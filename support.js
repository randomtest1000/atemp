(() => {
    var t = {
            7757: (t, d, h) => {
                t.exports = h(5666)
            },
            4260: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    LocalTimeElement: () => LocalTimeElement,
                    RelativeTimeElement: () => RelativeTimeElement,
                    TimeAgoElement: () => TimeAgoElement,
                    TimeUntilElement: () => TimeUntilElement
                });
                const y = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    _ = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

                function pad(t) {
                    return "0".concat(t).slice(-2)
                }

                function strftime(t, d) {
                    const h = t.getDay(),
                        x = t.getDate(),
                        C = t.getMonth(),
                        E = t.getFullYear(),
                        O = t.getHours(),
                        k = t.getMinutes(),
                        z = t.getSeconds();
                    return d.replace(/%([%aAbBcdeHIlmMpPSwyYZz])/g, (function(d) {
                        let A;
                        switch (d[1]) {
                            case "%":
                                return "%";
                            case "a":
                                return y[h].slice(0, 3);
                            case "A":
                                return y[h];
                            case "b":
                                return _[C].slice(0, 3);
                            case "B":
                                return _[C];
                            case "c":
                                return t.toString();
                            case "d":
                                return pad(x);
                            case "e":
                                return String(x);
                            case "H":
                                return pad(O);
                            case "I":
                                return pad(strftime(t, "%l"));
                            case "l":
                                return String(0 === O || 12 === O ? 12 : (O + 12) % 12);
                            case "m":
                                return pad(C + 1);
                            case "M":
                                return pad(k);
                            case "p":
                                return O > 11 ? "PM" : "AM";
                            case "P":
                                return O > 11 ? "pm" : "am";
                            case "S":
                                return pad(z);
                            case "w":
                                return String(h);
                            case "y":
                                return pad(E % 100);
                            case "Y":
                                return String(E);
                            case "Z":
                                return A = t.toString().match(/\((\w+)\)$/), A ? A[1] : "";
                            case "z":
                                return A = t.toString().match(/\w([+-]\d\d\d\d) /), A ? A[1] : ""
                        }
                        return ""
                    }))
                }

                function makeFormatter(t) {
                    let d;
                    return function() {
                        if (d) return d;
                        if ("Intl" in window) try {
                            return d = new Intl.DateTimeFormat(void 0, t), d
                        } catch (h) {
                            if (!(h instanceof RangeError)) throw h
                        }
                    }
                }
                let x = null;
                const C = makeFormatter({
                    day: "numeric",
                    month: "short"
                });

                function isDayFirst() {
                    if (null !== x) return x;
                    const t = C();
                    if (t) {
                        const d = t.format(new Date(0));
                        return x = !!d.match(/^\d/), x
                    }
                    return !1
                }
                let E = null;
                const O = makeFormatter({
                    day: "numeric",
                    month: "short",
                    year: "numeric"
                });

                function localeFromElement(t) {
                    const d = t.closest("[lang]");
                    return d instanceof HTMLElement && d.lang ? d.lang : "default"
                }
                const k = new WeakMap;
                class ExtendedTimeElement extends HTMLElement {
                    static get observedAttributes() {
                        return ["datetime", "day", "format", "lang", "hour", "minute", "month", "second", "title", "weekday", "year"]
                    }
                    connectedCallback() {
                        const t = this.getFormattedTitle();
                        t && !this.hasAttribute("title") && this.setAttribute("title", t);
                        const d = this.getFormattedDate();
                        d && (this.textContent = d)
                    }
                    attributeChangedCallback(t, d, h) {
                        const y = this.getFormattedTitle();
                        if ("datetime" === t) {
                            const t = Date.parse(h);
                            isNaN(t) ? k.delete(this) : k.set(this, new Date(t))
                        }
                        const _ = this.getFormattedTitle(),
                            x = this.getAttribute("title");
                        "title" === t || !_ || x && x !== y || this.setAttribute("title", _);
                        const C = this.getFormattedDate();
                        C && (this.textContent = C)
                    }
                    get date() {
                        return k.get(this)
                    }
                    getFormattedTitle() {
                        const t = this.date;
                        if (!t) return;
                        const d = z();
                        if (d) return d.format(t);
                        try {
                            return t.toLocaleString()
                        } catch (h) {
                            if (h instanceof RangeError) return t.toString();
                            throw h
                        }
                    }
                    getFormattedDate() {}
                }
                const z = makeFormatter({
                        day: "numeric",
                        month: "short",
                        year: "numeric",
                        hour: "numeric",
                        minute: "2-digit",
                        timeZoneName: "short"
                    }),
                    A = new WeakMap;
                class LocalTimeElement extends ExtendedTimeElement {
                    attributeChangedCallback(t, d, h) {
                        "hour" !== t && "minute" !== t && "second" !== t && "time-zone-name" !== t || A.delete(this), super.attributeChangedCallback(t, d, h)
                    }
                    getFormattedDate() {
                        const t = this.date;
                        if (!t) return;
                        const d = function formatDate(t, d) {
                                const h = {
                                    weekday: {
                                        short: "%a",
                                        long: "%A"
                                    },
                                    day: {
                                        numeric: "%e",
                                        "2-digit": "%d"
                                    },
                                    month: {
                                        short: "%b",
                                        long: "%B"
                                    },
                                    year: {
                                        numeric: "%Y",
                                        "2-digit": "%y"
                                    }
                                };
                                let y = isDayFirst() ? "weekday day month year" : "weekday month day, year";
                                for (const _ in h) {
                                    const d = h[_][t.getAttribute(_)];
                                    y = y.replace(_, d || "")
                                }
                                return y = y.replace(/(\s,)|(,\s$)/, ""), strftime(d, y).replace(/\s+/, " ").trim()
                            }(this, t) || "",
                            h = function formatTime(t, d) {
                                const h = {},
                                    y = t.getAttribute("hour");
                                "numeric" !== y && "2-digit" !== y || (h.hour = y);
                                const _ = t.getAttribute("minute");
                                "numeric" !== _ && "2-digit" !== _ || (h.minute = _);
                                const x = t.getAttribute("second");
                                "numeric" !== x && "2-digit" !== x || (h.second = x);
                                const C = t.getAttribute("time-zone-name");
                                "short" !== C && "long" !== C || (h.timeZoneName = C);
                                if (0 === Object.keys(h).length) return;
                                let E = A.get(t);
                                E || (E = makeFormatter(h), A.set(t, E));
                                const O = E();
                                if (O) return O.format(d);
                                return strftime(d, h.second ? "%H:%M:%S" : "%H:%M")
                            }(this, t) || "";
                        return "".concat(d, " ").concat(h).trim()
                    }
                }
                window.customElements.get("local-time") || (window.LocalTimeElement = LocalTimeElement, window.customElements.define("local-time", LocalTimeElement));
                class RelativeTime {
                    constructor(t, d) {
                        this.date = t, this.locale = d
                    }
                    toString() {
                        const t = this.timeElapsed();
                        if (t) return t; {
                            const t = this.timeAhead();
                            return t || "on ".concat(this.formatDate())
                        }
                    }
                    timeElapsed() {
                        const t = (new Date).getTime() - this.date.getTime(),
                            d = Math.round(t / 1e3),
                            h = Math.round(d / 60),
                            y = Math.round(h / 60),
                            _ = Math.round(y / 24);
                        return t >= 0 && _ < 30 ? this.timeAgoFromMs(t) : null
                    }
                    timeAhead() {
                        const t = this.date.getTime() - (new Date).getTime(),
                            d = Math.round(t / 1e3),
                            h = Math.round(d / 60),
                            y = Math.round(h / 60),
                            _ = Math.round(y / 24);
                        return t >= 0 && _ < 30 ? this.timeUntil() : null
                    }
                    timeAgo() {
                        const t = (new Date).getTime() - this.date.getTime();
                        return this.timeAgoFromMs(t)
                    }
                    timeAgoFromMs(t) {
                        const d = Math.round(t / 1e3),
                            h = Math.round(d / 60),
                            y = Math.round(h / 60),
                            _ = Math.round(y / 24),
                            x = Math.round(_ / 30),
                            C = Math.round(x / 12);
                        return t < 0 || d < 10 ? formatRelativeTime(this.locale, 0, "second") : d < 45 ? formatRelativeTime(this.locale, -d, "second") : d < 90 || h < 45 ? formatRelativeTime(this.locale, -h, "minute") : h < 90 || y < 24 ? formatRelativeTime(this.locale, -y, "hour") : y < 36 || _ < 30 ? formatRelativeTime(this.locale, -_, "day") : x < 18 ? formatRelativeTime(this.locale, -x, "month") : formatRelativeTime(this.locale, -C, "year")
                    }
                    microTimeAgo() {
                        const t = (new Date).getTime() - this.date.getTime(),
                            d = Math.round(t / 1e3),
                            h = Math.round(d / 60),
                            y = Math.round(h / 60),
                            _ = Math.round(y / 24),
                            x = Math.round(_ / 30),
                            C = Math.round(x / 12);
                        return h < 1 ? "1m" : h < 60 ? "".concat(h, "m") : y < 24 ? "".concat(y, "h") : _ < 365 ? "".concat(_, "d") : "".concat(C, "y")
                    }
                    timeUntil() {
                        const t = this.date.getTime() - (new Date).getTime();
                        return this.timeUntilFromMs(t)
                    }
                    timeUntilFromMs(t) {
                        const d = Math.round(t / 1e3),
                            h = Math.round(d / 60),
                            y = Math.round(h / 60),
                            _ = Math.round(y / 24),
                            x = Math.round(_ / 30),
                            C = Math.round(x / 12);
                        return x >= 18 || x >= 12 ? formatRelativeTime(this.locale, C, "year") : _ >= 45 || _ >= 30 ? formatRelativeTime(this.locale, x, "month") : y >= 36 || y >= 24 ? formatRelativeTime(this.locale, _, "day") : h >= 90 || h >= 45 ? formatRelativeTime(this.locale, y, "hour") : d >= 90 || d >= 45 ? formatRelativeTime(this.locale, h, "minute") : formatRelativeTime(this.locale, d >= 10 ? d : 0, "second")
                    }
                    microTimeUntil() {
                        const t = this.date.getTime() - (new Date).getTime(),
                            d = Math.round(t / 1e3),
                            h = Math.round(d / 60),
                            y = Math.round(h / 60),
                            _ = Math.round(y / 24),
                            x = Math.round(_ / 30),
                            C = Math.round(x / 12);
                        return _ >= 365 ? "".concat(C, "y") : y >= 24 ? "".concat(_, "d") : h >= 60 ? "".concat(y, "h") : h > 1 ? "".concat(h, "m") : "1m"
                    }
                    formatDate() {
                        let t = isDayFirst() ? "%e %b" : "%b %e";
                        return function isThisYear(t) {
                            return (new Date).getUTCFullYear() === t.getUTCFullYear()
                        }(this.date) || (t += function isYearSeparator() {
                            if (null !== E) return E;
                            const t = O();
                            if (t) {
                                const d = t.format(new Date(0));
                                return E = !!d.match(/\d,/), E
                            }
                            return !0
                        }() ? ", %Y" : " %Y"), strftime(this.date, t)
                    }
                    formatTime() {
                        const t = B();
                        return t ? t.format(this.date) : strftime(this.date, "%l:%M%P")
                    }
                }

                function formatRelativeTime(t, d, h) {
                    const y = function makeRelativeFormat(t, d) {
                        if ("Intl" in window && "RelativeTimeFormat" in window.Intl) try {
                            return new Intl.RelativeTimeFormat(t, d)
                        } catch (h) {
                            if (!(h instanceof RangeError)) throw h
                        }
                    }(t, {
                        numeric: "auto"
                    });
                    return y ? y.format(d, h) : function formatEnRelativeTime(t, d) {
                        if (0 === t) switch (d) {
                            case "year":
                            case "quarter":
                            case "month":
                            case "week":
                                return "this ".concat(d);
                            case "day":
                                return "today";
                            case "hour":
                            case "minute":
                                return "in 0 ".concat(d, "s");
                            case "second":
                                return "now"
                        } else if (1 === t) switch (d) {
                            case "year":
                            case "quarter":
                            case "month":
                            case "week":
                                return "next ".concat(d);
                            case "day":
                                return "tomorrow";
                            case "hour":
                            case "minute":
                            case "second":
                                return "in 1 ".concat(d)
                        } else if (-1 === t) switch (d) {
                            case "year":
                            case "quarter":
                            case "month":
                            case "week":
                                return "last ".concat(d);
                            case "day":
                                return "yesterday";
                            case "hour":
                            case "minute":
                            case "second":
                                return "1 ".concat(d, " ago")
                        } else if (t > 1) switch (d) {
                            case "year":
                            case "quarter":
                            case "month":
                            case "week":
                            case "day":
                            case "hour":
                            case "minute":
                            case "second":
                                return "in ".concat(t, " ").concat(d, "s")
                        } else if (t < -1) switch (d) {
                            case "year":
                            case "quarter":
                            case "month":
                            case "week":
                            case "day":
                            case "hour":
                            case "minute":
                            case "second":
                                return "".concat(-t, " ").concat(d, "s ago")
                        }
                        throw new RangeError("Invalid unit argument for format() '".concat(d, "'"))
                    }(d, h)
                }
                const B = makeFormatter({
                    hour: "numeric",
                    minute: "2-digit"
                });
                class RelativeTimeElement extends ExtendedTimeElement {
                    getFormattedDate() {
                        const t = this.date;
                        if (t) return new RelativeTime(t, localeFromElement(this)).toString()
                    }
                    connectedCallback() {
                        I.push(this), q || (updateNowElements(), q = setInterval(updateNowElements, 6e4)), super.connectedCallback()
                    }
                    disconnectedCallback() {
                        const t = I.indexOf(this); - 1 !== t && I.splice(t, 1), I.length || q && (clearInterval(q), q = null)
                    }
                }
                const I = [];
                let q;

                function updateNowElements() {
                    let t, d, h;
                    for (d = 0, h = I.length; d < h; d++) t = I[d], t.textContent = t.getFormattedDate() || ""
                }
                window.customElements.get("relative-time") || (window.RelativeTimeElement = RelativeTimeElement, window.customElements.define("relative-time", RelativeTimeElement));
                class TimeAgoElement extends RelativeTimeElement {
                    getFormattedDate() {
                        const t = this.getAttribute("format"),
                            d = this.date;
                        if (d) return "micro" === t ? new RelativeTime(d, localeFromElement(this)).microTimeAgo() : new RelativeTime(d, localeFromElement(this)).timeAgo()
                    }
                }
                window.customElements.get("time-ago") || (window.TimeAgoElement = TimeAgoElement, window.customElements.define("time-ago", TimeAgoElement));
                class TimeUntilElement extends RelativeTimeElement {
                    getFormattedDate() {
                        const t = this.getAttribute("format"),
                            d = this.date;
                        if (d) return "micro" === t ? new RelativeTime(d, localeFromElement(this)).microTimeUntil() : new RelativeTime(d, localeFromElement(this)).timeUntil()
                    }
                }
                window.customElements.get("time-until") || (window.TimeUntilElement = TimeUntilElement, window.customElements.define("time-until", TimeUntilElement))
            },
            2234: (t, d, h) => {
                "use strict";
                h.r(d);
                const y = !!navigator.userAgent.match(/Macintosh/);
                class Combobox {
                    constructor(t, d) {
                        this.input = t, this.list = d, this.isComposing = !1, d.id || (d.id = `combobox-${Math.random().toString().slice(2,6)}`), this.keyboardEventHandler = t => function keyboardBindings(t, d) {
                            if (t.shiftKey || t.metaKey || t.altKey) return;
                            if (!y && t.ctrlKey) return;
                            if (d.isComposing) return;
                            switch (t.key) {
                                case "Enter":
                                case "Tab":
                                    (function commit(t, d) {
                                        const h = d.querySelector('[aria-selected="true"]');
                                        return !!h && ("true" === h.getAttribute("aria-disabled") || h.click(), !0)
                                    })(d.input, d.list) && t.preventDefault();
                                    break;
                                case "Escape":
                                    d.clearSelection();
                                    break;
                                case "ArrowDown":
                                    d.navigate(1), t.preventDefault();
                                    break;
                                case "ArrowUp":
                                    d.navigate(-1), t.preventDefault();
                                    break;
                                case "n":
                                    y && t.ctrlKey && (d.navigate(1), t.preventDefault());
                                    break;
                                case "p":
                                    y && t.ctrlKey && (d.navigate(-1), t.preventDefault());
                                    break;
                                default:
                                    if (t.ctrlKey) break;
                                    d.clearSelection()
                            }
                        }(t, this), this.compositionEventHandler = t => function trackComposition(t, d) {
                            d.isComposing = "compositionstart" === t.type;
                            if (!document.getElementById(d.input.getAttribute("aria-controls") || "")) return;
                            d.clearSelection()
                        }(t, this), this.inputHandler = this.clearSelection.bind(this), t.setAttribute("role", "combobox"), t.setAttribute("aria-controls", d.id), t.setAttribute("aria-expanded", "false"), t.setAttribute("aria-autocomplete", "list"), t.setAttribute("aria-haspopup", "listbox")
                    }
                    destroy() {
                        this.clearSelection(), this.stop(), this.input.removeAttribute("role"), this.input.removeAttribute("aria-controls"), this.input.removeAttribute("aria-expanded"), this.input.removeAttribute("aria-autocomplete"), this.input.removeAttribute("aria-haspopup")
                    }
                    start() {
                        this.input.setAttribute("aria-expanded", "true"), this.input.addEventListener("compositionstart", this.compositionEventHandler), this.input.addEventListener("compositionend", this.compositionEventHandler), this.input.addEventListener("input", this.inputHandler), this.input.addEventListener("keydown", this.keyboardEventHandler), this.list.addEventListener("click", commitWithElement)
                    }
                    stop() {
                        this.clearSelection(), this.input.setAttribute("aria-expanded", "false"), this.input.removeEventListener("compositionstart", this.compositionEventHandler), this.input.removeEventListener("compositionend", this.compositionEventHandler), this.input.removeEventListener("input", this.inputHandler), this.input.removeEventListener("keydown", this.keyboardEventHandler), this.list.removeEventListener("click", commitWithElement)
                    }
                    navigate(t = 1) {
                        const d = Array.from(this.list.querySelectorAll('[aria-selected="true"]')).filter(visible)[0],
                            h = Array.from(this.list.querySelectorAll('[role="option"]')).filter(visible),
                            y = h.indexOf(d);
                        if (y === h.length - 1 && 1 === t || 0 === y && -1 === t) return this.clearSelection(), void this.input.focus();
                        let _ = 1 === t ? 0 : h.length - 1;
                        if (d && y >= 0) {
                            const d = y + t;
                            d >= 0 && d < h.length && (_ = d)
                        }
                        const x = h[_];
                        if (x)
                            for (const C of h) x === C ? (this.input.setAttribute("aria-activedescendant", x.id), x.setAttribute("aria-selected", "true"), scrollTo(this.list, x)) : C.setAttribute("aria-selected", "false")
                    }
                    clearSelection() {
                        this.input.removeAttribute("aria-activedescendant");
                        for (const t of this.list.querySelectorAll('[aria-selected="true"]')) t.setAttribute("aria-selected", "false")
                    }
                }

                function commitWithElement(t) {
                    if (!(t.target instanceof Element)) return;
                    const d = t.target.closest('[role="option"]');
                    d && "true" !== d.getAttribute("aria-disabled") && function fireCommitEvent(t) {
                        t.dispatchEvent(new CustomEvent("combobox-commit", {
                            bubbles: !0
                        }))
                    }(d)
                }

                function visible(t) {
                    return !t.hidden && !(t instanceof HTMLInputElement && "hidden" === t.type) && (t.offsetWidth > 0 || t.offsetHeight > 0)
                }

                function scrollTo(t, d) {
                    (function inViewport(t, d) {
                        const h = t.scrollTop,
                            y = h + t.clientHeight,
                            _ = d.offsetTop,
                            x = _ + d.clientHeight;
                        return _ >= h && x <= y
                    })(t, d) || (t.scrollTop = d.offsetTop)
                }
                class AutocompleteEvent extends CustomEvent {
                    constructor(t, d) {
                        super(t, d), this.relatedTarget = d.relatedTarget
                    }
                }
                const _ = new WeakMap;

                function fragment(t, d) {
                    const h = new XMLHttpRequest;
                    return h.open("GET", d, !0), h.setRequestHeader("Accept", "text/fragment+html"),
                        function request(t, d) {
                            const h = _.get(t);
                            h && h.abort();
                            _.set(t, d);
                            const clear = () => _.delete(t),
                                y = function send(t) {
                                    return new Promise(((d, h) => {
                                        t.onload = function() {
                                            t.status >= 200 && t.status < 300 ? d(t.responseText) : h(new Error(t.responseText))
                                        }, t.onerror = h, t.send()
                                    }))
                                }(d);
                            return y.then(clear, clear), y
                        }(t, h)
                }
                class Autocomplete {
                    constructor(t, d, h) {
                        this.container = t, this.input = d, this.results = h, this.combobox = new Combobox(d, h), this.results.hidden = !0, this.input.setAttribute("autocomplete", "off"), this.input.setAttribute("spellcheck", "false"), this.interactingWithList = !1, this.onInputChange = function debounce(t, d = 0) {
                            let h;
                            return function(...y) {
                                clearTimeout(h), h = window.setTimeout((() => {
                                    clearTimeout(h), t(...y)
                                }), d)
                            }
                        }(this.onInputChange.bind(this), 300), this.onResultsMouseDown = this.onResultsMouseDown.bind(this), this.onInputBlur = this.onInputBlur.bind(this), this.onInputFocus = this.onInputFocus.bind(this), this.onKeydown = this.onKeydown.bind(this), this.onCommit = this.onCommit.bind(this), this.input.addEventListener("keydown", this.onKeydown), this.input.addEventListener("focus", this.onInputFocus), this.input.addEventListener("blur", this.onInputBlur), this.input.addEventListener("input", this.onInputChange), this.results.addEventListener("mousedown", this.onResultsMouseDown), this.results.addEventListener("combobox-commit", this.onCommit)
                    }
                    destroy() {
                        this.input.removeEventListener("keydown", this.onKeydown), this.input.removeEventListener("focus", this.onInputFocus), this.input.removeEventListener("blur", this.onInputBlur), this.input.removeEventListener("input", this.onInputChange), this.results.removeEventListener("mousedown", this.onResultsMouseDown), this.results.removeEventListener("combobox-commit", this.onCommit)
                    }
                    onKeydown(t) {
                        if ("Escape" === t.key && this.container.open) this.container.open = !1, t.stopPropagation(), t.preventDefault();
                        else if (t.altKey && "ArrowUp" === t.key && this.container.open) this.container.open = !1, t.stopPropagation(), t.preventDefault();
                        else if (t.altKey && "ArrowDown" === t.key && !this.container.open) {
                            if (!this.input.value.trim()) return;
                            this.container.open = !0, t.stopPropagation(), t.preventDefault()
                        }
                    }
                    onInputFocus() {
                        this.fetchResults()
                    }
                    onInputBlur() {
                        this.interactingWithList ? this.interactingWithList = !1 : this.container.open = !1
                    }
                    onCommit({
                        target: t
                    }) {
                        const d = t;
                        if (!(d instanceof HTMLElement)) return;
                        if (this.container.open = !1, d instanceof HTMLAnchorElement) return;
                        const h = d.getAttribute("data-autocomplete-value") || d.textContent;
                        this.container.value = h
                    }
                    onResultsMouseDown() {
                        this.interactingWithList = !0
                    }
                    onInputChange() {
                        this.container.removeAttribute("value"), this.fetchResults()
                    }
                    identifyOptions() {
                        let t = 0;
                        for (const d of this.results.querySelectorAll('[role="option"]:not([id])')) d.id = `${this.results.id}-option-${t++}`
                    }
                    fetchResults() {
                        const t = this.input.value.trim();
                        if (!t) return void(this.container.open = !1);
                        const d = this.container.src;
                        if (!d) return;
                        const h = new URL(d, window.location.href),
                            y = new URLSearchParams(h.search.slice(1));
                        y.append("q", t), h.search = y.toString(), this.container.dispatchEvent(new CustomEvent("loadstart")), fragment(this.input, h.toString()).then((t => {
                            this.results.innerHTML = t, this.identifyOptions();
                            const d = !!this.results.querySelector('[role="option"]');
                            this.container.open = d, this.container.dispatchEvent(new CustomEvent("load")), this.container.dispatchEvent(new CustomEvent("loadend"))
                        })).catch((() => {
                            this.container.dispatchEvent(new CustomEvent("error")), this.container.dispatchEvent(new CustomEvent("loadend"))
                        }))
                    }
                    open() {
                        this.results.hidden && (this.combobox.start(), this.results.hidden = !1)
                    }
                    close() {
                        this.results.hidden || (this.combobox.stop(), this.results.hidden = !0)
                    }
                }
                const x = new WeakMap;
                class AutocompleteElement extends HTMLElement {
                    constructor() {
                        super()
                    }
                    connectedCallback() {
                        const t = this.getAttribute("for");
                        if (!t) return;
                        const d = this.querySelector("input"),
                            h = document.getElementById(t);
                        d instanceof HTMLInputElement && h && (x.set(this, new Autocomplete(this, d, h)), h.setAttribute("role", "listbox"))
                    }
                    disconnectedCallback() {
                        const t = x.get(this);
                        t && (t.destroy(), x.delete(this))
                    }
                    get src() {
                        return this.getAttribute("src") || ""
                    }
                    set src(t) {
                        this.setAttribute("src", t)
                    }
                    get value() {
                        return this.getAttribute("value") || ""
                    }
                    set value(t) {
                        this.setAttribute("value", t)
                    }
                    get open() {
                        return this.hasAttribute("open")
                    }
                    set open(t) {
                        t ? this.setAttribute("open", "") : this.removeAttribute("open")
                    }
                    static get observedAttributes() {
                        return ["open", "value"]
                    }
                    attributeChangedCallback(t, d, h) {
                        if (d === h) return;
                        const y = x.get(this);
                        if (y) switch (t) {
                            case "open":
                                null === h ? y.close() : y.open();
                                break;
                            case "value":
                                null !== h && (y.input.value = h), this.dispatchEvent(new AutocompleteEvent("auto-complete-change", {
                                    bubbles: !0,
                                    relatedTarget: y.input
                                }))
                        }
                    }
                }
                window.customElements.get("auto-complete") || (window.AutocompleteElement = AutocompleteElement, window.customElements.define("auto-complete", AutocompleteElement));

                function copyNode(t) {
                    if ("clipboard" in navigator) return navigator.clipboard.writeText(t.textContent);
                    const d = getSelection();
                    if (null == d) return Promise.reject(new Error);
                    d.removeAllRanges();
                    const h = document.createRange();
                    return h.selectNodeContents(t), d.addRange(h), document.execCommand("copy"), d.removeAllRanges(), Promise.resolve()
                }

                function copyText(t) {
                    if ("clipboard" in navigator) return navigator.clipboard.writeText(t);
                    const d = document.body;
                    if (!d) return Promise.reject(new Error);
                    const h = function createNode(t) {
                        const d = document.createElement("pre");
                        return d.style.width = "1px", d.style.height = "1px", d.style.position = "fixed", d.style.top = "5px", d.textContent = t, d
                    }(t);
                    return d.appendChild(h), copyNode(h), d.removeChild(h), Promise.resolve()
                }

                function copy(t) {
                    const d = t.getAttribute("for"),
                        h = t.getAttribute("value");

                    function trigger() {
                        t.dispatchEvent(new CustomEvent("clipboard-copy", {
                            bubbles: !0
                        }))
                    }
                    if (h) copyText(h).then(trigger);
                    else if (d) {
                        const h = "getRootNode" in Element.prototype ? t.getRootNode() : t.ownerDocument;
                        if (!(h instanceof Document || "ShadowRoot" in window && h instanceof ShadowRoot)) return;
                        const y = h.getElementById(d);
                        y && function copyTarget(t) {
                            return t instanceof HTMLInputElement || t instanceof HTMLTextAreaElement ? copyText(t.value) : t instanceof HTMLAnchorElement && t.hasAttribute("href") ? copyText(t.href) : copyNode(t)
                        }(y).then(trigger)
                    }
                }

                function clicked(t) {
                    const d = t.currentTarget;
                    d instanceof HTMLElement && copy(d)
                }

                function keydown(t) {
                    if (" " === t.key || "Enter" === t.key) {
                        const d = t.currentTarget;
                        d instanceof HTMLElement && (t.preventDefault(), copy(d))
                    }
                }

                function focused(t) {
                    t.currentTarget.addEventListener("keydown", keydown)
                }

                function blurred(t) {
                    t.currentTarget.removeEventListener("keydown", keydown)
                }
                class ClipboardCopyElement extends HTMLElement {
                    constructor() {
                        super(), this.addEventListener("click", clicked), this.addEventListener("focus", focused), this.addEventListener("blur", blurred)
                    }
                    connectedCallback() {
                        this.hasAttribute("tabindex") || this.setAttribute("tabindex", "0"), this.hasAttribute("role") || this.setAttribute("role", "button")
                    }
                    get value() {
                        return this.getAttribute("value") || ""
                    }
                    set value(t) {
                        this.setAttribute("value", t)
                    }
                }
                window.customElements.get("clipboard-copy") || (window.ClipboardCopyElement = ClipboardCopyElement, window.customElements.define("clipboard-copy", ClipboardCopyElement));

                function toggleSVG(t) {
                    "" === t.style.display || "block" === t.style.display ? t.style.display = "none" : t.style.display = "block"
                }

                function toggleCopyButton(t) {
                    const [d, h] = t.querySelectorAll(".octicon");
                    d && h && (toggleSVG(d), toggleSVG(h))
                }

                function getTabs(t) {
                    return Array.from(t.querySelectorAll('[role="tablist"] [role="tab"]')).filter((d => d instanceof HTMLElement && d.closest(t.tagName) === t))
                }
                document.addEventListener("clipboard-copy", (function({
                    target: t
                }) {
                    t instanceof HTMLElement && (toggleCopyButton(t), setTimeout(toggleCopyButton, 2e3, t))
                }));
                class TabContainerElement extends HTMLElement {
                    constructor() {
                        super(), this.addEventListener("keydown", (t => {
                            const d = t.target;
                            if (!(d instanceof HTMLElement)) return;
                            if (d.closest(this.tagName) !== this) return;
                            if ("tab" !== d.getAttribute("role") && !d.closest('[role="tablist"]')) return;
                            const h = getTabs(this),
                                y = h.indexOf(h.find((t => t.matches('[aria-selected="true"]'))));
                            if ("ArrowRight" === t.code) {
                                let t = y + 1;
                                t >= h.length && (t = 0), selectTab(this, t)
                            } else if ("ArrowLeft" === t.code) {
                                let t = y - 1;
                                t < 0 && (t = h.length - 1), selectTab(this, t)
                            } else "Home" === t.code ? (selectTab(this, 0), t.preventDefault()) : "End" === t.code && (selectTab(this, h.length - 1), t.preventDefault())
                        })), this.addEventListener("click", (t => {
                            const d = getTabs(this);
                            if (!(t.target instanceof Element)) return;
                            if (t.target.closest(this.tagName) !== this) return;
                            const h = t.target.closest('[role="tab"]');
                            if (!(h instanceof HTMLElement && h.closest('[role="tablist"]'))) return;
                            selectTab(this, d.indexOf(h))
                        }))
                    }
                    connectedCallback() {
                        for (const t of getTabs(this)) t.hasAttribute("aria-selected") || t.setAttribute("aria-selected", "false"), t.hasAttribute("tabindex") || ("true" === t.getAttribute("aria-selected") ? t.setAttribute("tabindex", "0") : t.setAttribute("tabindex", "-1"))
                    }
                }

                function selectTab(t, d) {
                    const h = getTabs(t),
                        y = Array.from(t.querySelectorAll('[role="tabpanel"]')).filter((d => d.closest(t.tagName) === t)),
                        _ = h[d],
                        x = y[d];
                    if (!!t.dispatchEvent(new CustomEvent("tab-container-change", {
                            bubbles: !0,
                            cancelable: !0,
                            detail: {
                                relatedTarget: x
                            }
                        }))) {
                        for (const t of h) t.setAttribute("aria-selected", "false"), t.setAttribute("tabindex", "-1");
                        for (const t of y) t.hidden = !0, t.hasAttribute("tabindex") || t.hasAttribute("data-tab-container-no-tabstop") || t.setAttribute("tabindex", "0");
                        _.setAttribute("aria-selected", "true"), _.setAttribute("tabindex", "0"), _.focus(), x.hidden = !1, t.dispatchEvent(new CustomEvent("tab-container-changed", {
                            bubbles: !0,
                            detail: {
                                relatedTarget: x
                            }
                        }))
                    }
                }
                window.customElements.get("tab-container") || (window.TabContainerElement = TabContainerElement, window.customElements.define("tab-container", TabContainerElement));
                h(4260);
                const C = new WeakMap,
                    E = new WeakMap,
                    O = new WeakMap;

                function moveCropArea(t) {
                    const d = t.currentTarget;
                    if (!(d instanceof ImageCropElement)) return;
                    const {
                        box: h,
                        image: y
                    } = O.get(d) || {};
                    if (!h || !y) return;
                    let _ = 0,
                        x = 0;
                    if (t instanceof KeyboardEvent) "ArrowUp" === t.key ? x = -1 : "ArrowDown" === t.key ? x = 1 : "ArrowLeft" === t.key ? _ = -1 : "ArrowRight" === t.key && (_ = 1);
                    else if (E.has(d) && t instanceof MouseEvent) {
                        const h = E.get(d);
                        _ = t.pageX - h.dragStartX, x = t.pageY - h.dragStartY
                    } else if (E.has(d) && t instanceof TouchEvent) {
                        const {
                            pageX: h,
                            pageY: y
                        } = t.changedTouches[0], {
                            dragStartX: C,
                            dragStartY: O
                        } = E.get(d);
                        _ = h - C, x = y - O
                    }
                    if (0 !== _ || 0 !== x) {
                        const t = Math.min(Math.max(0, h.offsetLeft + _), y.width - h.offsetWidth),
                            C = Math.min(Math.max(0, h.offsetTop + x), y.height - h.offsetHeight);
                        h.style.left = `${t}px`, h.style.top = `${C}px`, fireChangeEvent(d, {
                            x: t,
                            y: C,
                            width: h.offsetWidth,
                            height: h.offsetHeight
                        })
                    }
                    if (t instanceof MouseEvent) E.set(d, {
                        dragStartX: t.pageX,
                        dragStartY: t.pageY
                    });
                    else if (t instanceof TouchEvent) {
                        const {
                            pageX: h,
                            pageY: y
                        } = t.changedTouches[0];
                        E.set(d, {
                            dragStartX: h,
                            dragStartY: y
                        })
                    }
                }

                function updateCropArea(t) {
                    const d = t.target;
                    if (!(d instanceof HTMLElement)) return;
                    const h = getShadowHost(d);
                    if (!(h instanceof ImageCropElement)) return;
                    const {
                        box: y
                    } = O.get(h) || {};
                    if (!y) return;
                    const _ = h.getBoundingClientRect();
                    let x, E, k;
                    if (t instanceof KeyboardEvent) {
                        if ("Escape" === t.key) return setInitialPosition(h);
                        if ("-" === t.key && (k = -10), "=" === t.key && (k = 10), !k) return;
                        x = y.offsetWidth + k, E = y.offsetHeight + k, C.set(h, {
                            startX: y.offsetLeft,
                            startY: y.offsetTop
                        })
                    } else if (t instanceof MouseEvent) {
                        const d = C.get(h);
                        if (!d) return;
                        x = t.pageX - d.startX - _.left - window.pageXOffset, E = t.pageY - d.startY - _.top - window.pageYOffset
                    } else if (t instanceof TouchEvent) {
                        const d = C.get(h);
                        if (!d) return;
                        x = t.changedTouches[0].pageX - d.startX - _.left - window.pageXOffset, E = t.changedTouches[0].pageY - d.startY - _.top - window.pageYOffset
                    }
                    x && E && updateDimensions(h, x, E, !(t instanceof KeyboardEvent))
                }

                function getShadowHost(t) {
                    const d = t.getRootNode();
                    return d instanceof ShadowRoot ? d.host : t
                }

                function startUpdate(t) {
                    const d = t.currentTarget;
                    if (!(d instanceof HTMLElement)) return;
                    const h = getShadowHost(d);
                    if (!(h instanceof ImageCropElement)) return;
                    const {
                        box: y
                    } = O.get(h) || {};
                    if (!y) return;
                    const _ = t.target;
                    if (_ instanceof HTMLElement)
                        if (_.hasAttribute("data-direction")) {
                            const d = _.getAttribute("data-direction") || "";
                            h.addEventListener("mousemove", updateCropArea), h.addEventListener("touchmove", updateCropArea, {
                                passive: !0
                            }), ["nw", "se"].indexOf(d) >= 0 && h.classList.add("nwse"), ["ne", "sw"].indexOf(d) >= 0 && h.classList.add("nesw"), C.set(h, {
                                startX: y.offsetLeft + (["se", "ne"].indexOf(d) >= 0 ? 0 : y.offsetWidth),
                                startY: y.offsetTop + (["se", "sw"].indexOf(d) >= 0 ? 0 : y.offsetHeight)
                            }), updateCropArea(t)
                        } else h.addEventListener("mousemove", moveCropArea), h.addEventListener("touchmove", moveCropArea, {
                            passive: !0
                        })
                }

                function updateDimensions(t, d, h, y = !0) {
                    let _ = Math.max(Math.abs(d), Math.abs(h), 10);
                    const x = C.get(t);
                    if (!x) return;
                    const {
                        box: E,
                        image: k
                    } = O.get(t) || {};
                    if (!E || !k) return;
                    _ = Math.min(_, h > 0 ? k.height - x.startY : x.startY, d > 0 ? k.width - x.startX : x.startX);
                    const z = y ? Math.round(Math.max(0, d > 0 ? x.startX : x.startX - _)) : E.offsetLeft,
                        A = y ? Math.round(Math.max(0, h > 0 ? x.startY : x.startY - _)) : E.offsetTop;
                    E.style.left = `${z}px`, E.style.top = `${A}px`, E.style.width = `${_}px`, E.style.height = `${_}px`, fireChangeEvent(t, {
                        x: z,
                        y: A,
                        width: _,
                        height: _
                    })
                }

                function setInitialPosition(t) {
                    const {
                        image: d
                    } = O.get(t) || {};
                    if (!d) return;
                    const h = Math.round(d.clientWidth > d.clientHeight ? d.clientHeight : d.clientWidth);
                    C.set(t, {
                        startX: (d.clientWidth - h) / 2,
                        startY: (d.clientHeight - h) / 2
                    }), updateDimensions(t, h, h)
                }

                function stopUpdate(t) {
                    const d = t.currentTarget;
                    d instanceof ImageCropElement && (E.delete(d), d.classList.remove("nwse", "nesw"), d.removeEventListener("mousemove", updateCropArea), d.removeEventListener("mousemove", moveCropArea), d.removeEventListener("touchmove", updateCropArea), d.removeEventListener("touchmove", moveCropArea))
                }

                function fireChangeEvent(t, d) {
                    const {
                        image: h
                    } = O.get(t) || {};
                    if (!h) return;
                    const y = h.naturalWidth / h.width;
                    for (const _ in d) {
                        const h = Math.round(d[_] * y);
                        d[_] = h;
                        const x = t.querySelector(`[data-image-crop-input='${_}']`);
                        x instanceof HTMLInputElement && (x.value = h.toString())
                    }
                    t.dispatchEvent(new CustomEvent("image-crop-change", {
                        bubbles: !0,
                        detail: d
                    }))
                }
                class ImageCropElement extends HTMLElement {
                    connectedCallback() {
                        if (O.has(this)) return;
                        const t = this.attachShadow({
                            mode: "open"
                        });
                        t.innerHTML = '\n<style>\n  :host { touch-action: none; display: block; }\n  :host(.nesw) { cursor: nesw-resize; }\n  :host(.nwse) { cursor: nwse-resize; }\n  :host(.nesw) .crop-box, :host(.nwse) .crop-box { cursor: inherit; }\n  :host([loaded]) .crop-image { display: block; }\n  :host([loaded]) ::slotted([data-loading-slot]), .crop-image { display: none; }\n\n  .crop-wrapper {\n    position: relative;\n    font-size: 0;\n  }\n  .crop-container {\n    user-select: none;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    position: absolute;\n    overflow: hidden;\n    z-index: 1;\n    top: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  :host([rounded]) .crop-box {\n    border-radius: 50%;\n    box-shadow: 0 0 0 4000px rgba(0, 0, 0, 0.3);\n  }\n  .crop-box {\n    position: absolute;\n    border: 1px dashed #fff;\n    box-sizing: border-box;\n    cursor: move;\n  }\n\n  :host([rounded]) .crop-outline {\n    outline: none;\n  }\n  .crop-outline {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    outline: 4000px solid rgba(0, 0, 0, .3);\n  }\n\n  .handle { position: absolute; }\n  :host([rounded]) .handle::before { border-radius: 50%; }\n  .handle:before {\n    position: absolute;\n    display: block;\n    padding: 4px;\n    transform: translate(-50%, -50%);\n    content: \' \';\n    background: #fff;\n    border: 1px solid #767676;\n  }\n  .ne { top: 0; right: 0; cursor: nesw-resize; }\n  .nw { top: 0; left: 0; cursor: nwse-resize; }\n  .se { bottom: 0; right: 0; cursor: nwse-resize; }\n  .sw { bottom: 0; left: 0; cursor: nesw-resize; }\n</style>\n<slot></slot>\n<div class="crop-wrapper">\n  <img width="100%" class="crop-image" alt="">\n  <div class="crop-container">\n    <div data-crop-box class="crop-box">\n      <div class="crop-outline"></div>\n      <div data-direction="nw" class="handle nw"></div>\n      <div data-direction="ne" class="handle ne"></div>\n      <div data-direction="sw" class="handle sw"></div>\n      <div data-direction="se" class="handle se"></div>\n    </div>\n  </div>\n</div>\n';
                        const d = t.querySelector("[data-crop-box]");
                        if (!(d instanceof HTMLElement)) return;
                        const h = t.querySelector("img");
                        h instanceof HTMLImageElement && (O.set(this, {
                            box: d,
                            image: h
                        }), h.addEventListener("load", (() => {
                            this.loaded = !0, setInitialPosition(this)
                        })), this.addEventListener("mouseleave", stopUpdate), this.addEventListener("touchend", stopUpdate), this.addEventListener("mouseup", stopUpdate), d.addEventListener("mousedown", startUpdate), d.addEventListener("touchstart", startUpdate, {
                            passive: !0
                        }), this.addEventListener("keydown", moveCropArea), this.addEventListener("keydown", updateCropArea), this.src && (h.src = this.src))
                    }
                    static get observedAttributes() {
                        return ["src"]
                    }
                    get src() {
                        return this.getAttribute("src")
                    }
                    set src(t) {
                        t ? this.setAttribute("src", t) : this.removeAttribute("src")
                    }
                    get loaded() {
                        return this.hasAttribute("loaded")
                    }
                    set loaded(t) {
                        t ? this.setAttribute("loaded", "") : this.removeAttribute("loaded")
                    }
                    attributeChangedCallback(t, d, h) {
                        const {
                            image: y
                        } = O.get(this) || {};
                        "src" === t && (this.loaded = !1, y && (y.src = h))
                    }
                }
                window.customElements.get("image-crop") || (window.ImageCropElement = ImageCropElement, window.customElements.define("image-crop", ImageCropElement))
            },
            7363: () => {
                (function() {
                    "use strict";
                    var t = window.Document.prototype.createElement,
                        d = window.Document.prototype.createElementNS,
                        h = window.Document.prototype.importNode,
                        y = window.Document.prototype.prepend,
                        _ = window.Document.prototype.append,
                        x = window.DocumentFragment.prototype.prepend,
                        C = window.DocumentFragment.prototype.append,
                        E = window.Node.prototype.cloneNode,
                        O = window.Node.prototype.appendChild,
                        k = window.Node.prototype.insertBefore,
                        z = window.Node.prototype.removeChild,
                        A = window.Node.prototype.replaceChild,
                        B = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
                        I = window.Element.prototype.attachShadow,
                        q = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
                        D = window.Element.prototype.getAttribute,
                        j = window.Element.prototype.setAttribute,
                        H = window.Element.prototype.removeAttribute,
                        $ = window.Element.prototype.getAttributeNS,
                        G = window.Element.prototype.setAttributeNS,
                        ee = window.Element.prototype.removeAttributeNS,
                        te = window.Element.prototype.insertAdjacentElement,
                        re = window.Element.prototype.insertAdjacentHTML,
                        ne = window.Element.prototype.prepend,
                        ie = window.Element.prototype.append,
                        oe = window.Element.prototype.before,
                        ae = window.Element.prototype.after,
                        se = window.Element.prototype.replaceWith,
                        le = window.Element.prototype.remove,
                        ce = window.HTMLElement,
                        ue = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML"),
                        de = window.HTMLElement.prototype.insertAdjacentElement,
                        pe = window.HTMLElement.prototype.insertAdjacentHTML,
                        me = new Set;

                    function qa(t) {
                        var d = me.has(t);
                        return t = /^[a-z][.0-9_a-z]*-[-.0-9_a-z]*$/.test(t), !d && t
                    }
                    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" ").forEach((function(t) {
                        return me.add(t)
                    }));
                    var fe = document.contains ? document.contains.bind(document) : document.documentElement.contains.bind(document.documentElement);

                    function J(t) {
                        var d = t.isConnected;
                        if (void 0 !== d) return d;
                        if (fe(t)) return !0;
                        for (; t && !(t.__CE_isImportDocument || t instanceof Document);) t = t.parentNode || (window.ShadowRoot && t instanceof ShadowRoot ? t.host : void 0);
                        return !(!t || !(t.__CE_isImportDocument || t instanceof Document))
                    }

                    function K(t) {
                        var d = t.children;
                        if (d) return Array.prototype.slice.call(d);
                        for (d = [], t = t.firstChild; t; t = t.nextSibling) t.nodeType === Node.ELEMENT_NODE && d.push(t);
                        return d
                    }

                    function L(t, d) {
                        for (; d && d !== t && !d.nextSibling;) d = d.parentNode;
                        return d && d !== t ? d.nextSibling : null
                    }

                    function M(t, d, h) {
                        for (var y = t; y;) {
                            if (y.nodeType === Node.ELEMENT_NODE) {
                                var _ = y;
                                d(_);
                                var x = _.localName;
                                if ("link" === x && "import" === _.getAttribute("rel")) {
                                    if (y = _.import, void 0 === h && (h = new Set), y instanceof Node && !h.has(y))
                                        for (h.add(y), y = y.firstChild; y; y = y.nextSibling) M(y, d, h);
                                    y = L(t, _);
                                    continue
                                }
                                if ("template" === x) {
                                    y = L(t, _);
                                    continue
                                }
                                if (_ = _.__CE_shadowRoot)
                                    for (_ = _.firstChild; _; _ = _.nextSibling) M(_, d, h)
                            }
                            y = y.firstChild ? y.firstChild : L(t, y)
                        }
                    }

                    function N() {
                        var t = !(null == ye || !ye.noDocumentConstructionObserver),
                            d = !(null == ye || !ye.shadyDomFastWalk);
                        this.h = [], this.a = [], this.f = !1, this.shadyDomFastWalk = d, this.C = !t
                    }

                    function P(t, d, h, y) {
                        var _ = window.ShadyDom;
                        if (t.shadyDomFastWalk && _ && _.inUse) {
                            if (d.nodeType === Node.ELEMENT_NODE && h(d), d.querySelectorAll)
                                for (t = _.nativeMethods.querySelectorAll.call(d, "*"), d = 0; d < t.length; d++) h(t[d])
                        } else M(d, h, y)
                    }

                    function Q(t, d) {
                        t.f && P(t, d, (function(d) {
                            return R(t, d)
                        }))
                    }

                    function R(t, d) {
                        if (t.f && !d.__CE_patched) {
                            d.__CE_patched = !0;
                            for (var h = 0; h < t.h.length; h++) t.h[h](d);
                            for (h = 0; h < t.a.length; h++) t.a[h](d)
                        }
                    }

                    function S(t, d) {
                        var h = [];
                        for (P(t, d, (function(t) {
                                return h.push(t)
                            })), d = 0; d < h.length; d++) {
                            var y = h[d];
                            1 === y.__CE_state ? t.connectedCallback(y) : T(t, y)
                        }
                    }

                    function U(t, d) {
                        var h = [];
                        for (P(t, d, (function(t) {
                                return h.push(t)
                            })), d = 0; d < h.length; d++) {
                            var y = h[d];
                            1 === y.__CE_state && t.disconnectedCallback(y)
                        }
                    }

                    function V(t, d, h) {
                        var y = (h = void 0 === h ? {} : h).D,
                            _ = h.upgrade || function(d) {
                                return T(t, d)
                            },
                            x = [];
                        for (P(t, d, (function(d) {
                                if (t.f && R(t, d), "link" === d.localName && "import" === d.getAttribute("rel")) {
                                    var h = d.import;
                                    h instanceof Node && (h.__CE_isImportDocument = !0, h.__CE_registry = document.__CE_registry), h && "complete" === h.readyState ? h.__CE_documentLoadHandled = !0 : d.addEventListener("load", (function() {
                                        var h = d.import;
                                        if (!h.__CE_documentLoadHandled) {
                                            h.__CE_documentLoadHandled = !0;
                                            var x = new Set;
                                            y && (y.forEach((function(t) {
                                                return x.add(t)
                                            })), x.delete(h)), V(t, h, {
                                                D: x,
                                                upgrade: _
                                            })
                                        }
                                    }))
                                } else x.push(d)
                            }), y), d = 0; d < x.length; d++) _(x[d])
                    }

                    function T(t, d) {
                        try {
                            var h = d.ownerDocument,
                                y = h.__CE_registry,
                                _ = y && (h.defaultView || h.__CE_isImportDocument) ? W(y, d.localName) : void 0;
                            if (_ && void 0 === d.__CE_state) {
                                _.constructionStack.push(d);
                                try {
                                    try {
                                        if (new _.constructorFunction !== d) throw Error("The custom element constructor did not produce the element being upgraded.")
                                    } finally {
                                        _.constructionStack.pop()
                                    }
                                } catch (O) {
                                    throw d.__CE_state = 2, O
                                }
                                if (d.__CE_state = 1, d.__CE_definition = _, _.attributeChangedCallback && d.hasAttributes()) {
                                    var x = _.observedAttributes;
                                    for (_ = 0; _ < x.length; _++) {
                                        var C = x[_],
                                            E = d.getAttribute(C);
                                        null !== E && t.attributeChangedCallback(d, C, null, E, null)
                                    }
                                }
                                J(d) && t.connectedCallback(d)
                            }
                        } catch (O) {
                            X(O)
                        }
                    }

                    function ua(h, y, _, x) {
                        var C = y.__CE_registry;
                        if (C && (null === x || "http://www.w3.org/1999/xhtml" === x) && (C = W(C, _))) try {
                            var E = new C.constructorFunction;
                            if (void 0 === E.__CE_state || void 0 === E.__CE_definition) throw Error("Failed to construct '" + _ + "': The returned value was not constructed with the HTMLElement constructor.");
                            if ("http://www.w3.org/1999/xhtml" !== E.namespaceURI) throw Error("Failed to construct '" + _ + "': The constructed element's namespace must be the HTML namespace.");
                            if (E.hasAttributes()) throw Error("Failed to construct '" + _ + "': The constructed element must not have any attributes.");
                            if (null !== E.firstChild) throw Error("Failed to construct '" + _ + "': The constructed element must not have any children.");
                            if (null !== E.parentNode) throw Error("Failed to construct '" + _ + "': The constructed element must not have a parent node.");
                            if (E.ownerDocument !== y) throw Error("Failed to construct '" + _ + "': The constructed element's owner document is incorrect.");
                            if (E.localName !== _) throw Error("Failed to construct '" + _ + "': The constructed element's local name is incorrect.");
                            return E
                        } catch (O) {
                            return X(O), y = null === x ? t.call(y, _) : d.call(y, x, _), Object.setPrototypeOf(y, HTMLUnknownElement.prototype), y.__CE_state = 2, y.__CE_definition = void 0, R(h, y), y
                        }
                        return R(h, y = null === x ? t.call(y, _) : d.call(y, x, _)), y
                    }

                    function X(t) {
                        var d = t.message,
                            h = t.sourceURL || t.fileName || "",
                            y = t.line || t.lineNumber || 0,
                            _ = t.column || t.columnNumber || 0,
                            x = void 0;
                        void 0 === ErrorEvent.prototype.initErrorEvent ? x = new ErrorEvent("error", {
                            cancelable: !0,
                            message: d,
                            filename: h,
                            lineno: y,
                            colno: _,
                            error: t
                        }) : ((x = document.createEvent("ErrorEvent")).initErrorEvent("error", !1, !0, d, h, y), x.preventDefault = function() {
                            Object.defineProperty(this, "defaultPrevented", {
                                configurable: !0,
                                get: function() {
                                    return !0
                                }
                            })
                        }), void 0 === x.error && Object.defineProperty(x, "error", {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return t
                            }
                        }), window.dispatchEvent(x), x.defaultPrevented || console.error(t)
                    }

                    function va() {
                        var t = this;
                        this.a = void 0, this.w = new Promise((function(d) {
                            t.g = d
                        }))
                    }

                    function wa(t) {
                        var d = document;
                        this.g = void 0, this.b = t, this.a = d, V(this.b, this.a), "loading" === this.a.readyState && (this.g = new MutationObserver(this.A.bind(this)), this.g.observe(this.a, {
                            childList: !0,
                            subtree: !0
                        }))
                    }

                    function xa(t) {
                        t.g && t.g.disconnect()
                    }

                    function Y(t) {
                        this.j = new Map, this.l = new Map, this.u = new Map, this.o = !1, this.s = new Map, this.i = function(t) {
                            return t()
                        }, this.c = !1, this.m = [], this.b = t, this.v = t.C ? new wa(t) : void 0
                    }

                    function ya(t, d) {
                        if (!qa(d)) throw new SyntaxError("The element name '" + d + "' is not valid.");
                        if (W(t, d)) throw Error("A custom element with name '" + d + "' has already been defined.");
                        if (t.o) throw Error("A custom element is already being defined.")
                    }

                    function Aa(t, d, h) {
                        var y;
                        t.o = !0;
                        try {
                            var _ = h.prototype;
                            if (!(_ instanceof Object)) throw new TypeError("The custom element constructor's prototype is not an object.");
                            var e = function(t) {
                                    var d = _[t];
                                    if (void 0 !== d && !(d instanceof Function)) throw Error("The '" + t + "' callback must be a function.");
                                    return d
                                },
                                x = e("connectedCallback"),
                                C = e("disconnectedCallback"),
                                E = e("adoptedCallback"),
                                O = (y = e("attributeChangedCallback")) && h.observedAttributes || []
                        } catch (k) {
                            throw k
                        } finally {
                            t.o = !1
                        }
                        return h = {
                            localName: d,
                            constructorFunction: h,
                            connectedCallback: x,
                            disconnectedCallback: C,
                            adoptedCallback: E,
                            attributeChangedCallback: y,
                            observedAttributes: O,
                            constructionStack: []
                        }, t.l.set(d, h), t.u.set(h.constructorFunction, h), h
                    }

                    function za(t) {
                        if (!1 !== t.c) {
                            t.c = !1;
                            for (var d = [], h = t.m, y = new Map, _ = 0; _ < h.length; _++) y.set(h[_], []);
                            for (V(t.b, document, {
                                    upgrade: function(h) {
                                        if (void 0 === h.__CE_state) {
                                            var _ = h.localName,
                                                x = y.get(_);
                                            x ? x.push(h) : t.l.has(_) && d.push(h)
                                        }
                                    }
                                }), _ = 0; _ < d.length; _++) T(t.b, d[_]);
                            for (_ = 0; _ < h.length; _++) {
                                for (var x = h[_], C = y.get(x), E = 0; E < C.length; E++) T(t.b, C[E]);
                                (x = t.s.get(x)) && x.resolve(void 0)
                            }
                            h.length = 0
                        }
                    }

                    function W(t, d) {
                        var h = t.l.get(d);
                        if (h) return h;
                        if (h = t.j.get(d)) {
                            t.j.delete(d);
                            try {
                                return Aa(t, d, h())
                            } catch (y) {
                                X(y)
                            }
                        }
                    }

                    function Z(t, d, h) {
                        function f(d) {
                            return function(h) {
                                for (var y = [], _ = 0; _ < arguments.length; ++_) y[_] = arguments[_];
                                _ = [];
                                for (var x = [], C = 0; C < y.length; C++) {
                                    var E = y[C];
                                    if (E instanceof Element && J(E) && x.push(E), E instanceof DocumentFragment)
                                        for (E = E.firstChild; E; E = E.nextSibling) _.push(E);
                                    else _.push(E)
                                }
                                for (d.apply(this, y), y = 0; y < x.length; y++) U(t, x[y]);
                                if (J(this))
                                    for (y = 0; y < _.length; y++)(x = _[y]) instanceof Element && S(t, x)
                            }
                        }
                        void 0 !== h.prepend && (d.prepend = f(h.prepend)), void 0 !== h.append && (d.append = f(h.append))
                    }

                    function Da(t) {
                        function b(d, h) {
                            Object.defineProperty(d, "innerHTML", {
                                enumerable: h.enumerable,
                                configurable: !0,
                                get: h.get,
                                set: function(d) {
                                    var y = this,
                                        _ = void 0;
                                    if (J(this) && (_ = [], P(t, this, (function(t) {
                                            t !== y && _.push(t)
                                        }))), h.set.call(this, d), _)
                                        for (var x = 0; x < _.length; x++) {
                                            var C = _[x];
                                            1 === C.__CE_state && t.disconnectedCallback(C)
                                        }
                                    return this.ownerDocument.__CE_registry ? V(t, this) : Q(t, this), d
                                }
                            })
                        }

                        function c(d, h) {
                            d.insertAdjacentElement = function(d, y) {
                                var _ = J(y);
                                return d = h.call(this, d, y), _ && U(t, y), J(d) && S(t, y), d
                            }
                        }

                        function f(d, h) {
                            function g(d, h) {
                                for (var y = []; d !== h; d = d.nextSibling) y.push(d);
                                for (h = 0; h < y.length; h++) V(t, y[h])
                            }
                            d.insertAdjacentHTML = function(t, d) {
                                if ("beforebegin" === (t = t.toLowerCase())) {
                                    var y = this.previousSibling;
                                    h.call(this, t, d), g(y || this.parentNode.firstChild, this)
                                } else if ("afterbegin" === t) y = this.firstChild, h.call(this, t, d), g(this.firstChild, y);
                                else if ("beforeend" === t) y = this.lastChild, h.call(this, t, d), g(y || this.firstChild, null);
                                else {
                                    if ("afterend" !== t) throw new SyntaxError("The value provided (" + String(t) + ") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");
                                    y = this.nextSibling, h.call(this, t, d), g(this.nextSibling, y)
                                }
                            }
                        }
                        I && (Element.prototype.attachShadow = function(d) {
                                if (d = I.call(this, d), t.f && !d.__CE_patched) {
                                    d.__CE_patched = !0;
                                    for (var h = 0; h < t.h.length; h++) t.h[h](d)
                                }
                                return this.__CE_shadowRoot = d
                            }), q && q.get ? b(Element.prototype, q) : ue && ue.get ? b(HTMLElement.prototype, ue) : function ta(t, d) {
                                t.f = !0, t.a.push(d)
                            }(t, (function(t) {
                                b(t, {
                                    enumerable: !0,
                                    configurable: !0,
                                    get: function() {
                                        return E.call(this, !0).innerHTML
                                    },
                                    set: function(t) {
                                        var h = "template" === this.localName,
                                            y = h ? this.content : this,
                                            _ = d.call(document, this.namespaceURI, this.localName);
                                        for (_.innerHTML = t; 0 < y.childNodes.length;) z.call(y, y.childNodes[0]);
                                        for (t = h ? _.content : _; 0 < t.childNodes.length;) O.call(y, t.childNodes[0])
                                    }
                                })
                            })), Element.prototype.setAttribute = function(d, h) {
                                if (1 !== this.__CE_state) return j.call(this, d, h);
                                var y = D.call(this, d);
                                j.call(this, d, h), h = D.call(this, d), t.attributeChangedCallback(this, d, y, h, null)
                            }, Element.prototype.setAttributeNS = function(d, h, y) {
                                if (1 !== this.__CE_state) return G.call(this, d, h, y);
                                var _ = $.call(this, d, h);
                                G.call(this, d, h, y), y = $.call(this, d, h), t.attributeChangedCallback(this, h, _, y, d)
                            }, Element.prototype.removeAttribute = function(d) {
                                if (1 !== this.__CE_state) return H.call(this, d);
                                var h = D.call(this, d);
                                H.call(this, d), null !== h && t.attributeChangedCallback(this, d, h, null, null)
                            }, Element.prototype.removeAttributeNS = function(d, h) {
                                if (1 !== this.__CE_state) return ee.call(this, d, h);
                                var y = $.call(this, d, h);
                                ee.call(this, d, h);
                                var _ = $.call(this, d, h);
                                y !== _ && t.attributeChangedCallback(this, h, y, _, d)
                            }, de ? c(HTMLElement.prototype, de) : te && c(Element.prototype, te), pe ? f(HTMLElement.prototype, pe) : re && f(Element.prototype, re), Z(t, Element.prototype, {
                                prepend: ne,
                                append: ie
                            }),
                            function Ca(t) {
                                function b(d) {
                                    return function(h) {
                                        for (var y = [], _ = 0; _ < arguments.length; ++_) y[_] = arguments[_];
                                        _ = [];
                                        for (var x = [], C = 0; C < y.length; C++) {
                                            var E = y[C];
                                            if (E instanceof Element && J(E) && x.push(E), E instanceof DocumentFragment)
                                                for (E = E.firstChild; E; E = E.nextSibling) _.push(E);
                                            else _.push(E)
                                        }
                                        for (d.apply(this, y), y = 0; y < x.length; y++) U(t, x[y]);
                                        if (J(this))
                                            for (y = 0; y < _.length; y++)(x = _[y]) instanceof Element && S(t, x)
                                    }
                                }
                                var d = Element.prototype;
                                void 0 !== oe && (d.before = b(oe)), void 0 !== ae && (d.after = b(ae)), void 0 !== se && (d.replaceWith = function(d) {
                                    for (var h = [], y = 0; y < arguments.length; ++y) h[y] = arguments[y];
                                    y = [];
                                    for (var _ = [], x = 0; x < h.length; x++) {
                                        var C = h[x];
                                        if (C instanceof Element && J(C) && _.push(C), C instanceof DocumentFragment)
                                            for (C = C.firstChild; C; C = C.nextSibling) y.push(C);
                                        else y.push(C)
                                    }
                                    for (x = J(this), se.apply(this, h), h = 0; h < _.length; h++) U(t, _[h]);
                                    if (x)
                                        for (U(t, this), h = 0; h < y.length; h++)(_ = y[h]) instanceof Element && S(t, _)
                                }), void 0 !== le && (d.remove = function() {
                                    var d = J(this);
                                    le.call(this), d && U(t, this)
                                })
                            }(t)
                    }
                    N.prototype.connectedCallback = function(t) {
                        var d = t.__CE_definition;
                        if (d.connectedCallback) try {
                            d.connectedCallback.call(t)
                        } catch (h) {
                            X(h)
                        }
                    }, N.prototype.disconnectedCallback = function(t) {
                        var d = t.__CE_definition;
                        if (d.disconnectedCallback) try {
                            d.disconnectedCallback.call(t)
                        } catch (h) {
                            X(h)
                        }
                    }, N.prototype.attributeChangedCallback = function(t, d, h, y, _) {
                        var x = t.__CE_definition;
                        if (x.attributeChangedCallback && -1 < x.observedAttributes.indexOf(d)) try {
                            x.attributeChangedCallback.call(t, d, h, y, _)
                        } catch (C) {
                            X(C)
                        }
                    }, va.prototype.resolve = function(t) {
                        if (this.a) throw Error("Already resolved.");
                        this.a = t, this.g(t)
                    }, wa.prototype.A = function(t) {
                        var d = this.a.readyState;
                        for ("interactive" !== d && "complete" !== d || xa(this), d = 0; d < t.length; d++)
                            for (var h = t[d].addedNodes, y = 0; y < h.length; y++) V(this.b, h[y])
                    }, Y.prototype.B = function(t, d) {
                        var h = this;
                        if (!(d instanceof Function)) throw new TypeError("Custom element constructor getters must be functions.");
                        ya(this, t), this.j.set(t, d), this.m.push(t), this.c || (this.c = !0, this.i((function() {
                            return za(h)
                        })))
                    }, Y.prototype.define = function(t, d) {
                        var h = this;
                        if (!(d instanceof Function)) throw new TypeError("Custom element constructors must be functions.");
                        ya(this, t), Aa(this, t, d), this.m.push(t), this.c || (this.c = !0, this.i((function() {
                            return za(h)
                        })))
                    }, Y.prototype.upgrade = function(t) {
                        V(this.b, t)
                    }, Y.prototype.get = function(t) {
                        if (t = W(this, t)) return t.constructorFunction
                    }, Y.prototype.whenDefined = function(t) {
                        if (!qa(t)) return Promise.reject(new SyntaxError("'" + t + "' is not a valid custom element name."));
                        var d = this.s.get(t);
                        if (d) return d.w;
                        d = new va, this.s.set(t, d);
                        var h = this.l.has(t) || this.j.has(t);
                        return t = -1 === this.m.indexOf(t), h && t && d.resolve(void 0), d.w
                    }, Y.prototype.polyfillWrapFlushCallback = function(t) {
                        this.v && xa(this.v);
                        var d = this.i;
                        this.i = function(h) {
                            return t((function() {
                                return d(h)
                            }))
                        }
                    }, window.CustomElementRegistry = Y, Y.prototype.define = Y.prototype.define, Y.prototype.upgrade = Y.prototype.upgrade, Y.prototype.get = Y.prototype.get, Y.prototype.whenDefined = Y.prototype.whenDefined, Y.prototype.polyfillDefineLazy = Y.prototype.B, Y.prototype.polyfillWrapFlushCallback = Y.prototype.polyfillWrapFlushCallback;
                    var he = {};
                    var ye = window.customElements;

                    function Ha() {
                        var d = new N;
                        ! function Fa(d) {
                            function b() {
                                var h = this.constructor,
                                    y = document.__CE_registry.u.get(h);
                                if (!y) throw Error("Failed to construct a custom element: The constructor was not registered with `customElements`.");
                                var _ = y.constructionStack;
                                if (0 === _.length) return _ = t.call(document, y.localName), Object.setPrototypeOf(_, h.prototype), _.__CE_state = 1, _.__CE_definition = y, R(d, _), _;
                                var x = _.length - 1,
                                    C = _[x];
                                if (C === he) throw Error("Failed to construct '" + y.localName + "': This element was already constructed.");
                                return _[x] = he, Object.setPrototypeOf(C, h.prototype), R(d, C), C
                            }
                            b.prototype = ce.prototype, Object.defineProperty(HTMLElement.prototype, "constructor", {
                                writable: !0,
                                configurable: !0,
                                enumerable: !1,
                                value: b
                            }), window.HTMLElement = b
                        }(d),
                        function Ba(t) {
                            Document.prototype.createElement = function(d) {
                                return ua(t, this, d, null)
                            }, Document.prototype.importNode = function(d, y) {
                                return d = h.call(this, d, !!y), this.__CE_registry ? V(t, d) : Q(t, d), d
                            }, Document.prototype.createElementNS = function(d, h) {
                                return ua(t, this, h, d)
                            }, Z(t, Document.prototype, {
                                prepend: y,
                                append: _
                            })
                        }(d), Z(d, DocumentFragment.prototype, {
                                prepend: x,
                                append: C
                            }),
                            function Ga(t) {
                                function b(d, h) {
                                    Object.defineProperty(d, "textContent", {
                                        enumerable: h.enumerable,
                                        configurable: !0,
                                        get: h.get,
                                        set: function(d) {
                                            if (this.nodeType === Node.TEXT_NODE) h.set.call(this, d);
                                            else {
                                                var y = void 0;
                                                if (this.firstChild) {
                                                    var _ = this.childNodes,
                                                        x = _.length;
                                                    if (0 < x && J(this)) {
                                                        y = Array(x);
                                                        for (var C = 0; C < x; C++) y[C] = _[C]
                                                    }
                                                }
                                                if (h.set.call(this, d), y)
                                                    for (d = 0; d < y.length; d++) U(t, y[d])
                                            }
                                        }
                                    })
                                }
                                Node.prototype.insertBefore = function(d, h) {
                                    if (d instanceof DocumentFragment) {
                                        var y = K(d);
                                        if (d = k.call(this, d, h), J(this))
                                            for (h = 0; h < y.length; h++) S(t, y[h]);
                                        return d
                                    }
                                    return y = d instanceof Element && J(d), h = k.call(this, d, h), y && U(t, d), J(this) && S(t, d), h
                                }, Node.prototype.appendChild = function(d) {
                                    if (d instanceof DocumentFragment) {
                                        var h = K(d);
                                        if (d = O.call(this, d), J(this))
                                            for (var y = 0; y < h.length; y++) S(t, h[y]);
                                        return d
                                    }
                                    return h = d instanceof Element && J(d), y = O.call(this, d), h && U(t, d), J(this) && S(t, d), y
                                }, Node.prototype.cloneNode = function(d) {
                                    return d = E.call(this, !!d), this.ownerDocument.__CE_registry ? V(t, d) : Q(t, d), d
                                }, Node.prototype.removeChild = function(d) {
                                    var h = d instanceof Element && J(d),
                                        y = z.call(this, d);
                                    return h && U(t, d), y
                                }, Node.prototype.replaceChild = function(d, h) {
                                    if (d instanceof DocumentFragment) {
                                        var y = K(d);
                                        if (d = A.call(this, d, h), J(this))
                                            for (U(t, h), h = 0; h < y.length; h++) S(t, y[h]);
                                        return d
                                    }
                                    y = d instanceof Element && J(d);
                                    var _ = A.call(this, d, h),
                                        x = J(this);
                                    return x && U(t, h), y && U(t, d), x && S(t, d), _
                                }, B && B.get ? b(Node.prototype, B) : function sa(t, d) {
                                    t.f = !0, t.h.push(d)
                                }(t, (function(t) {
                                    b(t, {
                                        enumerable: !0,
                                        configurable: !0,
                                        get: function() {
                                            for (var t = [], d = this.firstChild; d; d = d.nextSibling) d.nodeType !== Node.COMMENT_NODE && t.push(d.textContent);
                                            return t.join("")
                                        },
                                        set: function(t) {
                                            for (; this.firstChild;) z.call(this, this.firstChild);
                                            null != t && "" !== t && O.call(this, document.createTextNode(t))
                                        }
                                    })
                                }))
                            }(d), Da(d), d = new Y(d), document.__CE_registry = d, Object.defineProperty(window, "customElements", {
                                configurable: !0,
                                enumerable: !0,
                                value: d
                            })
                    }
                    ye && !ye.forcePolyfill && "function" == typeof ye.define && "function" == typeof ye.get || Ha(), window.__CE_installPolyfill = Ha
                }).call(self)
            },
            3939: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    BundleBlobAttachmentStore: () => Wl
                });
                var y = {};
                h.r(y), h.d(y, {
                    AccessPolicy: () => ht,
                    AppendBlobAppendBlockExceptionHeaders: () => Qn,
                    AppendBlobAppendBlockFromUrlExceptionHeaders: () => Yn,
                    AppendBlobAppendBlockFromUrlHeaders: () => Jn,
                    AppendBlobAppendBlockHeaders: () => Xn,
                    AppendBlobCreateExceptionHeaders: () => Wn,
                    AppendBlobCreateHeaders: () => Gn,
                    AppendBlobSealExceptionHeaders: () => ei,
                    AppendBlobSealHeaders: () => Zn,
                    ArrowConfiguration: () => At,
                    ArrowField: () => Bt,
                    BlobAbortCopyFromURLExceptionHeaders: () => bn,
                    BlobAbortCopyFromURLHeaders: () => gn,
                    BlobAcquireLeaseExceptionHeaders: () => Zr,
                    BlobAcquireLeaseHeaders: () => Yr,
                    BlobBreakLeaseExceptionHeaders: () => cn,
                    BlobBreakLeaseHeaders: () => ln,
                    BlobChangeLeaseExceptionHeaders: () => sn,
                    BlobChangeLeaseHeaders: () => an,
                    BlobCopyFromURLExceptionHeaders: () => yn,
                    BlobCopyFromURLHeaders: () => hn,
                    BlobCreateSnapshotExceptionHeaders: () => dn,
                    BlobCreateSnapshotHeaders: () => un,
                    BlobDeleteExceptionHeaders: () => Mr,
                    BlobDeleteHeaders: () => Ir,
                    BlobDeleteImmutabilityPolicyExceptionHeaders: () => Gr,
                    BlobDeleteImmutabilityPolicyHeaders: () => Kr,
                    BlobDownloadExceptionHeaders: () => Lr,
                    BlobDownloadHeaders: () => zr,
                    BlobFlatListSegment: () => gt,
                    BlobGetAccountInfoExceptionHeaders: () => Nn,
                    BlobGetAccountInfoHeaders: () => xn,
                    BlobGetPropertiesExceptionHeaders: () => Br,
                    BlobGetPropertiesHeaders: () => Ar,
                    BlobGetTagsExceptionHeaders: () => Cn,
                    BlobGetTagsHeaders: () => wn,
                    BlobHierarchyListSegment: () => xt,
                    BlobItemInternal: () => bt,
                    BlobPrefix: () => Nt,
                    BlobPropertiesInternal: () => vt,
                    BlobQueryExceptionHeaders: () => Sn,
                    BlobQueryHeaders: () => Pn,
                    BlobReleaseLeaseExceptionHeaders: () => tn,
                    BlobReleaseLeaseHeaders: () => en,
                    BlobRenewLeaseExceptionHeaders: () => nn,
                    BlobRenewLeaseHeaders: () => rn,
                    BlobServiceProperties: () => Qe,
                    BlobServiceStatistics: () => nt,
                    BlobSetExpiryExceptionHeaders: () => Fr,
                    BlobSetExpiryHeaders: () => jr,
                    BlobSetHttpHeadersExceptionHeaders: () => Ur,
                    BlobSetHttpHeadersHeaders: () => Hr,
                    BlobSetImmutabilityPolicyExceptionHeaders: () => Vr,
                    BlobSetImmutabilityPolicyHeaders: () => $r,
                    BlobSetLegalHoldExceptionHeaders: () => Xr,
                    BlobSetLegalHoldHeaders: () => Wr,
                    BlobSetMetadataExceptionHeaders: () => Jr,
                    BlobSetMetadataHeaders: () => Qr,
                    BlobSetTagsExceptionHeaders: () => On,
                    BlobSetTagsHeaders: () => En,
                    BlobSetTierExceptionHeaders: () => _n,
                    BlobSetTierHeaders: () => vn,
                    BlobStartCopyFromURLExceptionHeaders: () => mn,
                    BlobStartCopyFromURLHeaders: () => pn,
                    BlobTag: () => mt,
                    BlobTags: () => pt,
                    BlobUndeleteExceptionHeaders: () => Dr,
                    BlobUndeleteHeaders: () => qr,
                    Block: () => wt,
                    BlockBlobCommitBlockListExceptionHeaders: () => ui,
                    BlockBlobCommitBlockListHeaders: () => ci,
                    BlockBlobGetBlockListExceptionHeaders: () => pi,
                    BlockBlobGetBlockListHeaders: () => di,
                    BlockBlobPutBlobFromUrlExceptionHeaders: () => ii,
                    BlockBlobPutBlobFromUrlHeaders: () => ni,
                    BlockBlobStageBlockExceptionHeaders: () => ai,
                    BlockBlobStageBlockFromURLExceptionHeaders: () => li,
                    BlockBlobStageBlockFromURLHeaders: () => si,
                    BlockBlobStageBlockHeaders: () => oi,
                    BlockBlobUploadExceptionHeaders: () => ri,
                    BlockBlobUploadHeaders: () => ti,
                    BlockList: () => St,
                    BlockLookupList: () => Pt,
                    ClearRange: () => Ot,
                    ContainerAcquireLeaseExceptionHeaders: () => gr,
                    ContainerAcquireLeaseHeaders: () => yr,
                    ContainerBreakLeaseExceptionHeaders: () => Pr,
                    ContainerBreakLeaseHeaders: () => Nr,
                    ContainerChangeLeaseExceptionHeaders: () => wr,
                    ContainerChangeLeaseHeaders: () => Sr,
                    ContainerCreateExceptionHeaders: () => Zt,
                    ContainerCreateHeaders: () => Yt,
                    ContainerDeleteExceptionHeaders: () => nr,
                    ContainerDeleteHeaders: () => rr,
                    ContainerGetAccessPolicyExceptionHeaders: () => sr,
                    ContainerGetAccessPolicyHeaders: () => ar,
                    ContainerGetAccountInfoExceptionHeaders: () => kr,
                    ContainerGetAccountInfoHeaders: () => Rr,
                    ContainerGetPropertiesExceptionHeaders: () => tr,
                    ContainerGetPropertiesHeaders: () => er,
                    ContainerItem: () => at,
                    ContainerListBlobFlatSegmentExceptionHeaders: () => Er,
                    ContainerListBlobFlatSegmentHeaders: () => Cr,
                    ContainerListBlobHierarchySegmentExceptionHeaders: () => Tr,
                    ContainerListBlobHierarchySegmentHeaders: () => Or,
                    ContainerProperties: () => st,
                    ContainerReleaseLeaseExceptionHeaders: () => vr,
                    ContainerReleaseLeaseHeaders: () => br,
                    ContainerRenameExceptionHeaders: () => mr,
                    ContainerRenameHeaders: () => pr,
                    ContainerRenewLeaseExceptionHeaders: () => xr,
                    ContainerRenewLeaseHeaders: () => _r,
                    ContainerRestoreExceptionHeaders: () => dr,
                    ContainerRestoreHeaders: () => ur,
                    ContainerSetAccessPolicyExceptionHeaders: () => cr,
                    ContainerSetAccessPolicyHeaders: () => lr,
                    ContainerSetMetadataExceptionHeaders: () => or,
                    ContainerSetMetadataHeaders: () => ir,
                    ContainerSubmitBatchExceptionHeaders: () => hr,
                    ContainerSubmitBatchHeaders: () => fr,
                    CorsRule: () => et,
                    DelimitedTextConfiguration: () => zt,
                    FilterBlobItem: () => dt,
                    FilterBlobSegment: () => ut,
                    GeoReplication: () => it,
                    JsonTextConfiguration: () => Lt,
                    KeyInfo: () => lt,
                    ListBlobsFlatSegmentResponse: () => yt,
                    ListBlobsHierarchySegmentResponse: () => _t,
                    ListContainersSegmentResponse: () => ot,
                    Logging: () => Je,
                    Metrics: () => Ze,
                    PageBlobClearPagesExceptionHeaders: () => An,
                    PageBlobClearPagesHeaders: () => Ln,
                    PageBlobCopyIncrementalExceptionHeaders: () => Kn,
                    PageBlobCopyIncrementalHeaders: () => Vn,
                    PageBlobCreateExceptionHeaders: () => Rn,
                    PageBlobCreateHeaders: () => Tn,
                    PageBlobGetPageRangesDiffExceptionHeaders: () => jn,
                    PageBlobGetPageRangesDiffHeaders: () => Dn,
                    PageBlobGetPageRangesExceptionHeaders: () => qn,
                    PageBlobGetPageRangesHeaders: () => Mn,
                    PageBlobResizeExceptionHeaders: () => Hn,
                    PageBlobResizeHeaders: () => Fn,
                    PageBlobUpdateSequenceNumberExceptionHeaders: () => $n,
                    PageBlobUpdateSequenceNumberHeaders: () => Un,
                    PageBlobUploadPagesExceptionHeaders: () => zn,
                    PageBlobUploadPagesFromURLExceptionHeaders: () => In,
                    PageBlobUploadPagesFromURLHeaders: () => Bn,
                    PageBlobUploadPagesHeaders: () => kn,
                    PageList: () => Ct,
                    PageRange: () => Et,
                    QueryFormat: () => kt,
                    QueryRequest: () => Tt,
                    QuerySerialization: () => Rt,
                    RetentionPolicy: () => Ye,
                    ServiceFilterBlobsExceptionHeaders: () => Jt,
                    ServiceFilterBlobsHeaders: () => Qt,
                    ServiceGetAccountInfoExceptionHeaders: () => Gt,
                    ServiceGetAccountInfoHeaders: () => Kt,
                    ServiceGetPropertiesExceptionHeaders: () => Dt,
                    ServiceGetPropertiesHeaders: () => qt,
                    ServiceGetStatisticsExceptionHeaders: () => Ft,
                    ServiceGetStatisticsHeaders: () => jt,
                    ServiceGetUserDelegationKeyExceptionHeaders: () => Vt,
                    ServiceGetUserDelegationKeyHeaders: () => $t,
                    ServiceListContainersSegmentExceptionHeaders: () => Ut,
                    ServiceListContainersSegmentHeaders: () => Ht,
                    ServiceSetPropertiesExceptionHeaders: () => Mt,
                    ServiceSetPropertiesHeaders: () => It,
                    ServiceSubmitBatchExceptionHeaders: () => Xt,
                    ServiceSubmitBatchHeaders: () => Wt,
                    SignedIdentifier: () => ft,
                    StaticWebsite: () => tt,
                    StorageError: () => rt,
                    UserDelegationKey: () => ct
                });
                var _ = h(7757),
                    x = h.n(_);
                const C = "$",
                    E = "_";
                var O, k = new Uint8Array(16);

                function rng() {
                    if (!O && !(O = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                    return O(k)
                }
                const z = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
                const A = function validate(t) {
                    return "string" == typeof t && z.test(t)
                };
                for (var B = [], I = 0; I < 256; ++I) B.push((I + 256).toString(16).substr(1));
                const q = function stringify(t) {
                    var d = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        h = (B[t[d + 0]] + B[t[d + 1]] + B[t[d + 2]] + B[t[d + 3]] + "-" + B[t[d + 4]] + B[t[d + 5]] + "-" + B[t[d + 6]] + B[t[d + 7]] + "-" + B[t[d + 8]] + B[t[d + 9]] + "-" + B[t[d + 10]] + B[t[d + 11]] + B[t[d + 12]] + B[t[d + 13]] + B[t[d + 14]] + B[t[d + 15]]).toLowerCase();
                    if (!A(h)) throw TypeError("Stringified UUID is invalid");
                    return h
                };
                const D = function v4(t, d, h) {
                        var y = (t = t || {}).random || (t.rng || rng)();
                        if (y[6] = 15 & y[6] | 64, y[8] = 63 & y[8] | 128, d) {
                            h = h || 0;
                            for (var _ = 0; _ < 16; ++_) d[h + _] = y[_];
                            return d
                        }
                        return q(y)
                    },
                    j = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i,
                    H = "undefined" != typeof process && !!process.version && !!process.versions && !!process.versions.node;

                function generateUuid() {
                    return D()
                }
                const $ = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

                function replaceAll(t, d, h) {
                    return t && d ? t.split(d).join(h || "") : t
                }

                function isTokenCredential(t) {
                    const d = t;
                    return d && "function" == typeof d.getToken && (void 0 === d.signRequest || d.getToken.length > 0)
                }
                const G = new Error("ProxyPolicy is not supported in browser environment");

                function proxyPolicy_browser_proxyPolicy(t) {
                    return {
                        create: (t, d) => {
                            throw G
                        }
                    }
                }
                class URLQuery {
                    constructor() {
                        this._rawQuery = {}
                    }
                    any() {
                        return Object.keys(this._rawQuery).length > 0
                    }
                    keys() {
                        return Object.keys(this._rawQuery)
                    }
                    set(t, d) {
                        const h = d;
                        if (t)
                            if (null != h) {
                                const d = Array.isArray(h) ? h : h.toString();
                                this._rawQuery[t] = d
                            } else delete this._rawQuery[t]
                    }
                    get(t) {
                        return t ? this._rawQuery[t] : void 0
                    }
                    toString() {
                        let t = "";
                        for (const d in this._rawQuery) {
                            t && (t += "&");
                            const h = this._rawQuery[d];
                            if (Array.isArray(h)) {
                                const y = [];
                                for (const t of h) y.push(`${d}=${t}`);
                                t += y.join("&")
                            } else t += `${d}=${h}`
                        }
                        return t
                    }
                    static parse(t) {
                        const d = new URLQuery;
                        if (t) {
                            t.startsWith("?") && (t = t.substring(1));
                            let h = "ParameterName",
                                y = "",
                                _ = "";
                            for (let x = 0; x < t.length; ++x) {
                                const C = t[x];
                                switch (h) {
                                    case "ParameterName":
                                        switch (C) {
                                            case "=":
                                                h = "ParameterValue";
                                                break;
                                            case "&":
                                                y = "", _ = "";
                                                break;
                                            default:
                                                y += C
                                        }
                                        break;
                                    case "ParameterValue":
                                        if ("&" === C) d.set(y, _), y = "", _ = "", h = "ParameterName";
                                        else _ += C;
                                        break;
                                    default:
                                        throw new Error("Unrecognized URLQuery parse state: " + h)
                                }
                            }
                            "ParameterValue" === h && d.set(y, _)
                        }
                        return d
                    }
                }
                class url_URLBuilder {
                    setScheme(t) {
                        t ? this.set(t, "SCHEME") : this._scheme = void 0
                    }
                    getScheme() {
                        return this._scheme
                    }
                    setHost(t) {
                        t ? this.set(t, "SCHEME_OR_HOST") : this._host = void 0
                    }
                    getHost() {
                        return this._host
                    }
                    setPort(t) {
                        null == t || "" === t ? this._port = void 0 : this.set(t.toString(), "PORT")
                    }
                    getPort() {
                        return this._port
                    }
                    setPath(t) {
                        if (t) {
                            const d = t.indexOf("://");
                            if (-1 !== d) {
                                const h = t.lastIndexOf("/", d);
                                this.set(-1 === h ? t : t.substr(h + 1), "SCHEME")
                            } else this.set(t, "PATH")
                        } else this._path = void 0
                    }
                    appendPath(t) {
                        if (t) {
                            let d = this.getPath();
                            d && (d.endsWith("/") || (d += "/"), t.startsWith("/") && (t = t.substring(1)), t = d + t), this.set(t, "PATH")
                        }
                    }
                    getPath() {
                        return this._path
                    }
                    setQuery(t) {
                        this._query = t ? URLQuery.parse(t) : void 0
                    }
                    setQueryParameter(t, d) {
                        t && (this._query || (this._query = new URLQuery), this._query.set(t, d))
                    }
                    getQueryParameterValue(t) {
                        return this._query ? this._query.get(t) : void 0
                    }
                    getQuery() {
                        return this._query ? this._query.toString() : void 0
                    }
                    set(t, d) {
                        const h = new URLTokenizer(t, d);
                        for (; h.next();) {
                            const t = h.current();
                            let d;
                            if (t) switch (t.type) {
                                case "SCHEME":
                                    this._scheme = t.text || void 0;
                                    break;
                                case "HOST":
                                    this._host = t.text || void 0;
                                    break;
                                case "PORT":
                                    this._port = t.text || void 0;
                                    break;
                                case "PATH":
                                    d = t.text || void 0, this._path && "/" !== this._path && "/" === d || (this._path = d);
                                    break;
                                case "QUERY":
                                    this._query = URLQuery.parse(t.text);
                                    break;
                                default:
                                    throw new Error(`Unrecognized URLTokenType: ${t.type}`)
                            }
                        }
                    }
                    toString() {
                        let t = "";
                        return this._scheme && (t += `${this._scheme}://`), this._host && (t += this._host), this._port && (t += `:${this._port}`), this._path && (this._path.startsWith("/") || (t += "/"), t += this._path), this._query && this._query.any() && (t += `?${this._query.toString()}`), t
                    }
                    replaceAll(t, d) {
                        t && (this.setScheme(replaceAll(this.getScheme(), t, d)), this.setHost(replaceAll(this.getHost(), t, d)), this.setPort(replaceAll(this.getPort(), t, d)), this.setPath(replaceAll(this.getPath(), t, d)), this.setQuery(replaceAll(this.getQuery(), t, d)))
                    }
                    static parse(t) {
                        const d = new url_URLBuilder;
                        return d.set(t, "SCHEME_OR_HOST"), d
                    }
                }
                class URLToken {
                    constructor(t, d) {
                        this.text = t, this.type = d
                    }
                    static scheme(t) {
                        return new URLToken(t, "SCHEME")
                    }
                    static host(t) {
                        return new URLToken(t, "HOST")
                    }
                    static port(t) {
                        return new URLToken(t, "PORT")
                    }
                    static path(t) {
                        return new URLToken(t, "PATH")
                    }
                    static query(t) {
                        return new URLToken(t, "QUERY")
                    }
                }
                class URLTokenizer {
                    constructor(t, d) {
                        this._text = t, this._textLength = t ? t.length : 0, this._currentState = null != d ? d : "SCHEME_OR_HOST", this._currentIndex = 0
                    }
                    current() {
                        return this._currentToken
                    }
                    next() {
                        if (hasCurrentCharacter(this)) switch (this._currentState) {
                            case "SCHEME":
                                ! function nextScheme(t) {
                                    const d = function readWhileLetterOrDigit(t) {
                                        return readWhile(t, (t => function isAlphaNumericCharacter(t) {
                                            const d = t.charCodeAt(0);
                                            return 48 <= d && d <= 57 || 65 <= d && d <= 90 || 97 <= d && d <= 122
                                        }(t)))
                                    }(t);
                                    t._currentToken = URLToken.scheme(d), hasCurrentCharacter(t) ? t._currentState = "HOST" : t._currentState = "DONE"
                                }(this);
                                break;
                            case "SCHEME_OR_HOST":
                                ! function nextSchemeOrHost(t) {
                                    const d = readUntilCharacter(t, ":", "/", "?");
                                    hasCurrentCharacter(t) ? ":" === getCurrentCharacter(t) ? "://" === peekCharacters(t, 3) ? (t._currentToken = URLToken.scheme(d), t._currentState = "HOST") : (t._currentToken = URLToken.host(d), t._currentState = "PORT") : (t._currentToken = URLToken.host(d), "/" === getCurrentCharacter(t) ? t._currentState = "PATH" : t._currentState = "QUERY") : (t._currentToken = URLToken.host(d), t._currentState = "DONE")
                                }(this);
                                break;
                            case "HOST":
                                ! function nextHost(t) {
                                    "://" === peekCharacters(t, 3) && nextCharacter(t, 3);
                                    const d = readUntilCharacter(t, ":", "/", "?");
                                    t._currentToken = URLToken.host(d), hasCurrentCharacter(t) ? ":" === getCurrentCharacter(t) ? t._currentState = "PORT" : "/" === getCurrentCharacter(t) ? t._currentState = "PATH" : t._currentState = "QUERY" : t._currentState = "DONE"
                                }(this);
                                break;
                            case "PORT":
                                ! function nextPort(t) {
                                    ":" === getCurrentCharacter(t) && nextCharacter(t);
                                    const d = readUntilCharacter(t, "/", "?");
                                    t._currentToken = URLToken.port(d), hasCurrentCharacter(t) ? "/" === getCurrentCharacter(t) ? t._currentState = "PATH" : t._currentState = "QUERY" : t._currentState = "DONE"
                                }(this);
                                break;
                            case "PATH":
                                ! function nextPath(t) {
                                    const d = readUntilCharacter(t, "?");
                                    t._currentToken = URLToken.path(d), hasCurrentCharacter(t) ? t._currentState = "QUERY" : t._currentState = "DONE"
                                }(this);
                                break;
                            case "QUERY":
                                ! function nextQuery(t) {
                                    "?" === getCurrentCharacter(t) && nextCharacter(t);
                                    const d = function readRemaining(t) {
                                        let d = "";
                                        t._currentIndex < t._textLength && (d = t._text.substring(t._currentIndex), t._currentIndex = t._textLength);
                                        return d
                                    }(t);
                                    t._currentToken = URLToken.query(d), t._currentState = "DONE"
                                }(this);
                                break;
                            default:
                                throw new Error(`Unrecognized URLTokenizerState: ${this._currentState}`)
                        } else this._currentToken = void 0;
                        return !!this._currentToken
                    }
                }

                function hasCurrentCharacter(t) {
                    return t._currentIndex < t._textLength
                }

                function getCurrentCharacter(t) {
                    return t._text[t._currentIndex]
                }

                function nextCharacter(t, d) {
                    hasCurrentCharacter(t) && (d || (d = 1), t._currentIndex += d)
                }

                function peekCharacters(t, d) {
                    let h = t._currentIndex + d;
                    return t._textLength < h && (h = t._textLength), t._text.substring(t._currentIndex, h)
                }

                function readWhile(t, d) {
                    let h = "";
                    for (; hasCurrentCharacter(t);) {
                        const y = getCurrentCharacter(t);
                        if (!d(y)) break;
                        h += y, nextCharacter(t)
                    }
                    return h
                }

                function readUntilCharacter(t, ...d) {
                    return readWhile(t, (t => -1 === d.indexOf(t)))
                }
                var ee = "object" == typeof globalThis ? globalThis : "object" == typeof self ? self : "object" == typeof window ? window : "object" == typeof h.g ? h.g : {},
                    te = "1.0.4",
                    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
                var ne = function _makeCompatibilityCheck(t) {
                        var d = new Set([t]),
                            h = new Set,
                            y = t.match(re);
                        if (!y) return function() {
                            return !1
                        };
                        var _ = +y[1],
                            x = +y[2],
                            C = +y[3];
                        if (null != y[4]) return function isExactmatch(d) {
                            return d === t
                        };

                        function _reject(t) {
                            return h.add(t), !1
                        }

                        function _accept(t) {
                            return d.add(t), !0
                        }
                        return function isCompatible(t) {
                            if (d.has(t)) return !0;
                            if (h.has(t)) return !1;
                            var y = t.match(re);
                            if (!y) return _reject(t);
                            var E = +y[1],
                                O = +y[2],
                                k = +y[3];
                            return null != y[4] || _ !== E ? _reject(t) : 0 === _ ? x === O && C <= k ? _accept(t) : _reject(t) : x <= O ? _accept(t) : _reject(t)
                        }
                    }(te),
                    ie = te.split(".")[0],
                    oe = Symbol.for("opentelemetry.js.api." + ie),
                    ae = ee;

                function registerGlobal(t, d, h, y) {
                    var _;
                    void 0 === y && (y = !1);
                    var x = ae[oe] = null !== (_ = ae[oe]) && void 0 !== _ ? _ : {
                        version: te
                    };
                    if (!y && x[t]) {
                        var C = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + t);
                        return h.error(C.stack || C.message), !1
                    }
                    if (x.version !== te) {
                        C = new Error("@opentelemetry/api: All API registration versions must match");
                        return h.error(C.stack || C.message), !1
                    }
                    return x[t] = d, h.debug("@opentelemetry/api: Registered a global for " + t + " v" + "1.0.4."), !0
                }

                function getGlobal(t) {
                    var d, h, y = null === (d = ae[oe]) || void 0 === d ? void 0 : d.version;
                    if (y && ne(y)) return null === (h = ae[oe]) || void 0 === h ? void 0 : h[t]
                }

                function unregisterGlobal(t, d) {
                    d.debug("@opentelemetry/api: Unregistering a global for " + t + " v" + "1.0.4.");
                    var h = ae[oe];
                    h && delete h[t]
                }
                var se, le = function() {
                    function DiagComponentLogger(t) {
                        this._namespace = t.namespace || "DiagComponentLogger"
                    }
                    return DiagComponentLogger.prototype.debug = function() {
                        for (var t = [], d = 0; d < arguments.length; d++) t[d] = arguments[d];
                        return logProxy("debug", this._namespace, t)
                    }, DiagComponentLogger.prototype.error = function() {
                        for (var t = [], d = 0; d < arguments.length; d++) t[d] = arguments[d];
                        return logProxy("error", this._namespace, t)
                    }, DiagComponentLogger.prototype.info = function() {
                        for (var t = [], d = 0; d < arguments.length; d++) t[d] = arguments[d];
                        return logProxy("info", this._namespace, t)
                    }, DiagComponentLogger.prototype.warn = function() {
                        for (var t = [], d = 0; d < arguments.length; d++) t[d] = arguments[d];
                        return logProxy("warn", this._namespace, t)
                    }, DiagComponentLogger.prototype.verbose = function() {
                        for (var t = [], d = 0; d < arguments.length; d++) t[d] = arguments[d];
                        return logProxy("verbose", this._namespace, t)
                    }, DiagComponentLogger
                }();

                function logProxy(t, d, h) {
                    var y = getGlobal("diag");
                    if (y) return h.unshift(d), y[t].apply(y, h)
                }! function(t) {
                    t[t.NONE = 0] = "NONE", t[t.ERROR = 30] = "ERROR", t[t.WARN = 50] = "WARN", t[t.INFO = 60] = "INFO", t[t.DEBUG = 70] = "DEBUG", t[t.VERBOSE = 80] = "VERBOSE", t[t.ALL = 9999] = "ALL"
                }(se || (se = {}));
                var ce = function() {
                        function DiagAPI() {
                            function _logProxy(t) {
                                return function() {
                                    for (var d = [], h = 0; h < arguments.length; h++) d[h] = arguments[h];
                                    var y = getGlobal("diag");
                                    if (y) return y[t].apply(y, d)
                                }
                            }
                            var t = this;
                            t.setLogger = function(d, h) {
                                var y, _;
                                if (void 0 === h && (h = se.INFO), d === t) {
                                    var x = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                                    return t.error(null !== (y = x.stack) && void 0 !== y ? y : x.message), !1
                                }
                                var C = getGlobal("diag"),
                                    E = function createLogLevelDiagLogger(t, d) {
                                        function _filterFunc(h, y) {
                                            var _ = d[h];
                                            return "function" == typeof _ && t >= y ? _.bind(d) : function() {}
                                        }
                                        return t < se.NONE ? t = se.NONE : t > se.ALL && (t = se.ALL), d = d || {}, {
                                            error: _filterFunc("error", se.ERROR),
                                            warn: _filterFunc("warn", se.WARN),
                                            info: _filterFunc("info", se.INFO),
                                            debug: _filterFunc("debug", se.DEBUG),
                                            verbose: _filterFunc("verbose", se.VERBOSE)
                                        }
                                    }(h, d);
                                if (C) {
                                    var O = null !== (_ = (new Error).stack) && void 0 !== _ ? _ : "<failed to generate stacktrace>";
                                    C.warn("Current logger will be overwritten from " + O), E.warn("Current logger will overwrite one already registered from " + O)
                                }
                                return registerGlobal("diag", E, t, !0)
                            }, t.disable = function() {
                                unregisterGlobal("diag", t)
                            }, t.createComponentLogger = function(t) {
                                return new le(t)
                            }, t.verbose = _logProxy("verbose"), t.debug = _logProxy("debug"), t.info = _logProxy("info"), t.warn = _logProxy("warn"), t.error = _logProxy("error")
                        }
                        return DiagAPI.instance = function() {
                            return this._instance || (this._instance = new DiagAPI), this._instance
                        }, DiagAPI
                    }(),
                    ue = function() {
                        function BaggageImpl(t) {
                            this._entries = t ? new Map(t) : new Map
                        }
                        return BaggageImpl.prototype.getEntry = function(t) {
                            var d = this._entries.get(t);
                            if (d) return Object.assign({}, d)
                        }, BaggageImpl.prototype.getAllEntries = function() {
                            return Array.from(this._entries.entries()).map((function(t) {
                                return [t[0], t[1]]
                            }))
                        }, BaggageImpl.prototype.setEntry = function(t, d) {
                            var h = new BaggageImpl(this._entries);
                            return h._entries.set(t, d), h
                        }, BaggageImpl.prototype.removeEntry = function(t) {
                            var d = new BaggageImpl(this._entries);
                            return d._entries.delete(t), d
                        }, BaggageImpl.prototype.removeEntries = function() {
                            for (var t = [], d = 0; d < arguments.length; d++) t[d] = arguments[d];
                            for (var h = new BaggageImpl(this._entries), y = 0, _ = t; y < _.length; y++) {
                                var x = _[y];
                                h._entries.delete(x)
                            }
                            return h
                        }, BaggageImpl.prototype.clear = function() {
                            return new BaggageImpl
                        }, BaggageImpl
                    }();
                Symbol("BaggageEntryMetadata"), ce.instance();

                function createBaggage(t) {
                    return void 0 === t && (t = {}), new ue(new Map(Object.entries(t)))
                }
                var de = {
                        get: function(t, d) {
                            if (null != t) return t[d]
                        },
                        keys: function(t) {
                            return null == t ? [] : Object.keys(t)
                        }
                    },
                    pe = {
                        set: function(t, d, h) {
                            null != t && (t[d] = h)
                        }
                    };

                function createContextKey(t) {
                    return Symbol.for(t)
                }
                var me, fe = function BaseContext(t) {
                        var d = this;
                        d._currentContext = t ? new Map(t) : new Map, d.getValue = function(t) {
                            return d._currentContext.get(t)
                        }, d.setValue = function(t, h) {
                            var y = new BaseContext(d._currentContext);
                            return y._currentContext.set(t, h), y
                        }, d.deleteValue = function(t) {
                            var h = new BaseContext(d._currentContext);
                            return h._currentContext.delete(t), h
                        }
                    },
                    he = new fe,
                    __spreadArray = function(t, d) {
                        for (var h = 0, y = d.length, _ = t.length; h < y; h++, _++) t[_] = d[h];
                        return t
                    },
                    ye = function() {
                        function NoopContextManager() {}
                        return NoopContextManager.prototype.active = function() {
                            return he
                        }, NoopContextManager.prototype.with = function(t, d, h) {
                            for (var y = [], _ = 3; _ < arguments.length; _++) y[_ - 3] = arguments[_];
                            return d.call.apply(d, __spreadArray([h], y))
                        }, NoopContextManager.prototype.bind = function(t, d) {
                            return d
                        }, NoopContextManager.prototype.enable = function() {
                            return this
                        }, NoopContextManager.prototype.disable = function() {
                            return this
                        }, NoopContextManager
                    }(),
                    context_spreadArray = function(t, d) {
                        for (var h = 0, y = d.length, _ = t.length; h < y; h++, _++) t[_] = d[h];
                        return t
                    },
                    ge = "context",
                    be = new ye,
                    ve = function() {
                        function ContextAPI() {}
                        return ContextAPI.getInstance = function() {
                            return this._instance || (this._instance = new ContextAPI), this._instance
                        }, ContextAPI.prototype.setGlobalContextManager = function(t) {
                            return registerGlobal(ge, t, ce.instance())
                        }, ContextAPI.prototype.active = function() {
                            return this._getContextManager().active()
                        }, ContextAPI.prototype.with = function(t, d, h) {
                            for (var y, _ = [], x = 3; x < arguments.length; x++) _[x - 3] = arguments[x];
                            return (y = this._getContextManager()).with.apply(y, context_spreadArray([t, d, h], _))
                        }, ContextAPI.prototype.bind = function(t, d) {
                            return this._getContextManager().bind(t, d)
                        }, ContextAPI.prototype._getContextManager = function() {
                            return getGlobal(ge) || be
                        }, ContextAPI.prototype.disable = function() {
                            this._getContextManager().disable(), unregisterGlobal(ge, ce.instance())
                        }, ContextAPI
                    }();
                ! function(t) {
                    t[t.NONE = 0] = "NONE", t[t.SAMPLED = 1] = "SAMPLED"
                }(me || (me = {}));
                var _e = "0000000000000000",
                    xe = "00000000000000000000000000000000",
                    Ne = {
                        traceId: xe,
                        spanId: _e,
                        traceFlags: me.NONE
                    },
                    Pe = function() {
                        function NonRecordingSpan(t) {
                            void 0 === t && (t = Ne), this._spanContext = t
                        }
                        return NonRecordingSpan.prototype.spanContext = function() {
                            return this._spanContext
                        }, NonRecordingSpan.prototype.setAttribute = function(t, d) {
                            return this
                        }, NonRecordingSpan.prototype.setAttributes = function(t) {
                            return this
                        }, NonRecordingSpan.prototype.addEvent = function(t, d) {
                            return this
                        }, NonRecordingSpan.prototype.setStatus = function(t) {
                            return this
                        }, NonRecordingSpan.prototype.updateName = function(t) {
                            return this
                        }, NonRecordingSpan.prototype.end = function(t) {}, NonRecordingSpan.prototype.isRecording = function() {
                            return !1
                        }, NonRecordingSpan.prototype.recordException = function(t, d) {}, NonRecordingSpan
                    }(),
                    Se = createContextKey("OpenTelemetry Context Key SPAN");

                function getSpan(t) {
                    return t.getValue(Se) || void 0
                }

                function setSpan(t, d) {
                    return t.setValue(Se, d)
                }

                function deleteSpan(t) {
                    return t.deleteValue(Se)
                }

                function setSpanContext(t, d) {
                    return setSpan(t, new Pe(d))
                }

                function getSpanContext(t) {
                    var d;
                    return null === (d = getSpan(t)) || void 0 === d ? void 0 : d.spanContext()
                }
                var we = /^([0-9a-f]{32})$/i,
                    Ce = /^[0-9a-f]{16}$/i;

                function isSpanContextValid(t) {
                    return function isValidTraceId(t) {
                        return we.test(t) && t !== xe
                    }(t.traceId) && function isValidSpanId(t) {
                        return Ce.test(t) && t !== _e
                    }(t.spanId)
                }

                function wrapSpanContext(t) {
                    return new Pe(t)
                }
                var Ee = ve.getInstance(),
                    Oe = function() {
                        function NoopTracer() {}
                        return NoopTracer.prototype.startSpan = function(t, d, h) {
                            if (Boolean(null == d ? void 0 : d.root)) return new Pe;
                            var y = h && getSpanContext(h);
                            return function isSpanContext(t) {
                                return "object" == typeof t && "string" == typeof t.spanId && "string" == typeof t.traceId && "number" == typeof t.traceFlags
                            }(y) && isSpanContextValid(y) ? new Pe(y) : new Pe
                        }, NoopTracer.prototype.startActiveSpan = function(t, d, h, y) {
                            var _, x, C;
                            if (!(arguments.length < 2)) {
                                2 === arguments.length ? C = d : 3 === arguments.length ? (_ = d, C = h) : (_ = d, x = h, C = y);
                                var E = null != x ? x : Ee.active(),
                                    O = this.startSpan(t, _, E),
                                    k = setSpan(E, O);
                                return Ee.with(k, C, void 0, O)
                            }
                        }, NoopTracer
                    }();
                var Te, Re, ke, ze = new Oe,
                    Le = function() {
                        function ProxyTracer(t, d, h) {
                            this._provider = t, this.name = d, this.version = h
                        }
                        return ProxyTracer.prototype.startSpan = function(t, d, h) {
                            return this._getTracer().startSpan(t, d, h)
                        }, ProxyTracer.prototype.startActiveSpan = function(t, d, h, y) {
                            var _ = this._getTracer();
                            return Reflect.apply(_.startActiveSpan, _, arguments)
                        }, ProxyTracer.prototype._getTracer = function() {
                            if (this._delegate) return this._delegate;
                            var t = this._provider.getDelegateTracer(this.name, this.version);
                            return t ? (this._delegate = t, this._delegate) : ze
                        }, ProxyTracer
                    }(),
                    Ae = new(function() {
                        function NoopTracerProvider() {}
                        return NoopTracerProvider.prototype.getTracer = function(t, d) {
                            return new Oe
                        }, NoopTracerProvider
                    }()),
                    Be = function() {
                        function ProxyTracerProvider() {}
                        return ProxyTracerProvider.prototype.getTracer = function(t, d) {
                            var h;
                            return null !== (h = this.getDelegateTracer(t, d)) && void 0 !== h ? h : new Le(this, t, d)
                        }, ProxyTracerProvider.prototype.getDelegate = function() {
                            var t;
                            return null !== (t = this._delegate) && void 0 !== t ? t : Ae
                        }, ProxyTracerProvider.prototype.setDelegate = function(t) {
                            this._delegate = t
                        }, ProxyTracerProvider.prototype.getDelegateTracer = function(t, d) {
                            var h;
                            return null === (h = this._delegate) || void 0 === h ? void 0 : h.getTracer(t, d)
                        }, ProxyTracerProvider
                    }();
                ! function(t) {
                    t[t.NOT_RECORD = 0] = "NOT_RECORD", t[t.RECORD = 1] = "RECORD", t[t.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED"
                }(Te || (Te = {})),
                function(t) {
                    t[t.INTERNAL = 0] = "INTERNAL", t[t.SERVER = 1] = "SERVER", t[t.CLIENT = 2] = "CLIENT", t[t.PRODUCER = 3] = "PRODUCER", t[t.CONSUMER = 4] = "CONSUMER"
                }(Re || (Re = {})),
                function(t) {
                    t[t.UNSET = 0] = "UNSET", t[t.OK = 1] = "OK", t[t.ERROR = 2] = "ERROR"
                }(ke || (ke = {}));
                var Ie = "trace",
                    Me = function() {
                        function TraceAPI() {
                            this._proxyTracerProvider = new Be, this.wrapSpanContext = wrapSpanContext, this.isSpanContextValid = isSpanContextValid, this.deleteSpan = deleteSpan, this.getSpan = getSpan, this.getSpanContext = getSpanContext, this.setSpan = setSpan, this.setSpanContext = setSpanContext
                        }
                        return TraceAPI.getInstance = function() {
                            return this._instance || (this._instance = new TraceAPI), this._instance
                        }, TraceAPI.prototype.setGlobalTracerProvider = function(t) {
                            var d = registerGlobal(Ie, this._proxyTracerProvider, ce.instance());
                            return d && this._proxyTracerProvider.setDelegate(t), d
                        }, TraceAPI.prototype.getTracerProvider = function() {
                            return getGlobal(Ie) || this._proxyTracerProvider
                        }, TraceAPI.prototype.getTracer = function(t, d) {
                            return this.getTracerProvider().getTracer(t, d)
                        }, TraceAPI.prototype.disable = function() {
                            unregisterGlobal(Ie, ce.instance()), this._proxyTracerProvider = new Be
                        }, TraceAPI
                    }(),
                    qe = function() {
                        function NoopTextMapPropagator() {}
                        return NoopTextMapPropagator.prototype.inject = function(t, d) {}, NoopTextMapPropagator.prototype.extract = function(t, d) {
                            return t
                        }, NoopTextMapPropagator.prototype.fields = function() {
                            return []
                        }, NoopTextMapPropagator
                    }(),
                    De = createContextKey("OpenTelemetry Baggage Key");

                function getBaggage(t) {
                    return t.getValue(De) || void 0
                }

                function setBaggage(t, d) {
                    return t.setValue(De, d)
                }

                function deleteBaggage(t) {
                    return t.deleteValue(De)
                }
                var je = "propagation",
                    Fe = new qe,
                    He = function() {
                        function PropagationAPI() {
                            this.createBaggage = createBaggage, this.getBaggage = getBaggage, this.setBaggage = setBaggage, this.deleteBaggage = deleteBaggage
                        }
                        return PropagationAPI.getInstance = function() {
                            return this._instance || (this._instance = new PropagationAPI), this._instance
                        }, PropagationAPI.prototype.setGlobalPropagator = function(t) {
                            return registerGlobal(je, t, ce.instance())
                        }, PropagationAPI.prototype.inject = function(t, d, h) {
                            return void 0 === h && (h = pe), this._getGlobalPropagator().inject(t, d, h)
                        }, PropagationAPI.prototype.extract = function(t, d, h) {
                            return void 0 === h && (h = de), this._getGlobalPropagator().extract(t, d, h)
                        }, PropagationAPI.prototype.fields = function() {
                            return this._getGlobalPropagator().fields()
                        }, PropagationAPI.prototype.disable = function() {
                            unregisterGlobal(je, ce.instance())
                        }, PropagationAPI.prototype._getGlobalPropagator = function() {
                            return getGlobal(je) || Fe
                        }, PropagationAPI
                    }(),
                    Ue = ve.getInstance(),
                    $e = Me.getInstance();
                He.getInstance(), ce.instance();
                var Ve;

                function interfaces_setSpan(t, d) {
                    return $e.setSpan(t, d)
                }! function(t) {
                    t[t.INTERNAL = 0] = "INTERNAL", t[t.SERVER = 1] = "SERVER", t[t.CLIENT = 2] = "CLIENT", t[t.PRODUCER = 3] = "PRODUCER", t[t.CONSUMER = 4] = "CONSUMER"
                }(Ve || (Ve = {}));
                const Ke = Ue;
                var Ge;
                ! function(t) {
                    t[t.UNSET = 0] = "UNSET", t[t.OK = 1] = "OK", t[t.ERROR = 2] = "ERROR"
                }(Ge || (Ge = {}));
                class BlobQueryResponse {
                    constructor(t, d = {}) {
                        this.originalResponse = t
                    }
                    get acceptRanges() {
                        return this.originalResponse.acceptRanges
                    }
                    get cacheControl() {
                        return this.originalResponse.cacheControl
                    }
                    get contentDisposition() {
                        return this.originalResponse.contentDisposition
                    }
                    get contentEncoding() {
                        return this.originalResponse.contentEncoding
                    }
                    get contentLanguage() {
                        return this.originalResponse.contentLanguage
                    }
                    get blobSequenceNumber() {
                        return this.originalResponse.blobSequenceNumber
                    }
                    get blobType() {
                        return this.originalResponse.blobType
                    }
                    get contentLength() {
                        return this.originalResponse.contentLength
                    }
                    get contentMD5() {
                        return this.originalResponse.contentMD5
                    }
                    get contentRange() {
                        return this.originalResponse.contentRange
                    }
                    get contentType() {
                        return this.originalResponse.contentType
                    }
                    get copyCompletedOn() {}
                    get copyId() {
                        return this.originalResponse.copyId
                    }
                    get copyProgress() {
                        return this.originalResponse.copyProgress
                    }
                    get copySource() {
                        return this.originalResponse.copySource
                    }
                    get copyStatus() {
                        return this.originalResponse.copyStatus
                    }
                    get copyStatusDescription() {
                        return this.originalResponse.copyStatusDescription
                    }
                    get leaseDuration() {
                        return this.originalResponse.leaseDuration
                    }
                    get leaseState() {
                        return this.originalResponse.leaseState
                    }
                    get leaseStatus() {
                        return this.originalResponse.leaseStatus
                    }
                    get date() {
                        return this.originalResponse.date
                    }
                    get blobCommittedBlockCount() {
                        return this.originalResponse.blobCommittedBlockCount
                    }
                    get etag() {
                        return this.originalResponse.etag
                    }
                    get errorCode() {
                        return this.originalResponse.errorCode
                    }
                    get isServerEncrypted() {
                        return this.originalResponse.isServerEncrypted
                    }
                    get blobContentMD5() {
                        return this.originalResponse.blobContentMD5
                    }
                    get lastModified() {
                        return this.originalResponse.lastModified
                    }
                    get metadata() {
                        return this.originalResponse.metadata
                    }
                    get requestId() {
                        return this.originalResponse.requestId
                    }
                    get clientRequestId() {
                        return this.originalResponse.clientRequestId
                    }
                    get version() {
                        return this.originalResponse.version
                    }
                    get encryptionKeySha256() {
                        return this.originalResponse.encryptionKeySha256
                    }
                    get contentCrc64() {
                        return this.originalResponse.contentCrc64
                    }
                    get blobBody() {
                        throw Error("Quick query in browser is not supported yet.")
                    }
                    get readableStreamBody() {}
                    get _response() {
                        return this.originalResponse._response
                    }
                }
                var We;
                ! function(t) {
                    t[t.OFF = 0] = "OFF", t[t.ERROR = 1] = "ERROR", t[t.WARNING = 2] = "WARNING", t[t.INFO = 3] = "INFO"
                }(We || (We = {}));
                class requestPolicy_BaseRequestPolicy {
                    constructor(t, d) {
                        this._nextPolicy = t, this._options = d
                    }
                    shouldLog(t) {
                        return this._options.shouldLog(t)
                    }
                    log(t, d) {
                        this._options.log(t, d)
                    }
                }
                class RequestPolicyOptions {
                    constructor(t) {
                        this._logger = t
                    }
                    shouldLog(t) {
                        return !!this._logger && t !== We.OFF && t <= this._logger.minimumLogLevel
                    }
                    log(t, d) {
                        this._logger && this.shouldLog(t) && this._logger.log(t, d)
                    }
                }
                class CredentialPolicy extends requestPolicy_BaseRequestPolicy {
                    sendRequest(t) {
                        return this._nextPolicy.sendRequest(this.signRequest(t))
                    }
                    signRequest(t) {
                        return t
                    }
                }
                class AnonymousCredentialPolicy extends CredentialPolicy {
                    constructor(t, d) {
                        super(t, d)
                    }
                }
                class AnonymousCredential extends class Credential {
                    create(t, d) {
                        throw new Error("Method should be implemented in children classes.")
                    }
                } {
                    create(t, d) {
                        return new AnonymousCredentialPolicy(t, d)
                    }
                }
                class StorageSharedKeyCredential {}
                var extendStatics = function(t, d) {
                    return extendStatics = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, d) {
                        t.__proto__ = d
                    } || function(t, d) {
                        for (var h in d) Object.prototype.hasOwnProperty.call(d, h) && (t[h] = d[h])
                    }, extendStatics(t, d)
                };
                Object.create;
                Object.create;

                function operationOptionsToRequestOptionsBase(t) {
                    var d;
                    const {
                        requestOptions: h,
                        tracingOptions: y
                    } = t, _ = function __rest(t, d) {
                        var h = {};
                        for (var y in t) Object.prototype.hasOwnProperty.call(t, y) && d.indexOf(y) < 0 && (h[y] = t[y]);
                        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
                            var _ = 0;
                            for (y = Object.getOwnPropertySymbols(t); _ < y.length; _++) d.indexOf(y[_]) < 0 && Object.prototype.propertyIsEnumerable.call(t, y[_]) && (h[y[_]] = t[y[_]])
                        }
                        return h
                    }(t, ["requestOptions", "tracingOptions"]);
                    let x = _;
                    return h && (x = Object.assign(Object.assign({}, x), h)), y && (x.tracingContext = y.tracingContext, x.spanOptions = null === (d = y) || void 0 === d ? void 0 : d.spanOptions), x
                }

                function encodeByteArray(t) {
                    let d = "";
                    for (let h = 0; h < t.length; h++) d += String.fromCharCode(t[h]);
                    return btoa(d)
                }

                function decodeString(t) {
                    const d = atob(t),
                        h = new Uint8Array(d.length);
                    for (let y = 0; y < d.length; y++) h[y] = d.charCodeAt(y);
                    return h
                }
                class Serializer {
                    constructor(t = {}, d) {
                        this.modelMappers = t, this.isXML = d
                    }
                    validateConstraints(t, d, h) {
                        const failValidation = (t, y) => {
                            throw new Error(`"${h}" with value "${d}" should satisfy the constraint "${t}": ${y}.`)
                        };
                        if (t.constraints && null != d) {
                            const h = d,
                                {
                                    ExclusiveMaximum: y,
                                    ExclusiveMinimum: _,
                                    InclusiveMaximum: x,
                                    InclusiveMinimum: C,
                                    MaxItems: E,
                                    MaxLength: O,
                                    MinItems: k,
                                    MinLength: z,
                                    MultipleOf: A,
                                    Pattern: B,
                                    UniqueItems: I
                                } = t.constraints;
                            null != y && h >= y && failValidation("ExclusiveMaximum", y), null != _ && h <= _ && failValidation("ExclusiveMinimum", _), null != x && h > x && failValidation("InclusiveMaximum", x), null != C && h < C && failValidation("InclusiveMinimum", C);
                            const q = d;
                            if (null != E && q.length > E && failValidation("MaxItems", E), null != O && q.length > O && failValidation("MaxLength", O), null != k && q.length < k && failValidation("MinItems", k), null != z && q.length < z && failValidation("MinLength", z), null != A && h % A != 0 && failValidation("MultipleOf", A), B) {
                                const t = "string" == typeof B ? new RegExp(B) : B;
                                "string" == typeof d && null !== d.match(t) || failValidation("Pattern", B)
                            }
                            I && q.some(((t, d, h) => h.indexOf(t) !== d)) && failValidation("UniqueItems", I)
                        }
                    }
                    serialize(t, d, h, y = {}) {
                        var _, x, O;
                        const k = {
                            rootName: null !== (_ = y.rootName) && void 0 !== _ ? _ : "",
                            includeRoot: null !== (x = y.includeRoot) && void 0 !== x && x,
                            xmlCharKey: null !== (O = y.xmlCharKey) && void 0 !== O ? O : E
                        };
                        let z = {};
                        const A = t.type.name;
                        h || (h = t.serializedName), null !== A.match(/^Sequence$/i) && (z = []), t.isConstant && (d = t.defaultValue);
                        const {
                            required: B,
                            nullable: I
                        } = t;
                        if (B && I && void 0 === d) throw new Error(`${h} cannot be undefined.`);
                        if (B && !I && null == d) throw new Error(`${h} cannot be null or undefined.`);
                        if (!B && !1 === I && null === d) throw new Error(`${h} cannot be null.`);
                        if (null == d) z = d;
                        else if (this.validateConstraints(t, d, h), null !== A.match(/^any$/i)) z = d;
                        else if (null !== A.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i)) z = function serializeBasicTypes(t, d, h) {
                            if (null != h)
                                if (null !== t.match(/^Number$/i)) {
                                    if ("number" != typeof h) throw new Error(`${d} with value ${h} must be of type number.`)
                                } else if (null !== t.match(/^String$/i)) {
                                if ("string" != typeof h.valueOf()) throw new Error(`${d} with value "${h}" must be of type string.`)
                            } else if (null !== t.match(/^Uuid$/i)) {
                                if ("string" != typeof h.valueOf() || ! function isValidUuid(t) {
                                        return j.test(t)
                                    }(h)) throw new Error(`${d} with value "${h}" must be of type string and a valid uuid.`)
                            } else if (null !== t.match(/^Boolean$/i)) {
                                if ("boolean" != typeof h) throw new Error(`${d} with value ${h} must be of type boolean.`)
                            } else if (null !== t.match(/^Stream$/i)) {
                                const t = typeof h;
                                if (!("string" === t || "function" === t || h instanceof ArrayBuffer || ArrayBuffer.isView(h) || ("function" == typeof Blob || "object" == typeof Blob) && h instanceof Blob)) throw new Error(`${d} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`)
                            }
                            return h
                        }(A, h, d);
                        else if (null !== A.match(/^Enum$/i)) {
                            z = function serializeEnumType(t, d, h) {
                                if (!d) throw new Error(`Please provide a set of allowedValues to validate ${t} as an Enum Type.`);
                                if (!d.some((t => "string" == typeof t.valueOf() ? t.toLowerCase() === h.toLowerCase() : t === h))) throw new Error(`${h} is not a valid value for ${t}. The valid values are: ${JSON.stringify(d)}.`);
                                return h
                            }(h, t.type.allowedValues, d)
                        } else null !== A.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) ? z = function serializeDateTypes(t, d, h) {
                            if (null != d)
                                if (null !== t.match(/^Date$/i)) {
                                    if (!(d instanceof Date || "string" == typeof d.valueOf() && !isNaN(Date.parse(d)))) throw new Error(`${h} must be an instanceof Date or a string in ISO8601 format.`);
                                    d = d instanceof Date ? d.toISOString().substring(0, 10) : new Date(d).toISOString().substring(0, 10)
                                } else if (null !== t.match(/^DateTime$/i)) {
                                if (!(d instanceof Date || "string" == typeof d.valueOf() && !isNaN(Date.parse(d)))) throw new Error(`${h} must be an instanceof Date or a string in ISO8601 format.`);
                                d = d instanceof Date ? d.toISOString() : new Date(d).toISOString()
                            } else if (null !== t.match(/^DateTimeRfc1123$/i)) {
                                if (!(d instanceof Date || "string" == typeof d.valueOf() && !isNaN(Date.parse(d)))) throw new Error(`${h} must be an instanceof Date or a string in RFC-1123 format.`);
                                d = d instanceof Date ? d.toUTCString() : new Date(d).toUTCString()
                            } else if (null !== t.match(/^UnixTime$/i)) {
                                if (!(d instanceof Date || "string" == typeof d.valueOf() && !isNaN(Date.parse(d)))) throw new Error(`${h} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
                                d = function dateToUnixTime(t) {
                                    if (!t) return;
                                    "string" == typeof t.valueOf() && (t = new Date(t));
                                    return Math.floor(t.getTime() / 1e3)
                                }(d)
                            } else if (null !== t.match(/^TimeSpan$/i) && ! function isDuration(t) {
                                    return $.test(t)
                                }(d)) throw new Error(`${h} must be a string in ISO 8601 format. Instead was "${d}".`);
                            return d
                        }(A, d, h) : null !== A.match(/^ByteArray$/i) ? z = function serializeByteArrayType(t, d) {
                            let h = "";
                            if (null != d) {
                                if (!(d instanceof Uint8Array)) throw new Error(`${t} must be of type Uint8Array.`);
                                h = encodeByteArray(d)
                            }
                            return h
                        }(h, d) : null !== A.match(/^Base64Url$/i) ? z = function serializeBase64UrlType(t, d) {
                            let h = "";
                            if (null != d) {
                                if (!(d instanceof Uint8Array)) throw new Error(`${t} must be of type Uint8Array.`);
                                h = function bufferToBase64Url(t) {
                                    if (!t) return;
                                    if (!(t instanceof Uint8Array)) throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
                                    return function trimEnd(t, d) {
                                        let h = t.length;
                                        for (; h - 1 >= 0 && t[h - 1] === d;) --h;
                                        return t.substr(0, h)
                                    }(encodeByteArray(t), "=").replace(/\+/g, "-").replace(/\//g, "_")
                                }(d) || ""
                            }
                            return h
                        }(h, d) : null !== A.match(/^Sequence$/i) ? z = function serializeSequenceType(t, d, h, y, _, x) {
                            if (!Array.isArray(h)) throw new Error(`${y} must be of type Array.`);
                            const E = d.type.element;
                            if (!E || "object" != typeof E) throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${y}.`);
                            const O = [];
                            for (let k = 0; k < h.length; k++) {
                                const d = t.serialize(E, h[k], y, x);
                                if (_ && E.xmlNamespace) {
                                    const t = E.xmlNamespacePrefix ? `xmlns:${E.xmlNamespacePrefix}` : "xmlns";
                                    "Composite" === E.type.name ? (O[k] = Object.assign({}, d), O[k][C] = {
                                        [t]: E.xmlNamespace
                                    }) : (O[k] = {}, O[k][x.xmlCharKey] = d, O[k][C] = {
                                        [t]: E.xmlNamespace
                                    })
                                } else O[k] = d
                            }
                            return O
                        }(this, t, d, h, Boolean(this.isXML), k) : null !== A.match(/^Dictionary$/i) ? z = function serializeDictionaryType(t, d, h, y, _, x) {
                            if ("object" != typeof h) throw new Error(`${y} must be of type object.`);
                            const E = d.type.value;
                            if (!E || "object" != typeof E) throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${y}.`);
                            const O = {};
                            for (const C of Object.keys(h)) {
                                const d = t.serialize(E, h[C], y, x);
                                O[C] = getXmlObjectValue(E, d, _, x)
                            }
                            if (_ && d.xmlNamespace) {
                                const t = d.xmlNamespacePrefix ? `xmlns:${d.xmlNamespacePrefix}` : "xmlns",
                                    h = O;
                                return h[C] = {
                                    [t]: d.xmlNamespace
                                }, h
                            }
                            return O
                        }(this, t, d, h, Boolean(this.isXML), k) : null !== A.match(/^Composite$/i) && (z = function serializeCompositeType(t, d, h, y, _, x) {
                            getPolymorphicDiscriminatorRecursively(t, d) && (d = getPolymorphicMapper(t, d, h, "clientName"));
                            if (null != h) {
                                const E = {},
                                    O = resolveModelProperties(t, d, y);
                                for (const z of Object.keys(O)) {
                                    const k = O[z];
                                    if (k.readOnly) continue;
                                    let A, B = E;
                                    if (t.isXML) A = k.xmlIsWrapped ? k.xmlName : k.xmlElementName || k.xmlName;
                                    else {
                                        const t = splitSerializeName(k.serializedName);
                                        A = t.pop();
                                        for (const d of t) {
                                            null != B[d] || null == h[z] && void 0 === k.defaultValue || (B[d] = {}), B = B[d]
                                        }
                                    }
                                    if (null != B) {
                                        if (_ && d.xmlNamespace) {
                                            const t = d.xmlNamespacePrefix ? `xmlns:${d.xmlNamespacePrefix}` : "xmlns";
                                            B[C] = Object.assign(Object.assign({}, B[C]), {
                                                [t]: d.xmlNamespace
                                            })
                                        }
                                        const E = "" !== k.serializedName ? y + "." + k.serializedName : y;
                                        let O = h[z];
                                        const I = getPolymorphicDiscriminatorRecursively(t, d);
                                        I && I.clientName === z && null == O && (O = d.serializedName);
                                        const q = t.serialize(k, O, E, x);
                                        if (void 0 !== q && null != A) {
                                            const t = getXmlObjectValue(k, q, _, x);
                                            _ && k.xmlIsAttribute ? (B[C] = B[C] || {}, B[C][A] = q) : _ && k.xmlIsWrapped ? B[A] = {
                                                [k.xmlElementName]: t
                                            } : B[A] = t
                                        }
                                    }
                                }
                                const k = function resolveAdditionalProperties(t, d, h) {
                                    const y = d.type.additionalProperties;
                                    if (!y && d.type.className) {
                                        const y = resolveReferencedMapper(t, d, h);
                                        return null == y ? void 0 : y.type.additionalProperties
                                    }
                                    return y
                                }(t, d, y);
                                if (k) {
                                    const d = Object.keys(O);
                                    for (const _ in h) {
                                        d.every((t => t !== _)) && (E[_] = t.serialize(k, h[_], y + '["' + _ + '"]', x))
                                    }
                                }
                                return E
                            }
                            return h
                        }(this, t, d, h, Boolean(this.isXML), k));
                        return z
                    }
                    deserialize(t, d, h, y = {}) {
                        var _, x, O;
                        const k = {
                            rootName: null !== (_ = y.rootName) && void 0 !== _ ? _ : "",
                            includeRoot: null !== (x = y.includeRoot) && void 0 !== x && x,
                            xmlCharKey: null !== (O = y.xmlCharKey) && void 0 !== O ? O : E
                        };
                        if (null == d) return this.isXML && "Sequence" === t.type.name && !t.xmlIsWrapped && (d = []), void 0 !== t.defaultValue && (d = t.defaultValue), d;
                        let z;
                        const A = t.type.name;
                        if (h || (h = t.serializedName), null !== A.match(/^Composite$/i)) z = function deserializeCompositeType(t, d, h, y, _) {
                            var x;
                            getPolymorphicDiscriminatorRecursively(t, d) && (d = getPolymorphicMapper(t, d, h, "serializedName"));
                            const E = resolveModelProperties(t, d, y);
                            let O = {};
                            const k = [];
                            for (const A of Object.keys(E)) {
                                const z = E[A],
                                    B = splitSerializeName(E[A].serializedName);
                                k.push(B[0]);
                                const {
                                    serializedName: I,
                                    xmlName: q,
                                    xmlElementName: D
                                } = z;
                                let j = y;
                                "" !== I && void 0 !== I && (j = y + "." + I);
                                const H = z.headerCollectionPrefix;
                                if (H) {
                                    const d = {};
                                    for (const y of Object.keys(h)) y.startsWith(H) && (d[y.substring(H.length)] = t.deserialize(z.type.value, h[y], j, _)), k.push(y);
                                    O[A] = d
                                } else if (t.isXML)
                                    if (z.xmlIsAttribute && h[C]) O[A] = t.deserialize(z, h[C][q], j, _);
                                    else {
                                        const d = D || q || I;
                                        if (z.xmlIsWrapped) {
                                            const d = h[q],
                                                y = null !== (x = null == d ? void 0 : d[D]) && void 0 !== x ? x : [];
                                            O[A] = t.deserialize(z, y, j, _)
                                        } else {
                                            const y = h[d];
                                            O[A] = t.deserialize(z, y, j, _)
                                        }
                                    }
                                else {
                                    let y, x = h;
                                    for (const t of B) {
                                        if (!x) break;
                                        x = x[t]
                                    }
                                    y = x;
                                    const C = d.type.polymorphicDiscriminator;
                                    let k;
                                    if (C && A === C.clientName && null == y && (y = d.serializedName), Array.isArray(h[A]) && "" === E[A].serializedName) {
                                        y = h[A];
                                        const d = t.deserialize(z, y, j, _);
                                        for (const [t, h] of Object.entries(O)) Object.prototype.hasOwnProperty.call(d, t) || (d[t] = h);
                                        O = d
                                    } else void 0 === y && void 0 === z.defaultValue || (k = t.deserialize(z, y, j, _), O[A] = k)
                                }
                            }
                            const z = d.type.additionalProperties;
                            if (z) {
                                const isAdditionalProperty = t => {
                                    for (const d in E) {
                                        if (splitSerializeName(E[d].serializedName)[0] === t) return !1
                                    }
                                    return !0
                                };
                                for (const d in h) isAdditionalProperty(d) && (O[d] = t.deserialize(z, h[d], y + '["' + d + '"]', _))
                            } else if (h)
                                for (const C of Object.keys(h)) void 0 !== O[C] || k.includes(C) || isSpecialXmlProperty(C, _) || (O[C] = h[C]);
                            return O
                        }(this, t, d, h, k);
                        else {
                            if (this.isXML) {
                                const t = k.xmlCharKey,
                                    h = d;
                                null != h[C] && null != h[t] && (d = h[t])
                            }
                            null !== A.match(/^Number$/i) ? (z = parseFloat(d), isNaN(z) && (z = d)) : null !== A.match(/^Boolean$/i) ? z = "true" === d || "false" !== d && d : null !== A.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) ? z = d : null !== A.match(/^(Date|DateTime|DateTimeRfc1123)$/i) ? z = new Date(d) : null !== A.match(/^UnixTime$/i) ? z = function unixTimeToDate(t) {
                                if (!t) return;
                                return new Date(1e3 * t)
                            }(d) : null !== A.match(/^ByteArray$/i) ? z = decodeString(d) : null !== A.match(/^Base64Url$/i) ? z = function base64UrlToByteArray(t) {
                                if (!t) return;
                                if (t && "string" != typeof t.valueOf()) throw new Error("Please provide an input of type string for converting to Uint8Array");
                                return decodeString(t = t.replace(/-/g, "+").replace(/_/g, "/"))
                            }(d) : null !== A.match(/^Sequence$/i) ? z = function deserializeSequenceType(t, d, h, y, _) {
                                const x = d.type.element;
                                if (!x || "object" != typeof x) throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${y}`);
                                if (h) {
                                    Array.isArray(h) || (h = [h]);
                                    const d = [];
                                    for (let C = 0; C < h.length; C++) d[C] = t.deserialize(x, h[C], `${y}[${C}]`, _);
                                    return d
                                }
                                return h
                            }(this, t, d, h, k) : null !== A.match(/^Dictionary$/i) && (z = function deserializeDictionaryType(t, d, h, y, _) {
                                const x = d.type.value;
                                if (!x || "object" != typeof x) throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${y}`);
                                if (h) {
                                    const d = {};
                                    for (const C of Object.keys(h)) d[C] = t.deserialize(x, h[C], y, _);
                                    return d
                                }
                                return h
                            }(this, t, d, h, k))
                        }
                        return t.isConstant && (z = t.defaultValue), z
                    }
                }

                function splitSerializeName(t) {
                    const d = [];
                    let h = "";
                    if (t) {
                        const y = t.split(".");
                        for (const t of y) "\\" === t.charAt(t.length - 1) ? h += t.substr(0, t.length - 1) + "." : (h += t, d.push(h), h = "")
                    }
                    return d
                }

                function resolveReferencedMapper(t, d, h) {
                    const y = d.type.className;
                    if (!y) throw new Error(`Class name for model "${h}" is not provided in the mapper "${JSON.stringify(d,void 0,2)}".`);
                    return t.modelMappers[y]
                }

                function resolveModelProperties(t, d, h) {
                    let y = d.type.modelProperties;
                    if (!y) {
                        const _ = resolveReferencedMapper(t, d, h);
                        if (!_) throw new Error(`mapper() cannot be null or undefined for model "${d.type.className}".`);
                        if (y = null == _ ? void 0 : _.type.modelProperties, !y) throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(_)}" of type "${d.type.className}" for object "${h}".`)
                    }
                    return y
                }

                function getXmlObjectValue(t, d, h, y) {
                    if (!h || !t.xmlNamespace) return d;
                    const _ = {
                        [t.xmlNamespacePrefix ? `xmlns:${t.xmlNamespacePrefix}` : "xmlns"]: t.xmlNamespace
                    };
                    if (["Composite"].includes(t.type.name)) {
                        if (d[C]) return d; {
                            const t = Object.assign({}, d);
                            return t[C] = _, t
                        }
                    }
                    const x = {};
                    return x[y.xmlCharKey] = d, x[C] = _, x
                }

                function isSpecialXmlProperty(t, d) {
                    return [C, d.xmlCharKey].includes(t)
                }

                function getPolymorphicMapper(t, d, h, y) {
                    const _ = getPolymorphicDiscriminatorRecursively(t, d);
                    if (_) {
                        const x = _[y];
                        if (null != x) {
                            const y = h[x];
                            if (null != y) {
                                const h = d.type.uberParent || d.type.className,
                                    _ = y === h ? y : h + "." + y,
                                    x = t.modelMappers.discriminators[_];
                                x && (d = x)
                            }
                        }
                    }
                    return d
                }

                function getPolymorphicDiscriminatorRecursively(t, d) {
                    return d.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(t, d.type.uberParent) || getPolymorphicDiscriminatorSafely(t, d.type.className)
                }

                function getPolymorphicDiscriminatorSafely(t, d) {
                    return d && t.modelMappers[d] && t.modelMappers[d].type.polymorphicDiscriminator
                }
                const Xe = function strEnum(t) {
                        const d = {};
                        for (const h of t) d[h] = h;
                        return d
                    }(["Base64Url", "Boolean", "ByteArray", "Composite", "Date", "DateTime", "DateTimeRfc1123", "Dictionary", "Enum", "Number", "Object", "Sequence", "String", "Stream", "TimeSpan", "UnixTime"]),
                    Qe = {
                        serializedName: "BlobServiceProperties",
                        xmlName: "StorageServiceProperties",
                        type: {
                            name: "Composite",
                            className: "BlobServiceProperties",
                            modelProperties: {
                                blobAnalyticsLogging: {
                                    serializedName: "Logging",
                                    xmlName: "Logging",
                                    type: {
                                        name: "Composite",
                                        className: "Logging"
                                    }
                                },
                                hourMetrics: {
                                    serializedName: "HourMetrics",
                                    xmlName: "HourMetrics",
                                    type: {
                                        name: "Composite",
                                        className: "Metrics"
                                    }
                                },
                                minuteMetrics: {
                                    serializedName: "MinuteMetrics",
                                    xmlName: "MinuteMetrics",
                                    type: {
                                        name: "Composite",
                                        className: "Metrics"
                                    }
                                },
                                cors: {
                                    serializedName: "Cors",
                                    xmlName: "Cors",
                                    xmlIsWrapped: !0,
                                    xmlElementName: "CorsRule",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "CorsRule"
                                            }
                                        }
                                    }
                                },
                                defaultServiceVersion: {
                                    serializedName: "DefaultServiceVersion",
                                    xmlName: "DefaultServiceVersion",
                                    type: {
                                        name: "String"
                                    }
                                },
                                deleteRetentionPolicy: {
                                    serializedName: "DeleteRetentionPolicy",
                                    xmlName: "DeleteRetentionPolicy",
                                    type: {
                                        name: "Composite",
                                        className: "RetentionPolicy"
                                    }
                                },
                                staticWebsite: {
                                    serializedName: "StaticWebsite",
                                    xmlName: "StaticWebsite",
                                    type: {
                                        name: "Composite",
                                        className: "StaticWebsite"
                                    }
                                }
                            }
                        }
                    },
                    Je = {
                        serializedName: "Logging",
                        type: {
                            name: "Composite",
                            className: "Logging",
                            modelProperties: {
                                version: {
                                    serializedName: "Version",
                                    required: !0,
                                    xmlName: "Version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                deleteProperty: {
                                    serializedName: "Delete",
                                    required: !0,
                                    xmlName: "Delete",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                read: {
                                    serializedName: "Read",
                                    required: !0,
                                    xmlName: "Read",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                write: {
                                    serializedName: "Write",
                                    required: !0,
                                    xmlName: "Write",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                retentionPolicy: {
                                    serializedName: "RetentionPolicy",
                                    xmlName: "RetentionPolicy",
                                    type: {
                                        name: "Composite",
                                        className: "RetentionPolicy"
                                    }
                                }
                            }
                        }
                    },
                    Ye = {
                        serializedName: "RetentionPolicy",
                        type: {
                            name: "Composite",
                            className: "RetentionPolicy",
                            modelProperties: {
                                enabled: {
                                    serializedName: "Enabled",
                                    required: !0,
                                    xmlName: "Enabled",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                days: {
                                    constraints: {
                                        InclusiveMinimum: 1
                                    },
                                    serializedName: "Days",
                                    xmlName: "Days",
                                    type: {
                                        name: "Number"
                                    }
                                }
                            }
                        }
                    },
                    Ze = {
                        serializedName: "Metrics",
                        type: {
                            name: "Composite",
                            className: "Metrics",
                            modelProperties: {
                                version: {
                                    serializedName: "Version",
                                    xmlName: "Version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                enabled: {
                                    serializedName: "Enabled",
                                    required: !0,
                                    xmlName: "Enabled",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                includeAPIs: {
                                    serializedName: "IncludeAPIs",
                                    xmlName: "IncludeAPIs",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                retentionPolicy: {
                                    serializedName: "RetentionPolicy",
                                    xmlName: "RetentionPolicy",
                                    type: {
                                        name: "Composite",
                                        className: "RetentionPolicy"
                                    }
                                }
                            }
                        }
                    },
                    et = {
                        serializedName: "CorsRule",
                        type: {
                            name: "Composite",
                            className: "CorsRule",
                            modelProperties: {
                                allowedOrigins: {
                                    serializedName: "AllowedOrigins",
                                    required: !0,
                                    xmlName: "AllowedOrigins",
                                    type: {
                                        name: "String"
                                    }
                                },
                                allowedMethods: {
                                    serializedName: "AllowedMethods",
                                    required: !0,
                                    xmlName: "AllowedMethods",
                                    type: {
                                        name: "String"
                                    }
                                },
                                allowedHeaders: {
                                    serializedName: "AllowedHeaders",
                                    required: !0,
                                    xmlName: "AllowedHeaders",
                                    type: {
                                        name: "String"
                                    }
                                },
                                exposedHeaders: {
                                    serializedName: "ExposedHeaders",
                                    required: !0,
                                    xmlName: "ExposedHeaders",
                                    type: {
                                        name: "String"
                                    }
                                },
                                maxAgeInSeconds: {
                                    constraints: {
                                        InclusiveMinimum: 0
                                    },
                                    serializedName: "MaxAgeInSeconds",
                                    required: !0,
                                    xmlName: "MaxAgeInSeconds",
                                    type: {
                                        name: "Number"
                                    }
                                }
                            }
                        }
                    },
                    tt = {
                        serializedName: "StaticWebsite",
                        type: {
                            name: "Composite",
                            className: "StaticWebsite",
                            modelProperties: {
                                enabled: {
                                    serializedName: "Enabled",
                                    required: !0,
                                    xmlName: "Enabled",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                indexDocument: {
                                    serializedName: "IndexDocument",
                                    xmlName: "IndexDocument",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorDocument404Path: {
                                    serializedName: "ErrorDocument404Path",
                                    xmlName: "ErrorDocument404Path",
                                    type: {
                                        name: "String"
                                    }
                                },
                                defaultIndexDocumentPath: {
                                    serializedName: "DefaultIndexDocumentPath",
                                    xmlName: "DefaultIndexDocumentPath",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    rt = {
                        serializedName: "StorageError",
                        type: {
                            name: "Composite",
                            className: "StorageError",
                            modelProperties: {
                                message: {
                                    serializedName: "Message",
                                    xmlName: "Message",
                                    type: {
                                        name: "String"
                                    }
                                },
                                code: {
                                    serializedName: "Code",
                                    xmlName: "Code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    nt = {
                        serializedName: "BlobServiceStatistics",
                        xmlName: "StorageServiceStats",
                        type: {
                            name: "Composite",
                            className: "BlobServiceStatistics",
                            modelProperties: {
                                geoReplication: {
                                    serializedName: "GeoReplication",
                                    xmlName: "GeoReplication",
                                    type: {
                                        name: "Composite",
                                        className: "GeoReplication"
                                    }
                                }
                            }
                        }
                    },
                    it = {
                        serializedName: "GeoReplication",
                        type: {
                            name: "Composite",
                            className: "GeoReplication",
                            modelProperties: {
                                status: {
                                    serializedName: "Status",
                                    required: !0,
                                    xmlName: "Status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["live", "bootstrap", "unavailable"]
                                    }
                                },
                                lastSyncOn: {
                                    serializedName: "LastSyncTime",
                                    required: !0,
                                    xmlName: "LastSyncTime",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    ot = {
                        serializedName: "ListContainersSegmentResponse",
                        xmlName: "EnumerationResults",
                        type: {
                            name: "Composite",
                            className: "ListContainersSegmentResponse",
                            modelProperties: {
                                serviceEndpoint: {
                                    serializedName: "ServiceEndpoint",
                                    required: !0,
                                    xmlName: "ServiceEndpoint",
                                    xmlIsAttribute: !0,
                                    type: {
                                        name: "String"
                                    }
                                },
                                prefix: {
                                    serializedName: "Prefix",
                                    xmlName: "Prefix",
                                    type: {
                                        name: "String"
                                    }
                                },
                                marker: {
                                    serializedName: "Marker",
                                    xmlName: "Marker",
                                    type: {
                                        name: "String"
                                    }
                                },
                                maxPageSize: {
                                    serializedName: "MaxResults",
                                    xmlName: "MaxResults",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                containerItems: {
                                    serializedName: "ContainerItems",
                                    required: !0,
                                    xmlName: "Containers",
                                    xmlIsWrapped: !0,
                                    xmlElementName: "Container",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "ContainerItem"
                                            }
                                        }
                                    }
                                },
                                continuationToken: {
                                    serializedName: "NextMarker",
                                    xmlName: "NextMarker",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    at = {
                        serializedName: "ContainerItem",
                        xmlName: "Container",
                        type: {
                            name: "Composite",
                            className: "ContainerItem",
                            modelProperties: {
                                name: {
                                    serializedName: "Name",
                                    required: !0,
                                    xmlName: "Name",
                                    type: {
                                        name: "String"
                                    }
                                },
                                deleted: {
                                    serializedName: "Deleted",
                                    xmlName: "Deleted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                version: {
                                    serializedName: "Version",
                                    xmlName: "Version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                properties: {
                                    serializedName: "Properties",
                                    xmlName: "Properties",
                                    type: {
                                        name: "Composite",
                                        className: "ContainerProperties"
                                    }
                                },
                                metadata: {
                                    serializedName: "Metadata",
                                    xmlName: "Metadata",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    st = {
                        serializedName: "ContainerProperties",
                        type: {
                            name: "Composite",
                            className: "ContainerProperties",
                            modelProperties: {
                                lastModified: {
                                    serializedName: "Last-Modified",
                                    required: !0,
                                    xmlName: "Last-Modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                etag: {
                                    serializedName: "Etag",
                                    required: !0,
                                    xmlName: "Etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                leaseStatus: {
                                    serializedName: "LeaseStatus",
                                    xmlName: "LeaseStatus",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["locked", "unlocked"]
                                    }
                                },
                                leaseState: {
                                    serializedName: "LeaseState",
                                    xmlName: "LeaseState",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["available", "leased", "expired", "breaking", "broken"]
                                    }
                                },
                                leaseDuration: {
                                    serializedName: "LeaseDuration",
                                    xmlName: "LeaseDuration",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["infinite", "fixed"]
                                    }
                                },
                                publicAccess: {
                                    serializedName: "PublicAccess",
                                    xmlName: "PublicAccess",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["container", "blob"]
                                    }
                                },
                                hasImmutabilityPolicy: {
                                    serializedName: "HasImmutabilityPolicy",
                                    xmlName: "HasImmutabilityPolicy",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                hasLegalHold: {
                                    serializedName: "HasLegalHold",
                                    xmlName: "HasLegalHold",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                defaultEncryptionScope: {
                                    serializedName: "DefaultEncryptionScope",
                                    xmlName: "DefaultEncryptionScope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                preventEncryptionScopeOverride: {
                                    serializedName: "DenyEncryptionScopeOverride",
                                    xmlName: "DenyEncryptionScopeOverride",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                deletedOn: {
                                    serializedName: "DeletedTime",
                                    xmlName: "DeletedTime",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                remainingRetentionDays: {
                                    serializedName: "RemainingRetentionDays",
                                    xmlName: "RemainingRetentionDays",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                isImmutableStorageWithVersioningEnabled: {
                                    serializedName: "ImmutableStorageWithVersioningEnabled",
                                    xmlName: "ImmutableStorageWithVersioningEnabled",
                                    type: {
                                        name: "Boolean"
                                    }
                                }
                            }
                        }
                    },
                    lt = {
                        serializedName: "KeyInfo",
                        type: {
                            name: "Composite",
                            className: "KeyInfo",
                            modelProperties: {
                                startsOn: {
                                    serializedName: "Start",
                                    required: !0,
                                    xmlName: "Start",
                                    type: {
                                        name: "String"
                                    }
                                },
                                expiresOn: {
                                    serializedName: "Expiry",
                                    required: !0,
                                    xmlName: "Expiry",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ct = {
                        serializedName: "UserDelegationKey",
                        type: {
                            name: "Composite",
                            className: "UserDelegationKey",
                            modelProperties: {
                                signedObjectId: {
                                    serializedName: "SignedOid",
                                    required: !0,
                                    xmlName: "SignedOid",
                                    type: {
                                        name: "String"
                                    }
                                },
                                signedTenantId: {
                                    serializedName: "SignedTid",
                                    required: !0,
                                    xmlName: "SignedTid",
                                    type: {
                                        name: "String"
                                    }
                                },
                                signedStartsOn: {
                                    serializedName: "SignedStart",
                                    required: !0,
                                    xmlName: "SignedStart",
                                    type: {
                                        name: "String"
                                    }
                                },
                                signedExpiresOn: {
                                    serializedName: "SignedExpiry",
                                    required: !0,
                                    xmlName: "SignedExpiry",
                                    type: {
                                        name: "String"
                                    }
                                },
                                signedService: {
                                    serializedName: "SignedService",
                                    required: !0,
                                    xmlName: "SignedService",
                                    type: {
                                        name: "String"
                                    }
                                },
                                signedVersion: {
                                    serializedName: "SignedVersion",
                                    required: !0,
                                    xmlName: "SignedVersion",
                                    type: {
                                        name: "String"
                                    }
                                },
                                value: {
                                    serializedName: "Value",
                                    required: !0,
                                    xmlName: "Value",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ut = {
                        serializedName: "FilterBlobSegment",
                        xmlName: "EnumerationResults",
                        type: {
                            name: "Composite",
                            className: "FilterBlobSegment",
                            modelProperties: {
                                serviceEndpoint: {
                                    serializedName: "ServiceEndpoint",
                                    required: !0,
                                    xmlName: "ServiceEndpoint",
                                    xmlIsAttribute: !0,
                                    type: {
                                        name: "String"
                                    }
                                },
                                where: {
                                    serializedName: "Where",
                                    required: !0,
                                    xmlName: "Where",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobs: {
                                    serializedName: "Blobs",
                                    required: !0,
                                    xmlName: "Blobs",
                                    xmlIsWrapped: !0,
                                    xmlElementName: "Blob",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "FilterBlobItem"
                                            }
                                        }
                                    }
                                },
                                continuationToken: {
                                    serializedName: "NextMarker",
                                    xmlName: "NextMarker",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    dt = {
                        serializedName: "FilterBlobItem",
                        xmlName: "Blob",
                        type: {
                            name: "Composite",
                            className: "FilterBlobItem",
                            modelProperties: {
                                name: {
                                    serializedName: "Name",
                                    required: !0,
                                    xmlName: "Name",
                                    type: {
                                        name: "String"
                                    }
                                },
                                containerName: {
                                    serializedName: "ContainerName",
                                    required: !0,
                                    xmlName: "ContainerName",
                                    type: {
                                        name: "String"
                                    }
                                },
                                tags: {
                                    serializedName: "Tags",
                                    xmlName: "Tags",
                                    type: {
                                        name: "Composite",
                                        className: "BlobTags"
                                    }
                                }
                            }
                        }
                    },
                    pt = {
                        serializedName: "BlobTags",
                        xmlName: "Tags",
                        type: {
                            name: "Composite",
                            className: "BlobTags",
                            modelProperties: {
                                blobTagSet: {
                                    serializedName: "BlobTagSet",
                                    required: !0,
                                    xmlName: "TagSet",
                                    xmlIsWrapped: !0,
                                    xmlElementName: "Tag",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "BlobTag"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    mt = {
                        serializedName: "BlobTag",
                        xmlName: "Tag",
                        type: {
                            name: "Composite",
                            className: "BlobTag",
                            modelProperties: {
                                key: {
                                    serializedName: "Key",
                                    required: !0,
                                    xmlName: "Key",
                                    type: {
                                        name: "String"
                                    }
                                },
                                value: {
                                    serializedName: "Value",
                                    required: !0,
                                    xmlName: "Value",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ft = {
                        serializedName: "SignedIdentifier",
                        xmlName: "SignedIdentifier",
                        type: {
                            name: "Composite",
                            className: "SignedIdentifier",
                            modelProperties: {
                                id: {
                                    serializedName: "Id",
                                    required: !0,
                                    xmlName: "Id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                accessPolicy: {
                                    serializedName: "AccessPolicy",
                                    xmlName: "AccessPolicy",
                                    type: {
                                        name: "Composite",
                                        className: "AccessPolicy"
                                    }
                                }
                            }
                        }
                    },
                    ht = {
                        serializedName: "AccessPolicy",
                        type: {
                            name: "Composite",
                            className: "AccessPolicy",
                            modelProperties: {
                                startsOn: {
                                    serializedName: "Start",
                                    xmlName: "Start",
                                    type: {
                                        name: "String"
                                    }
                                },
                                expiresOn: {
                                    serializedName: "Expiry",
                                    xmlName: "Expiry",
                                    type: {
                                        name: "String"
                                    }
                                },
                                permissions: {
                                    serializedName: "Permission",
                                    xmlName: "Permission",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    yt = {
                        serializedName: "ListBlobsFlatSegmentResponse",
                        xmlName: "EnumerationResults",
                        type: {
                            name: "Composite",
                            className: "ListBlobsFlatSegmentResponse",
                            modelProperties: {
                                serviceEndpoint: {
                                    serializedName: "ServiceEndpoint",
                                    required: !0,
                                    xmlName: "ServiceEndpoint",
                                    xmlIsAttribute: !0,
                                    type: {
                                        name: "String"
                                    }
                                },
                                containerName: {
                                    serializedName: "ContainerName",
                                    required: !0,
                                    xmlName: "ContainerName",
                                    xmlIsAttribute: !0,
                                    type: {
                                        name: "String"
                                    }
                                },
                                prefix: {
                                    serializedName: "Prefix",
                                    xmlName: "Prefix",
                                    type: {
                                        name: "String"
                                    }
                                },
                                marker: {
                                    serializedName: "Marker",
                                    xmlName: "Marker",
                                    type: {
                                        name: "String"
                                    }
                                },
                                maxPageSize: {
                                    serializedName: "MaxResults",
                                    xmlName: "MaxResults",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                segment: {
                                    serializedName: "Segment",
                                    xmlName: "Blobs",
                                    type: {
                                        name: "Composite",
                                        className: "BlobFlatListSegment"
                                    }
                                },
                                continuationToken: {
                                    serializedName: "NextMarker",
                                    xmlName: "NextMarker",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    gt = {
                        serializedName: "BlobFlatListSegment",
                        xmlName: "Blobs",
                        type: {
                            name: "Composite",
                            className: "BlobFlatListSegment",
                            modelProperties: {
                                blobItems: {
                                    serializedName: "BlobItems",
                                    required: !0,
                                    xmlName: "BlobItems",
                                    xmlElementName: "Blob",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "BlobItemInternal"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    bt = {
                        serializedName: "BlobItemInternal",
                        xmlName: "Blob",
                        type: {
                            name: "Composite",
                            className: "BlobItemInternal",
                            modelProperties: {
                                name: {
                                    serializedName: "Name",
                                    required: !0,
                                    xmlName: "Name",
                                    type: {
                                        name: "String"
                                    }
                                },
                                deleted: {
                                    serializedName: "Deleted",
                                    required: !0,
                                    xmlName: "Deleted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                snapshot: {
                                    serializedName: "Snapshot",
                                    required: !0,
                                    xmlName: "Snapshot",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "VersionId",
                                    xmlName: "VersionId",
                                    type: {
                                        name: "String"
                                    }
                                },
                                isCurrentVersion: {
                                    serializedName: "IsCurrentVersion",
                                    xmlName: "IsCurrentVersion",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                properties: {
                                    serializedName: "Properties",
                                    xmlName: "Properties",
                                    type: {
                                        name: "Composite",
                                        className: "BlobPropertiesInternal"
                                    }
                                },
                                metadata: {
                                    serializedName: "Metadata",
                                    xmlName: "Metadata",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    }
                                },
                                blobTags: {
                                    serializedName: "BlobTags",
                                    xmlName: "Tags",
                                    type: {
                                        name: "Composite",
                                        className: "BlobTags"
                                    }
                                },
                                objectReplicationMetadata: {
                                    serializedName: "ObjectReplicationMetadata",
                                    xmlName: "OrMetadata",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    }
                                },
                                hasVersionsOnly: {
                                    serializedName: "HasVersionsOnly",
                                    xmlName: "HasVersionsOnly",
                                    type: {
                                        name: "Boolean"
                                    }
                                }
                            }
                        }
                    },
                    vt = {
                        serializedName: "BlobPropertiesInternal",
                        xmlName: "Properties",
                        type: {
                            name: "Composite",
                            className: "BlobPropertiesInternal",
                            modelProperties: {
                                createdOn: {
                                    serializedName: "Creation-Time",
                                    xmlName: "Creation-Time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                lastModified: {
                                    serializedName: "Last-Modified",
                                    required: !0,
                                    xmlName: "Last-Modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                etag: {
                                    serializedName: "Etag",
                                    required: !0,
                                    xmlName: "Etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentLength: {
                                    serializedName: "Content-Length",
                                    xmlName: "Content-Length",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                contentType: {
                                    serializedName: "Content-Type",
                                    xmlName: "Content-Type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentEncoding: {
                                    serializedName: "Content-Encoding",
                                    xmlName: "Content-Encoding",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentLanguage: {
                                    serializedName: "Content-Language",
                                    xmlName: "Content-Language",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "Content-MD5",
                                    xmlName: "Content-MD5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                contentDisposition: {
                                    serializedName: "Content-Disposition",
                                    xmlName: "Content-Disposition",
                                    type: {
                                        name: "String"
                                    }
                                },
                                cacheControl: {
                                    serializedName: "Cache-Control",
                                    xmlName: "Cache-Control",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                blobType: {
                                    serializedName: "BlobType",
                                    xmlName: "BlobType",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
                                    }
                                },
                                leaseStatus: {
                                    serializedName: "LeaseStatus",
                                    xmlName: "LeaseStatus",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["locked", "unlocked"]
                                    }
                                },
                                leaseState: {
                                    serializedName: "LeaseState",
                                    xmlName: "LeaseState",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["available", "leased", "expired", "breaking", "broken"]
                                    }
                                },
                                leaseDuration: {
                                    serializedName: "LeaseDuration",
                                    xmlName: "LeaseDuration",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["infinite", "fixed"]
                                    }
                                },
                                copyId: {
                                    serializedName: "CopyId",
                                    xmlName: "CopyId",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyStatus: {
                                    serializedName: "CopyStatus",
                                    xmlName: "CopyStatus",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["pending", "success", "aborted", "failed"]
                                    }
                                },
                                copySource: {
                                    serializedName: "CopySource",
                                    xmlName: "CopySource",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyProgress: {
                                    serializedName: "CopyProgress",
                                    xmlName: "CopyProgress",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyCompletedOn: {
                                    serializedName: "CopyCompletionTime",
                                    xmlName: "CopyCompletionTime",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                copyStatusDescription: {
                                    serializedName: "CopyStatusDescription",
                                    xmlName: "CopyStatusDescription",
                                    type: {
                                        name: "String"
                                    }
                                },
                                serverEncrypted: {
                                    serializedName: "ServerEncrypted",
                                    xmlName: "ServerEncrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                incrementalCopy: {
                                    serializedName: "IncrementalCopy",
                                    xmlName: "IncrementalCopy",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                destinationSnapshot: {
                                    serializedName: "DestinationSnapshot",
                                    xmlName: "DestinationSnapshot",
                                    type: {
                                        name: "String"
                                    }
                                },
                                deletedOn: {
                                    serializedName: "DeletedTime",
                                    xmlName: "DeletedTime",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                remainingRetentionDays: {
                                    serializedName: "RemainingRetentionDays",
                                    xmlName: "RemainingRetentionDays",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                accessTier: {
                                    serializedName: "AccessTier",
                                    xmlName: "AccessTier",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["P4", "P6", "P10", "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive"]
                                    }
                                },
                                accessTierInferred: {
                                    serializedName: "AccessTierInferred",
                                    xmlName: "AccessTierInferred",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                archiveStatus: {
                                    serializedName: "ArchiveStatus",
                                    xmlName: "ArchiveStatus",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["rehydrate-pending-to-hot", "rehydrate-pending-to-cool"]
                                    }
                                },
                                customerProvidedKeySha256: {
                                    serializedName: "CustomerProvidedKeySha256",
                                    xmlName: "CustomerProvidedKeySha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "EncryptionScope",
                                    xmlName: "EncryptionScope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                accessTierChangedOn: {
                                    serializedName: "AccessTierChangeTime",
                                    xmlName: "AccessTierChangeTime",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                tagCount: {
                                    serializedName: "TagCount",
                                    xmlName: "TagCount",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                expiresOn: {
                                    serializedName: "Expiry-Time",
                                    xmlName: "Expiry-Time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isSealed: {
                                    serializedName: "Sealed",
                                    xmlName: "Sealed",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                rehydratePriority: {
                                    serializedName: "RehydratePriority",
                                    xmlName: "RehydratePriority",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["High", "Standard"]
                                    }
                                },
                                lastAccessedOn: {
                                    serializedName: "LastAccessTime",
                                    xmlName: "LastAccessTime",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                immutabilityPolicyExpiresOn: {
                                    serializedName: "ImmutabilityPolicyUntilDate",
                                    xmlName: "ImmutabilityPolicyUntilDate",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                immutabilityPolicyMode: {
                                    serializedName: "ImmutabilityPolicyMode",
                                    xmlName: "ImmutabilityPolicyMode",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Mutable", "Unlocked", "Locked"]
                                    }
                                },
                                legalHold: {
                                    serializedName: "LegalHold",
                                    xmlName: "LegalHold",
                                    type: {
                                        name: "Boolean"
                                    }
                                }
                            }
                        }
                    },
                    _t = {
                        serializedName: "ListBlobsHierarchySegmentResponse",
                        xmlName: "EnumerationResults",
                        type: {
                            name: "Composite",
                            className: "ListBlobsHierarchySegmentResponse",
                            modelProperties: {
                                serviceEndpoint: {
                                    serializedName: "ServiceEndpoint",
                                    required: !0,
                                    xmlName: "ServiceEndpoint",
                                    xmlIsAttribute: !0,
                                    type: {
                                        name: "String"
                                    }
                                },
                                containerName: {
                                    serializedName: "ContainerName",
                                    required: !0,
                                    xmlName: "ContainerName",
                                    xmlIsAttribute: !0,
                                    type: {
                                        name: "String"
                                    }
                                },
                                prefix: {
                                    serializedName: "Prefix",
                                    xmlName: "Prefix",
                                    type: {
                                        name: "String"
                                    }
                                },
                                marker: {
                                    serializedName: "Marker",
                                    xmlName: "Marker",
                                    type: {
                                        name: "String"
                                    }
                                },
                                maxPageSize: {
                                    serializedName: "MaxResults",
                                    xmlName: "MaxResults",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                delimiter: {
                                    serializedName: "Delimiter",
                                    xmlName: "Delimiter",
                                    type: {
                                        name: "String"
                                    }
                                },
                                segment: {
                                    serializedName: "Segment",
                                    xmlName: "Blobs",
                                    type: {
                                        name: "Composite",
                                        className: "BlobHierarchyListSegment"
                                    }
                                },
                                continuationToken: {
                                    serializedName: "NextMarker",
                                    xmlName: "NextMarker",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    xt = {
                        serializedName: "BlobHierarchyListSegment",
                        xmlName: "Blobs",
                        type: {
                            name: "Composite",
                            className: "BlobHierarchyListSegment",
                            modelProperties: {
                                blobPrefixes: {
                                    serializedName: "BlobPrefixes",
                                    xmlName: "BlobPrefixes",
                                    xmlElementName: "BlobPrefix",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "BlobPrefix"
                                            }
                                        }
                                    }
                                },
                                blobItems: {
                                    serializedName: "BlobItems",
                                    required: !0,
                                    xmlName: "BlobItems",
                                    xmlElementName: "Blob",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "BlobItemInternal"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    Nt = {
                        serializedName: "BlobPrefix",
                        type: {
                            name: "Composite",
                            className: "BlobPrefix",
                            modelProperties: {
                                name: {
                                    serializedName: "Name",
                                    required: !0,
                                    xmlName: "Name",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Pt = {
                        serializedName: "BlockLookupList",
                        xmlName: "BlockList",
                        type: {
                            name: "Composite",
                            className: "BlockLookupList",
                            modelProperties: {
                                committed: {
                                    serializedName: "Committed",
                                    xmlName: "Committed",
                                    xmlElementName: "Committed",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    }
                                },
                                uncommitted: {
                                    serializedName: "Uncommitted",
                                    xmlName: "Uncommitted",
                                    xmlElementName: "Uncommitted",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    }
                                },
                                latest: {
                                    serializedName: "Latest",
                                    xmlName: "Latest",
                                    xmlElementName: "Latest",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    St = {
                        serializedName: "BlockList",
                        type: {
                            name: "Composite",
                            className: "BlockList",
                            modelProperties: {
                                committedBlocks: {
                                    serializedName: "CommittedBlocks",
                                    xmlName: "CommittedBlocks",
                                    xmlIsWrapped: !0,
                                    xmlElementName: "Block",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "Block"
                                            }
                                        }
                                    }
                                },
                                uncommittedBlocks: {
                                    serializedName: "UncommittedBlocks",
                                    xmlName: "UncommittedBlocks",
                                    xmlIsWrapped: !0,
                                    xmlElementName: "Block",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "Block"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    wt = {
                        serializedName: "Block",
                        type: {
                            name: "Composite",
                            className: "Block",
                            modelProperties: {
                                name: {
                                    serializedName: "Name",
                                    required: !0,
                                    xmlName: "Name",
                                    type: {
                                        name: "String"
                                    }
                                },
                                size: {
                                    serializedName: "Size",
                                    required: !0,
                                    xmlName: "Size",
                                    type: {
                                        name: "Number"
                                    }
                                }
                            }
                        }
                    },
                    Ct = {
                        serializedName: "PageList",
                        type: {
                            name: "Composite",
                            className: "PageList",
                            modelProperties: {
                                pageRange: {
                                    serializedName: "PageRange",
                                    xmlName: "PageRange",
                                    xmlElementName: "PageRange",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "PageRange"
                                            }
                                        }
                                    }
                                },
                                clearRange: {
                                    serializedName: "ClearRange",
                                    xmlName: "ClearRange",
                                    xmlElementName: "ClearRange",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "ClearRange"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    Et = {
                        serializedName: "PageRange",
                        xmlName: "PageRange",
                        type: {
                            name: "Composite",
                            className: "PageRange",
                            modelProperties: {
                                start: {
                                    serializedName: "Start",
                                    required: !0,
                                    xmlName: "Start",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                end: {
                                    serializedName: "End",
                                    required: !0,
                                    xmlName: "End",
                                    type: {
                                        name: "Number"
                                    }
                                }
                            }
                        }
                    },
                    Ot = {
                        serializedName: "ClearRange",
                        xmlName: "ClearRange",
                        type: {
                            name: "Composite",
                            className: "ClearRange",
                            modelProperties: {
                                start: {
                                    serializedName: "Start",
                                    required: !0,
                                    xmlName: "Start",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                end: {
                                    serializedName: "End",
                                    required: !0,
                                    xmlName: "End",
                                    type: {
                                        name: "Number"
                                    }
                                }
                            }
                        }
                    },
                    Tt = {
                        serializedName: "QueryRequest",
                        xmlName: "QueryRequest",
                        type: {
                            name: "Composite",
                            className: "QueryRequest",
                            modelProperties: {
                                queryType: {
                                    serializedName: "QueryType",
                                    required: !0,
                                    xmlName: "QueryType",
                                    type: {
                                        name: "String"
                                    }
                                },
                                expression: {
                                    serializedName: "Expression",
                                    required: !0,
                                    xmlName: "Expression",
                                    type: {
                                        name: "String"
                                    }
                                },
                                inputSerialization: {
                                    serializedName: "InputSerialization",
                                    xmlName: "InputSerialization",
                                    type: {
                                        name: "Composite",
                                        className: "QuerySerialization"
                                    }
                                },
                                outputSerialization: {
                                    serializedName: "OutputSerialization",
                                    xmlName: "OutputSerialization",
                                    type: {
                                        name: "Composite",
                                        className: "QuerySerialization"
                                    }
                                }
                            }
                        }
                    },
                    Rt = {
                        serializedName: "QuerySerialization",
                        type: {
                            name: "Composite",
                            className: "QuerySerialization",
                            modelProperties: {
                                format: {
                                    serializedName: "Format",
                                    xmlName: "Format",
                                    type: {
                                        name: "Composite",
                                        className: "QueryFormat"
                                    }
                                }
                            }
                        }
                    },
                    kt = {
                        serializedName: "QueryFormat",
                        type: {
                            name: "Composite",
                            className: "QueryFormat",
                            modelProperties: {
                                type: {
                                    serializedName: "Type",
                                    required: !0,
                                    xmlName: "Type",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["delimited", "json", "arrow", "parquet"]
                                    }
                                },
                                delimitedTextConfiguration: {
                                    serializedName: "DelimitedTextConfiguration",
                                    xmlName: "DelimitedTextConfiguration",
                                    type: {
                                        name: "Composite",
                                        className: "DelimitedTextConfiguration"
                                    }
                                },
                                jsonTextConfiguration: {
                                    serializedName: "JsonTextConfiguration",
                                    xmlName: "JsonTextConfiguration",
                                    type: {
                                        name: "Composite",
                                        className: "JsonTextConfiguration"
                                    }
                                },
                                arrowConfiguration: {
                                    serializedName: "ArrowConfiguration",
                                    xmlName: "ArrowConfiguration",
                                    type: {
                                        name: "Composite",
                                        className: "ArrowConfiguration"
                                    }
                                },
                                parquetTextConfiguration: {
                                    serializedName: "ParquetTextConfiguration",
                                    xmlName: "ParquetTextConfiguration",
                                    type: {
                                        name: "any"
                                    }
                                }
                            }
                        }
                    },
                    zt = {
                        serializedName: "DelimitedTextConfiguration",
                        xmlName: "DelimitedTextConfiguration",
                        type: {
                            name: "Composite",
                            className: "DelimitedTextConfiguration",
                            modelProperties: {
                                columnSeparator: {
                                    serializedName: "ColumnSeparator",
                                    xmlName: "ColumnSeparator",
                                    type: {
                                        name: "String"
                                    }
                                },
                                fieldQuote: {
                                    serializedName: "FieldQuote",
                                    xmlName: "FieldQuote",
                                    type: {
                                        name: "String"
                                    }
                                },
                                recordSeparator: {
                                    serializedName: "RecordSeparator",
                                    xmlName: "RecordSeparator",
                                    type: {
                                        name: "String"
                                    }
                                },
                                escapeChar: {
                                    serializedName: "EscapeChar",
                                    xmlName: "EscapeChar",
                                    type: {
                                        name: "String"
                                    }
                                },
                                headersPresent: {
                                    serializedName: "HeadersPresent",
                                    xmlName: "HasHeaders",
                                    type: {
                                        name: "Boolean"
                                    }
                                }
                            }
                        }
                    },
                    Lt = {
                        serializedName: "JsonTextConfiguration",
                        xmlName: "JsonTextConfiguration",
                        type: {
                            name: "Composite",
                            className: "JsonTextConfiguration",
                            modelProperties: {
                                recordSeparator: {
                                    serializedName: "RecordSeparator",
                                    xmlName: "RecordSeparator",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    At = {
                        serializedName: "ArrowConfiguration",
                        xmlName: "ArrowConfiguration",
                        type: {
                            name: "Composite",
                            className: "ArrowConfiguration",
                            modelProperties: {
                                schema: {
                                    serializedName: "Schema",
                                    required: !0,
                                    xmlName: "Schema",
                                    xmlIsWrapped: !0,
                                    xmlElementName: "Field",
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "ArrowField"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    Bt = {
                        serializedName: "ArrowField",
                        xmlName: "Field",
                        type: {
                            name: "Composite",
                            className: "ArrowField",
                            modelProperties: {
                                type: {
                                    serializedName: "Type",
                                    required: !0,
                                    xmlName: "Type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                name: {
                                    serializedName: "Name",
                                    xmlName: "Name",
                                    type: {
                                        name: "String"
                                    }
                                },
                                precision: {
                                    serializedName: "Precision",
                                    xmlName: "Precision",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                scale: {
                                    serializedName: "Scale",
                                    xmlName: "Scale",
                                    type: {
                                        name: "Number"
                                    }
                                }
                            }
                        }
                    },
                    It = {
                        serializedName: "Service_setPropertiesHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceSetPropertiesHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Mt = {
                        serializedName: "Service_setPropertiesExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceSetPropertiesExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    qt = {
                        serializedName: "Service_getPropertiesHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceGetPropertiesHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Dt = {
                        serializedName: "Service_getPropertiesExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceGetPropertiesExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    jt = {
                        serializedName: "Service_getStatisticsHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceGetStatisticsHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Ft = {
                        serializedName: "Service_getStatisticsExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceGetStatisticsExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Ht = {
                        serializedName: "Service_listContainersSegmentHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceListContainersSegmentHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Ut = {
                        serializedName: "Service_listContainersSegmentExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceListContainersSegmentExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    $t = {
                        serializedName: "Service_getUserDelegationKeyHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceGetUserDelegationKeyHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Vt = {
                        serializedName: "Service_getUserDelegationKeyExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceGetUserDelegationKeyExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Kt = {
                        serializedName: "Service_getAccountInfoHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceGetAccountInfoHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                skuName: {
                                    serializedName: "x-ms-sku-name",
                                    xmlName: "x-ms-sku-name",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Standard_LRS", "Standard_GRS", "Standard_RAGRS", "Standard_ZRS", "Premium_LRS"]
                                    }
                                },
                                accountKind: {
                                    serializedName: "x-ms-account-kind",
                                    xmlName: "x-ms-account-kind",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Storage", "BlobStorage", "StorageV2", "FileStorage", "BlockBlobStorage"]
                                    }
                                },
                                isHierarchicalNamespaceEnabled: {
                                    serializedName: "x-ms-is-hns-enabled",
                                    xmlName: "x-ms-is-hns-enabled",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Gt = {
                        serializedName: "Service_getAccountInfoExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceGetAccountInfoExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Wt = {
                        serializedName: "Service_submitBatchHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceSubmitBatchHeaders",
                            modelProperties: {
                                contentType: {
                                    serializedName: "content-type",
                                    xmlName: "content-type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Xt = {
                        serializedName: "Service_submitBatchExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceSubmitBatchExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Qt = {
                        serializedName: "Service_filterBlobsHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceFilterBlobsHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Jt = {
                        serializedName: "Service_filterBlobsExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ServiceFilterBlobsExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Yt = {
                        serializedName: "Container_createHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerCreateHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Zt = {
                        serializedName: "Container_createExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerCreateExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    er = {
                        serializedName: "Container_getPropertiesHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerGetPropertiesHeaders",
                            modelProperties: {
                                metadata: {
                                    serializedName: "x-ms-meta",
                                    xmlName: "x-ms-meta",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    },
                                    headerCollectionPrefix: "x-ms-meta-"
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                leaseDuration: {
                                    serializedName: "x-ms-lease-duration",
                                    xmlName: "x-ms-lease-duration",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["infinite", "fixed"]
                                    }
                                },
                                leaseState: {
                                    serializedName: "x-ms-lease-state",
                                    xmlName: "x-ms-lease-state",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["available", "leased", "expired", "breaking", "broken"]
                                    }
                                },
                                leaseStatus: {
                                    serializedName: "x-ms-lease-status",
                                    xmlName: "x-ms-lease-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["locked", "unlocked"]
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                blobPublicAccess: {
                                    serializedName: "x-ms-blob-public-access",
                                    xmlName: "x-ms-blob-public-access",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["container", "blob"]
                                    }
                                },
                                hasImmutabilityPolicy: {
                                    serializedName: "x-ms-has-immutability-policy",
                                    xmlName: "x-ms-has-immutability-policy",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                hasLegalHold: {
                                    serializedName: "x-ms-has-legal-hold",
                                    xmlName: "x-ms-has-legal-hold",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                defaultEncryptionScope: {
                                    serializedName: "x-ms-default-encryption-scope",
                                    xmlName: "x-ms-default-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                denyEncryptionScopeOverride: {
                                    serializedName: "x-ms-deny-encryption-scope-override",
                                    xmlName: "x-ms-deny-encryption-scope-override",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                isImmutableStorageWithVersioningEnabled: {
                                    serializedName: "x-ms-immutable-storage-with-versioning-enabled",
                                    xmlName: "x-ms-immutable-storage-with-versioning-enabled",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    tr = {
                        serializedName: "Container_getPropertiesExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerGetPropertiesExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    rr = {
                        serializedName: "Container_deleteHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerDeleteHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    nr = {
                        serializedName: "Container_deleteExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerDeleteExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ir = {
                        serializedName: "Container_setMetadataHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerSetMetadataHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    or = {
                        serializedName: "Container_setMetadataExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerSetMetadataExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ar = {
                        serializedName: "Container_getAccessPolicyHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerGetAccessPolicyHeaders",
                            modelProperties: {
                                blobPublicAccess: {
                                    serializedName: "x-ms-blob-public-access",
                                    xmlName: "x-ms-blob-public-access",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["container", "blob"]
                                    }
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    sr = {
                        serializedName: "Container_getAccessPolicyExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerGetAccessPolicyExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    lr = {
                        serializedName: "Container_setAccessPolicyHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerSetAccessPolicyHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    cr = {
                        serializedName: "Container_setAccessPolicyExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerSetAccessPolicyExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ur = {
                        serializedName: "Container_restoreHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerRestoreHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    dr = {
                        serializedName: "Container_restoreExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerRestoreExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    pr = {
                        serializedName: "Container_renameHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerRenameHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    mr = {
                        serializedName: "Container_renameExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerRenameExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    fr = {
                        serializedName: "Container_submitBatchHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerSubmitBatchHeaders",
                            modelProperties: {
                                contentType: {
                                    serializedName: "content-type",
                                    xmlName: "content-type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    hr = {
                        serializedName: "Container_submitBatchExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerSubmitBatchExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    yr = {
                        serializedName: "Container_acquireLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerAcquireLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                leaseId: {
                                    serializedName: "x-ms-lease-id",
                                    xmlName: "x-ms-lease-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    gr = {
                        serializedName: "Container_acquireLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerAcquireLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    br = {
                        serializedName: "Container_releaseLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerReleaseLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    vr = {
                        serializedName: "Container_releaseLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerReleaseLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    _r = {
                        serializedName: "Container_renewLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerRenewLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                leaseId: {
                                    serializedName: "x-ms-lease-id",
                                    xmlName: "x-ms-lease-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    xr = {
                        serializedName: "Container_renewLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerRenewLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Nr = {
                        serializedName: "Container_breakLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerBreakLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                leaseTime: {
                                    serializedName: "x-ms-lease-time",
                                    xmlName: "x-ms-lease-time",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    Pr = {
                        serializedName: "Container_breakLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerBreakLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Sr = {
                        serializedName: "Container_changeLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerChangeLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                leaseId: {
                                    serializedName: "x-ms-lease-id",
                                    xmlName: "x-ms-lease-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    wr = {
                        serializedName: "Container_changeLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerChangeLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Cr = {
                        serializedName: "Container_listBlobFlatSegmentHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerListBlobFlatSegmentHeaders",
                            modelProperties: {
                                contentType: {
                                    serializedName: "content-type",
                                    xmlName: "content-type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Er = {
                        serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerListBlobFlatSegmentExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Or = {
                        serializedName: "Container_listBlobHierarchySegmentHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerListBlobHierarchySegmentHeaders",
                            modelProperties: {
                                contentType: {
                                    serializedName: "content-type",
                                    xmlName: "content-type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Tr = {
                        serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerListBlobHierarchySegmentExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Rr = {
                        serializedName: "Container_getAccountInfoHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerGetAccountInfoHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                skuName: {
                                    serializedName: "x-ms-sku-name",
                                    xmlName: "x-ms-sku-name",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Standard_LRS", "Standard_GRS", "Standard_RAGRS", "Standard_ZRS", "Premium_LRS"]
                                    }
                                },
                                accountKind: {
                                    serializedName: "x-ms-account-kind",
                                    xmlName: "x-ms-account-kind",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Storage", "BlobStorage", "StorageV2", "FileStorage", "BlockBlobStorage"]
                                    }
                                }
                            }
                        }
                    },
                    kr = {
                        serializedName: "Container_getAccountInfoExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "ContainerGetAccountInfoExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    zr = {
                        serializedName: "Blob_downloadHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobDownloadHeaders",
                            modelProperties: {
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                metadata: {
                                    serializedName: "x-ms-meta",
                                    xmlName: "x-ms-meta",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    },
                                    headerCollectionPrefix: "x-ms-meta-"
                                },
                                objectReplicationPolicyId: {
                                    serializedName: "x-ms-or-policy-id",
                                    xmlName: "x-ms-or-policy-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                objectReplicationRules: {
                                    serializedName: "x-ms-or",
                                    xmlName: "x-ms-or",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    },
                                    headerCollectionPrefix: "x-ms-or-"
                                },
                                contentLength: {
                                    serializedName: "content-length",
                                    xmlName: "content-length",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                contentType: {
                                    serializedName: "content-type",
                                    xmlName: "content-type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentRange: {
                                    serializedName: "content-range",
                                    xmlName: "content-range",
                                    type: {
                                        name: "String"
                                    }
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                contentEncoding: {
                                    serializedName: "content-encoding",
                                    xmlName: "content-encoding",
                                    type: {
                                        name: "String"
                                    }
                                },
                                cacheControl: {
                                    serializedName: "cache-control",
                                    xmlName: "cache-control",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentDisposition: {
                                    serializedName: "content-disposition",
                                    xmlName: "content-disposition",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentLanguage: {
                                    serializedName: "content-language",
                                    xmlName: "content-language",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                blobType: {
                                    serializedName: "x-ms-blob-type",
                                    xmlName: "x-ms-blob-type",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
                                    }
                                },
                                copyCompletedOn: {
                                    serializedName: "x-ms-copy-completion-time",
                                    xmlName: "x-ms-copy-completion-time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                copyStatusDescription: {
                                    serializedName: "x-ms-copy-status-description",
                                    xmlName: "x-ms-copy-status-description",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyId: {
                                    serializedName: "x-ms-copy-id",
                                    xmlName: "x-ms-copy-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyProgress: {
                                    serializedName: "x-ms-copy-progress",
                                    xmlName: "x-ms-copy-progress",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copySource: {
                                    serializedName: "x-ms-copy-source",
                                    xmlName: "x-ms-copy-source",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyStatus: {
                                    serializedName: "x-ms-copy-status",
                                    xmlName: "x-ms-copy-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["pending", "success", "aborted", "failed"]
                                    }
                                },
                                leaseDuration: {
                                    serializedName: "x-ms-lease-duration",
                                    xmlName: "x-ms-lease-duration",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["infinite", "fixed"]
                                    }
                                },
                                leaseState: {
                                    serializedName: "x-ms-lease-state",
                                    xmlName: "x-ms-lease-state",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["available", "leased", "expired", "breaking", "broken"]
                                    }
                                },
                                leaseStatus: {
                                    serializedName: "x-ms-lease-status",
                                    xmlName: "x-ms-lease-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["locked", "unlocked"]
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                isCurrentVersion: {
                                    serializedName: "x-ms-is-current-version",
                                    xmlName: "x-ms-is-current-version",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                acceptRanges: {
                                    serializedName: "accept-ranges",
                                    xmlName: "accept-ranges",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                blobCommittedBlockCount: {
                                    serializedName: "x-ms-blob-committed-block-count",
                                    xmlName: "x-ms-blob-committed-block-count",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-server-encrypted",
                                    xmlName: "x-ms-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobContentMD5: {
                                    serializedName: "x-ms-blob-content-md5",
                                    xmlName: "x-ms-blob-content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                tagCount: {
                                    serializedName: "x-ms-tag-count",
                                    xmlName: "x-ms-tag-count",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                isSealed: {
                                    serializedName: "x-ms-blob-sealed",
                                    xmlName: "x-ms-blob-sealed",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                lastAccessed: {
                                    serializedName: "x-ms-last-access-time",
                                    xmlName: "x-ms-last-access-time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                immutabilityPolicyExpiresOn: {
                                    serializedName: "x-ms-immutability-policy-until-date",
                                    xmlName: "x-ms-immutability-policy-until-date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                immutabilityPolicyMode: {
                                    serializedName: "x-ms-immutability-policy-mode",
                                    xmlName: "x-ms-immutability-policy-mode",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Mutable", "Unlocked", "Locked"]
                                    }
                                },
                                legalHold: {
                                    serializedName: "x-ms-legal-hold",
                                    xmlName: "x-ms-legal-hold",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                }
                            }
                        }
                    },
                    Lr = {
                        serializedName: "Blob_downloadExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobDownloadExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Ar = {
                        serializedName: "Blob_getPropertiesHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobGetPropertiesHeaders",
                            modelProperties: {
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                createdOn: {
                                    serializedName: "x-ms-creation-time",
                                    xmlName: "x-ms-creation-time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                metadata: {
                                    serializedName: "x-ms-meta",
                                    xmlName: "x-ms-meta",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    },
                                    headerCollectionPrefix: "x-ms-meta-"
                                },
                                objectReplicationPolicyId: {
                                    serializedName: "x-ms-or-policy-id",
                                    xmlName: "x-ms-or-policy-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                objectReplicationRules: {
                                    serializedName: "x-ms-or",
                                    xmlName: "x-ms-or",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    },
                                    headerCollectionPrefix: "x-ms-or-"
                                },
                                blobType: {
                                    serializedName: "x-ms-blob-type",
                                    xmlName: "x-ms-blob-type",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
                                    }
                                },
                                copyCompletedOn: {
                                    serializedName: "x-ms-copy-completion-time",
                                    xmlName: "x-ms-copy-completion-time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                copyStatusDescription: {
                                    serializedName: "x-ms-copy-status-description",
                                    xmlName: "x-ms-copy-status-description",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyId: {
                                    serializedName: "x-ms-copy-id",
                                    xmlName: "x-ms-copy-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyProgress: {
                                    serializedName: "x-ms-copy-progress",
                                    xmlName: "x-ms-copy-progress",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copySource: {
                                    serializedName: "x-ms-copy-source",
                                    xmlName: "x-ms-copy-source",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyStatus: {
                                    serializedName: "x-ms-copy-status",
                                    xmlName: "x-ms-copy-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["pending", "success", "aborted", "failed"]
                                    }
                                },
                                isIncrementalCopy: {
                                    serializedName: "x-ms-incremental-copy",
                                    xmlName: "x-ms-incremental-copy",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                destinationSnapshot: {
                                    serializedName: "x-ms-copy-destination-snapshot",
                                    xmlName: "x-ms-copy-destination-snapshot",
                                    type: {
                                        name: "String"
                                    }
                                },
                                leaseDuration: {
                                    serializedName: "x-ms-lease-duration",
                                    xmlName: "x-ms-lease-duration",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["infinite", "fixed"]
                                    }
                                },
                                leaseState: {
                                    serializedName: "x-ms-lease-state",
                                    xmlName: "x-ms-lease-state",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["available", "leased", "expired", "breaking", "broken"]
                                    }
                                },
                                leaseStatus: {
                                    serializedName: "x-ms-lease-status",
                                    xmlName: "x-ms-lease-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["locked", "unlocked"]
                                    }
                                },
                                contentLength: {
                                    serializedName: "content-length",
                                    xmlName: "content-length",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                contentType: {
                                    serializedName: "content-type",
                                    xmlName: "content-type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                contentEncoding: {
                                    serializedName: "content-encoding",
                                    xmlName: "content-encoding",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentDisposition: {
                                    serializedName: "content-disposition",
                                    xmlName: "content-disposition",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentLanguage: {
                                    serializedName: "content-language",
                                    xmlName: "content-language",
                                    type: {
                                        name: "String"
                                    }
                                },
                                cacheControl: {
                                    serializedName: "cache-control",
                                    xmlName: "cache-control",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                acceptRanges: {
                                    serializedName: "accept-ranges",
                                    xmlName: "accept-ranges",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobCommittedBlockCount: {
                                    serializedName: "x-ms-blob-committed-block-count",
                                    xmlName: "x-ms-blob-committed-block-count",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-server-encrypted",
                                    xmlName: "x-ms-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                accessTier: {
                                    serializedName: "x-ms-access-tier",
                                    xmlName: "x-ms-access-tier",
                                    type: {
                                        name: "String"
                                    }
                                },
                                accessTierInferred: {
                                    serializedName: "x-ms-access-tier-inferred",
                                    xmlName: "x-ms-access-tier-inferred",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                archiveStatus: {
                                    serializedName: "x-ms-archive-status",
                                    xmlName: "x-ms-archive-status",
                                    type: {
                                        name: "String"
                                    }
                                },
                                accessTierChangedOn: {
                                    serializedName: "x-ms-access-tier-change-time",
                                    xmlName: "x-ms-access-tier-change-time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                isCurrentVersion: {
                                    serializedName: "x-ms-is-current-version",
                                    xmlName: "x-ms-is-current-version",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                tagCount: {
                                    serializedName: "x-ms-tag-count",
                                    xmlName: "x-ms-tag-count",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                expiresOn: {
                                    serializedName: "x-ms-expiry-time",
                                    xmlName: "x-ms-expiry-time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isSealed: {
                                    serializedName: "x-ms-blob-sealed",
                                    xmlName: "x-ms-blob-sealed",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                rehydratePriority: {
                                    serializedName: "x-ms-rehydrate-priority",
                                    xmlName: "x-ms-rehydrate-priority",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["High", "Standard"]
                                    }
                                },
                                lastAccessed: {
                                    serializedName: "x-ms-last-access-time",
                                    xmlName: "x-ms-last-access-time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                immutabilityPolicyExpiresOn: {
                                    serializedName: "x-ms-immutability-policy-until-date",
                                    xmlName: "x-ms-immutability-policy-until-date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                immutabilityPolicyMode: {
                                    serializedName: "x-ms-immutability-policy-mode",
                                    xmlName: "x-ms-immutability-policy-mode",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Mutable", "Unlocked", "Locked"]
                                    }
                                },
                                legalHold: {
                                    serializedName: "x-ms-legal-hold",
                                    xmlName: "x-ms-legal-hold",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Br = {
                        serializedName: "Blob_getPropertiesExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobGetPropertiesExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Ir = {
                        serializedName: "Blob_deleteHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobDeleteHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Mr = {
                        serializedName: "Blob_deleteExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobDeleteExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    qr = {
                        serializedName: "Blob_undeleteHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobUndeleteHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Dr = {
                        serializedName: "Blob_undeleteExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobUndeleteExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    jr = {
                        serializedName: "Blob_setExpiryHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetExpiryHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    Fr = {
                        serializedName: "Blob_setExpiryExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetExpiryExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Hr = {
                        serializedName: "Blob_setHttpHeadersHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetHttpHeadersHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Ur = {
                        serializedName: "Blob_setHttpHeadersExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetHttpHeadersExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    $r = {
                        serializedName: "Blob_setImmutabilityPolicyHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetImmutabilityPolicyHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                immutabilityPolicyExpiry: {
                                    serializedName: "x-ms-immutability-policy-until-date",
                                    xmlName: "x-ms-immutability-policy-until-date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                immutabilityPolicyMode: {
                                    serializedName: "x-ms-immutability-policy-mode",
                                    xmlName: "x-ms-immutability-policy-mode",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Mutable", "Unlocked", "Locked"]
                                    }
                                }
                            }
                        }
                    },
                    Vr = {
                        serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetImmutabilityPolicyExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Kr = {
                        serializedName: "Blob_deleteImmutabilityPolicyHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobDeleteImmutabilityPolicyHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    Gr = {
                        serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Wr = {
                        serializedName: "Blob_setLegalHoldHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetLegalHoldHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                legalHold: {
                                    serializedName: "x-ms-legal-hold",
                                    xmlName: "x-ms-legal-hold",
                                    type: {
                                        name: "Boolean"
                                    }
                                }
                            }
                        }
                    },
                    Xr = {
                        serializedName: "Blob_setLegalHoldExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetLegalHoldExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Qr = {
                        serializedName: "Blob_setMetadataHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetMetadataHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Jr = {
                        serializedName: "Blob_setMetadataExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetMetadataExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Yr = {
                        serializedName: "Blob_acquireLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobAcquireLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                leaseId: {
                                    serializedName: "x-ms-lease-id",
                                    xmlName: "x-ms-lease-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    Zr = {
                        serializedName: "Blob_acquireLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobAcquireLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    en = {
                        serializedName: "Blob_releaseLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobReleaseLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    tn = {
                        serializedName: "Blob_releaseLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobReleaseLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    rn = {
                        serializedName: "Blob_renewLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobRenewLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                leaseId: {
                                    serializedName: "x-ms-lease-id",
                                    xmlName: "x-ms-lease-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    nn = {
                        serializedName: "Blob_renewLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobRenewLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    an = {
                        serializedName: "Blob_changeLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobChangeLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                leaseId: {
                                    serializedName: "x-ms-lease-id",
                                    xmlName: "x-ms-lease-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    sn = {
                        serializedName: "Blob_changeLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobChangeLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ln = {
                        serializedName: "Blob_breakLeaseHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobBreakLeaseHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                leaseTime: {
                                    serializedName: "x-ms-lease-time",
                                    xmlName: "x-ms-lease-time",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                }
                            }
                        }
                    },
                    cn = {
                        serializedName: "Blob_breakLeaseExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobBreakLeaseExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    un = {
                        serializedName: "Blob_createSnapshotHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobCreateSnapshotHeaders",
                            modelProperties: {
                                snapshot: {
                                    serializedName: "x-ms-snapshot",
                                    xmlName: "x-ms-snapshot",
                                    type: {
                                        name: "String"
                                    }
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    dn = {
                        serializedName: "Blob_createSnapshotExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobCreateSnapshotExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    pn = {
                        serializedName: "Blob_startCopyFromURLHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobStartCopyFromURLHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                copyId: {
                                    serializedName: "x-ms-copy-id",
                                    xmlName: "x-ms-copy-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyStatus: {
                                    serializedName: "x-ms-copy-status",
                                    xmlName: "x-ms-copy-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["pending", "success", "aborted", "failed"]
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    mn = {
                        serializedName: "Blob_startCopyFromURLExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobStartCopyFromURLExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    hn = {
                        serializedName: "Blob_copyFromURLHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobCopyFromURLHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                copyId: {
                                    serializedName: "x-ms-copy-id",
                                    xmlName: "x-ms-copy-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyStatus: {
                                    defaultValue: "success",
                                    isConstant: !0,
                                    serializedName: "x-ms-copy-status",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    yn = {
                        serializedName: "Blob_copyFromURLExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobCopyFromURLExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    gn = {
                        serializedName: "Blob_abortCopyFromURLHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobAbortCopyFromURLHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    bn = {
                        serializedName: "Blob_abortCopyFromURLExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobAbortCopyFromURLExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    vn = {
                        serializedName: "Blob_setTierHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetTierHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    _n = {
                        serializedName: "Blob_setTierExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetTierExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    xn = {
                        serializedName: "Blob_getAccountInfoHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobGetAccountInfoHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                skuName: {
                                    serializedName: "x-ms-sku-name",
                                    xmlName: "x-ms-sku-name",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Standard_LRS", "Standard_GRS", "Standard_RAGRS", "Standard_ZRS", "Premium_LRS"]
                                    }
                                },
                                accountKind: {
                                    serializedName: "x-ms-account-kind",
                                    xmlName: "x-ms-account-kind",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["Storage", "BlobStorage", "StorageV2", "FileStorage", "BlockBlobStorage"]
                                    }
                                }
                            }
                        }
                    },
                    Nn = {
                        serializedName: "Blob_getAccountInfoExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobGetAccountInfoExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Pn = {
                        serializedName: "Blob_queryHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobQueryHeaders",
                            modelProperties: {
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                metadata: {
                                    serializedName: "x-ms-meta",
                                    xmlName: "x-ms-meta",
                                    type: {
                                        name: "Dictionary",
                                        value: {
                                            type: {
                                                name: "String"
                                            }
                                        }
                                    }
                                },
                                contentLength: {
                                    serializedName: "content-length",
                                    xmlName: "content-length",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                contentType: {
                                    serializedName: "content-type",
                                    xmlName: "content-type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentRange: {
                                    serializedName: "content-range",
                                    xmlName: "content-range",
                                    type: {
                                        name: "String"
                                    }
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                contentEncoding: {
                                    serializedName: "content-encoding",
                                    xmlName: "content-encoding",
                                    type: {
                                        name: "String"
                                    }
                                },
                                cacheControl: {
                                    serializedName: "cache-control",
                                    xmlName: "cache-control",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentDisposition: {
                                    serializedName: "content-disposition",
                                    xmlName: "content-disposition",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentLanguage: {
                                    serializedName: "content-language",
                                    xmlName: "content-language",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                blobType: {
                                    serializedName: "x-ms-blob-type",
                                    xmlName: "x-ms-blob-type",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
                                    }
                                },
                                copyCompletionTime: {
                                    serializedName: "x-ms-copy-completion-time",
                                    xmlName: "x-ms-copy-completion-time",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                copyStatusDescription: {
                                    serializedName: "x-ms-copy-status-description",
                                    xmlName: "x-ms-copy-status-description",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyId: {
                                    serializedName: "x-ms-copy-id",
                                    xmlName: "x-ms-copy-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyProgress: {
                                    serializedName: "x-ms-copy-progress",
                                    xmlName: "x-ms-copy-progress",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copySource: {
                                    serializedName: "x-ms-copy-source",
                                    xmlName: "x-ms-copy-source",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyStatus: {
                                    serializedName: "x-ms-copy-status",
                                    xmlName: "x-ms-copy-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["pending", "success", "aborted", "failed"]
                                    }
                                },
                                leaseDuration: {
                                    serializedName: "x-ms-lease-duration",
                                    xmlName: "x-ms-lease-duration",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["infinite", "fixed"]
                                    }
                                },
                                leaseState: {
                                    serializedName: "x-ms-lease-state",
                                    xmlName: "x-ms-lease-state",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["available", "leased", "expired", "breaking", "broken"]
                                    }
                                },
                                leaseStatus: {
                                    serializedName: "x-ms-lease-status",
                                    xmlName: "x-ms-lease-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["locked", "unlocked"]
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                acceptRanges: {
                                    serializedName: "accept-ranges",
                                    xmlName: "accept-ranges",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                blobCommittedBlockCount: {
                                    serializedName: "x-ms-blob-committed-block-count",
                                    xmlName: "x-ms-blob-committed-block-count",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-server-encrypted",
                                    xmlName: "x-ms-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobContentMD5: {
                                    serializedName: "x-ms-blob-content-md5",
                                    xmlName: "x-ms-blob-content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                }
                            }
                        }
                    },
                    Sn = {
                        serializedName: "Blob_queryExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobQueryExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    wn = {
                        serializedName: "Blob_getTagsHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobGetTagsHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Cn = {
                        serializedName: "Blob_getTagsExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobGetTagsExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    En = {
                        serializedName: "Blob_setTagsHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetTagsHeaders",
                            modelProperties: {
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    On = {
                        serializedName: "Blob_setTagsExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlobSetTagsExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Tn = {
                        serializedName: "PageBlob_createHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobCreateHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Rn = {
                        serializedName: "PageBlob_createExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobCreateExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    kn = {
                        serializedName: "PageBlob_uploadPagesHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobUploadPagesHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    zn = {
                        serializedName: "PageBlob_uploadPagesExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobUploadPagesExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Ln = {
                        serializedName: "PageBlob_clearPagesHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobClearPagesHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    An = {
                        serializedName: "PageBlob_clearPagesExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobClearPagesExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Bn = {
                        serializedName: "PageBlob_uploadPagesFromURLHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobUploadPagesFromURLHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    In = {
                        serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobUploadPagesFromURLExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Mn = {
                        serializedName: "PageBlob_getPageRangesHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobGetPageRangesHeaders",
                            modelProperties: {
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobContentLength: {
                                    serializedName: "x-ms-blob-content-length",
                                    xmlName: "x-ms-blob-content-length",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    qn = {
                        serializedName: "PageBlob_getPageRangesExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobGetPageRangesExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Dn = {
                        serializedName: "PageBlob_getPageRangesDiffHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobGetPageRangesDiffHeaders",
                            modelProperties: {
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobContentLength: {
                                    serializedName: "x-ms-blob-content-length",
                                    xmlName: "x-ms-blob-content-length",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    jn = {
                        serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobGetPageRangesDiffExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Fn = {
                        serializedName: "PageBlob_resizeHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobResizeHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Hn = {
                        serializedName: "PageBlob_resizeExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobResizeExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Un = {
                        serializedName: "PageBlob_updateSequenceNumberHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobUpdateSequenceNumberHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                blobSequenceNumber: {
                                    serializedName: "x-ms-blob-sequence-number",
                                    xmlName: "x-ms-blob-sequence-number",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    $n = {
                        serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobUpdateSequenceNumberExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Vn = {
                        serializedName: "PageBlob_copyIncrementalHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobCopyIncrementalHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                copyId: {
                                    serializedName: "x-ms-copy-id",
                                    xmlName: "x-ms-copy-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                copyStatus: {
                                    serializedName: "x-ms-copy-status",
                                    xmlName: "x-ms-copy-status",
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["pending", "success", "aborted", "failed"]
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Kn = {
                        serializedName: "PageBlob_copyIncrementalExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "PageBlobCopyIncrementalExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Gn = {
                        serializedName: "AppendBlob_createHeaders",
                        type: {
                            name: "Composite",
                            className: "AppendBlobCreateHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Wn = {
                        serializedName: "AppendBlob_createExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "AppendBlobCreateExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Xn = {
                        serializedName: "AppendBlob_appendBlockHeaders",
                        type: {
                            name: "Composite",
                            className: "AppendBlobAppendBlockHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                blobAppendOffset: {
                                    serializedName: "x-ms-blob-append-offset",
                                    xmlName: "x-ms-blob-append-offset",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobCommittedBlockCount: {
                                    serializedName: "x-ms-blob-committed-block-count",
                                    xmlName: "x-ms-blob-committed-block-count",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Qn = {
                        serializedName: "AppendBlob_appendBlockExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "AppendBlobAppendBlockExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Jn = {
                        serializedName: "AppendBlob_appendBlockFromUrlHeaders",
                        type: {
                            name: "Composite",
                            className: "AppendBlobAppendBlockFromUrlHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                blobAppendOffset: {
                                    serializedName: "x-ms-blob-append-offset",
                                    xmlName: "x-ms-blob-append-offset",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobCommittedBlockCount: {
                                    serializedName: "x-ms-blob-committed-block-count",
                                    xmlName: "x-ms-blob-committed-block-count",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Yn = {
                        serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    Zn = {
                        serializedName: "AppendBlob_sealHeaders",
                        type: {
                            name: "Composite",
                            className: "AppendBlobSealHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isSealed: {
                                    serializedName: "x-ms-blob-sealed",
                                    xmlName: "x-ms-blob-sealed",
                                    type: {
                                        name: "Boolean"
                                    }
                                }
                            }
                        }
                    },
                    ei = {
                        serializedName: "AppendBlob_sealExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "AppendBlobSealExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ti = {
                        serializedName: "BlockBlob_uploadHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobUploadHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ri = {
                        serializedName: "BlockBlob_uploadExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobUploadExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ni = {
                        serializedName: "BlockBlob_putBlobFromUrlHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobPutBlobFromUrlHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ii = {
                        serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobPutBlobFromUrlExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    oi = {
                        serializedName: "BlockBlob_stageBlockHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobStageBlockHeaders",
                            modelProperties: {
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ai = {
                        serializedName: "BlockBlob_stageBlockExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobStageBlockExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    si = {
                        serializedName: "BlockBlob_stageBlockFromURLHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobStageBlockFromURLHeaders",
                            modelProperties: {
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    li = {
                        serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobStageBlockFromURLExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ci = {
                        serializedName: "BlockBlob_commitBlockListHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobCommitBlockListHeaders",
                            modelProperties: {
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                contentMD5: {
                                    serializedName: "content-md5",
                                    xmlName: "content-md5",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                xMsContentCrc64: {
                                    serializedName: "x-ms-content-crc64",
                                    xmlName: "x-ms-content-crc64",
                                    type: {
                                        name: "ByteArray"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                versionId: {
                                    serializedName: "x-ms-version-id",
                                    xmlName: "x-ms-version-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                isServerEncrypted: {
                                    serializedName: "x-ms-request-server-encrypted",
                                    xmlName: "x-ms-request-server-encrypted",
                                    type: {
                                        name: "Boolean"
                                    }
                                },
                                encryptionKeySha256: {
                                    serializedName: "x-ms-encryption-key-sha256",
                                    xmlName: "x-ms-encryption-key-sha256",
                                    type: {
                                        name: "String"
                                    }
                                },
                                encryptionScope: {
                                    serializedName: "x-ms-encryption-scope",
                                    xmlName: "x-ms-encryption-scope",
                                    type: {
                                        name: "String"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    ui = {
                        serializedName: "BlockBlob_commitBlockListExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobCommitBlockListExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    di = {
                        serializedName: "BlockBlob_getBlockListHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobGetBlockListHeaders",
                            modelProperties: {
                                lastModified: {
                                    serializedName: "last-modified",
                                    xmlName: "last-modified",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                etag: {
                                    serializedName: "etag",
                                    xmlName: "etag",
                                    type: {
                                        name: "String"
                                    }
                                },
                                contentType: {
                                    serializedName: "content-type",
                                    xmlName: "content-type",
                                    type: {
                                        name: "String"
                                    }
                                },
                                blobContentLength: {
                                    serializedName: "x-ms-blob-content-length",
                                    xmlName: "x-ms-blob-content-length",
                                    type: {
                                        name: "Number"
                                    }
                                },
                                clientRequestId: {
                                    serializedName: "x-ms-client-request-id",
                                    xmlName: "x-ms-client-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                requestId: {
                                    serializedName: "x-ms-request-id",
                                    xmlName: "x-ms-request-id",
                                    type: {
                                        name: "String"
                                    }
                                },
                                version: {
                                    serializedName: "x-ms-version",
                                    xmlName: "x-ms-version",
                                    type: {
                                        name: "String"
                                    }
                                },
                                date: {
                                    serializedName: "date",
                                    xmlName: "date",
                                    type: {
                                        name: "DateTimeRfc1123"
                                    }
                                },
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    },
                    pi = {
                        serializedName: "BlockBlob_getBlockListExceptionHeaders",
                        type: {
                            name: "Composite",
                            className: "BlockBlobGetBlockListExceptionHeaders",
                            modelProperties: {
                                errorCode: {
                                    serializedName: "x-ms-error-code",
                                    xmlName: "x-ms-error-code",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    };
                var mi;
                ! function(t) {
                    t.Csv = ",", t.Ssv = " ", t.Tsv = "\t", t.Pipes = "|", t.Multi = "Multi"
                }(mi || (mi = {}));
                const fi = {
                        parameterPath: ["options", "contentType"],
                        mapper: {
                            defaultValue: "application/xml",
                            isConstant: !0,
                            serializedName: "Content-Type",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    hi = {
                        parameterPath: "accept",
                        mapper: {
                            defaultValue: "application/xml",
                            isConstant: !0,
                            serializedName: "Accept",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    yi = {
                        parameterPath: "url",
                        mapper: {
                            serializedName: "url",
                            required: !0,
                            xmlName: "url",
                            type: {
                                name: "String"
                            }
                        },
                        skipEncoding: !0
                    },
                    gi = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "properties",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    bi = {
                        parameterPath: ["options", "timeoutInSeconds"],
                        mapper: {
                            constraints: {
                                InclusiveMinimum: 0
                            },
                            serializedName: "timeout",
                            xmlName: "timeout",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    vi = {
                        parameterPath: "version",
                        mapper: {
                            defaultValue: "2020-10-02",
                            isConstant: !0,
                            serializedName: "x-ms-version",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    _i = {
                        parameterPath: ["options", "requestId"],
                        mapper: {
                            serializedName: "x-ms-client-request-id",
                            xmlName: "x-ms-client-request-id",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    xi = {
                        parameterPath: "accept",
                        mapper: {
                            defaultValue: "application/xml",
                            isConstant: !0,
                            serializedName: "Accept",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Ni = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "list",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Pi = {
                        parameterPath: ["options", "prefix"],
                        mapper: {
                            serializedName: "prefix",
                            xmlName: "prefix",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Si = {
                        parameterPath: ["options", "marker"],
                        mapper: {
                            serializedName: "marker",
                            xmlName: "marker",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    wi = {
                        parameterPath: ["options", "maxPageSize"],
                        mapper: {
                            constraints: {
                                InclusiveMinimum: 1
                            },
                            serializedName: "maxresults",
                            xmlName: "maxresults",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Ci = (mi.Csv, {
                        parameterPath: "restype",
                        mapper: {
                            defaultValue: "account",
                            isConstant: !0,
                            serializedName: "restype",
                            type: {
                                name: "String"
                            }
                        }
                    }),
                    Ei = {
                        parameterPath: "contentLength",
                        mapper: {
                            serializedName: "Content-Length",
                            required: !0,
                            xmlName: "Content-Length",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Oi = {
                        parameterPath: "restype",
                        mapper: {
                            defaultValue: "container",
                            isConstant: !0,
                            serializedName: "restype",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Ti = {
                        parameterPath: ["options", "metadata"],
                        mapper: {
                            serializedName: "x-ms-meta",
                            xmlName: "x-ms-meta",
                            type: {
                                name: "Dictionary",
                                value: {
                                    type: {
                                        name: "String"
                                    }
                                }
                            },
                            headerCollectionPrefix: "x-ms-meta-"
                        }
                    },
                    Ri = {
                        parameterPath: ["options", "access"],
                        mapper: {
                            serializedName: "x-ms-blob-public-access",
                            xmlName: "x-ms-blob-public-access",
                            type: {
                                name: "Enum",
                                allowedValues: ["container", "blob"]
                            }
                        }
                    },
                    ki = {
                        parameterPath: ["options", "leaseAccessConditions", "leaseId"],
                        mapper: {
                            serializedName: "x-ms-lease-id",
                            xmlName: "x-ms-lease-id",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    zi = {
                        parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
                        mapper: {
                            serializedName: "If-Modified-Since",
                            xmlName: "If-Modified-Since",
                            type: {
                                name: "DateTimeRfc1123"
                            }
                        }
                    },
                    Li = {
                        parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
                        mapper: {
                            serializedName: "If-Unmodified-Since",
                            xmlName: "If-Unmodified-Since",
                            type: {
                                name: "DateTimeRfc1123"
                            }
                        }
                    },
                    Ai = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "metadata",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Bi = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "acl",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Ii = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "undelete",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Mi = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "lease",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    qi = {
                        parameterPath: "action",
                        mapper: {
                            defaultValue: "acquire",
                            isConstant: !0,
                            serializedName: "x-ms-lease-action",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Di = {
                        parameterPath: ["options", "duration"],
                        mapper: {
                            serializedName: "x-ms-lease-duration",
                            xmlName: "x-ms-lease-duration",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    ji = {
                        parameterPath: ["options", "proposedLeaseId"],
                        mapper: {
                            serializedName: "x-ms-proposed-lease-id",
                            xmlName: "x-ms-proposed-lease-id",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Fi = {
                        parameterPath: "action",
                        mapper: {
                            defaultValue: "release",
                            isConstant: !0,
                            serializedName: "x-ms-lease-action",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Hi = {
                        parameterPath: "leaseId",
                        mapper: {
                            serializedName: "x-ms-lease-id",
                            required: !0,
                            xmlName: "x-ms-lease-id",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Ui = {
                        parameterPath: "action",
                        mapper: {
                            defaultValue: "renew",
                            isConstant: !0,
                            serializedName: "x-ms-lease-action",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    $i = {
                        parameterPath: "action",
                        mapper: {
                            defaultValue: "break",
                            isConstant: !0,
                            serializedName: "x-ms-lease-action",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Vi = {
                        parameterPath: ["options", "breakPeriod"],
                        mapper: {
                            serializedName: "x-ms-lease-break-period",
                            xmlName: "x-ms-lease-break-period",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Ki = {
                        parameterPath: "action",
                        mapper: {
                            defaultValue: "change",
                            isConstant: !0,
                            serializedName: "x-ms-lease-action",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Gi = {
                        parameterPath: "proposedLeaseId",
                        mapper: {
                            serializedName: "x-ms-proposed-lease-id",
                            required: !0,
                            xmlName: "x-ms-proposed-lease-id",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Wi = {
                        parameterPath: ["options", "include"],
                        mapper: {
                            serializedName: "include",
                            xmlName: "include",
                            xmlElementName: "ListBlobsIncludeItem",
                            type: {
                                name: "Sequence",
                                element: {
                                    type: {
                                        name: "Enum",
                                        allowedValues: ["copy", "deleted", "metadata", "snapshots", "uncommittedblobs", "versions", "tags", "immutabilitypolicy", "legalhold", "deletedwithversions"]
                                    }
                                }
                            }
                        },
                        collectionFormat: mi.Csv
                    },
                    Xi = {
                        parameterPath: ["options", "snapshot"],
                        mapper: {
                            serializedName: "snapshot",
                            xmlName: "snapshot",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Qi = {
                        parameterPath: ["options", "versionId"],
                        mapper: {
                            serializedName: "versionid",
                            xmlName: "versionid",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Ji = {
                        parameterPath: ["options", "range"],
                        mapper: {
                            serializedName: "x-ms-range",
                            xmlName: "x-ms-range",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Yi = {
                        parameterPath: ["options", "cpkInfo", "encryptionKey"],
                        mapper: {
                            serializedName: "x-ms-encryption-key",
                            xmlName: "x-ms-encryption-key",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Zi = {
                        parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
                        mapper: {
                            serializedName: "x-ms-encryption-key-sha256",
                            xmlName: "x-ms-encryption-key-sha256",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    eo = {
                        parameterPath: ["options", "encryptionAlgorithm"],
                        mapper: {
                            defaultValue: "AES256",
                            isConstant: !0,
                            serializedName: "x-ms-encryption-algorithm",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    to = {
                        parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
                        mapper: {
                            serializedName: "If-Match",
                            xmlName: "If-Match",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    ro = {
                        parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
                        mapper: {
                            serializedName: "If-None-Match",
                            xmlName: "If-None-Match",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    no = {
                        parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
                        mapper: {
                            serializedName: "x-ms-if-tags",
                            xmlName: "x-ms-if-tags",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    io = {
                        parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
                        mapper: {
                            serializedName: "x-ms-blob-cache-control",
                            xmlName: "x-ms-blob-cache-control",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    oo = {
                        parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
                        mapper: {
                            serializedName: "x-ms-blob-content-type",
                            xmlName: "x-ms-blob-content-type",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    ao = {
                        parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
                        mapper: {
                            serializedName: "x-ms-blob-content-md5",
                            xmlName: "x-ms-blob-content-md5",
                            type: {
                                name: "ByteArray"
                            }
                        }
                    },
                    so = {
                        parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
                        mapper: {
                            serializedName: "x-ms-blob-content-encoding",
                            xmlName: "x-ms-blob-content-encoding",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    lo = {
                        parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
                        mapper: {
                            serializedName: "x-ms-blob-content-language",
                            xmlName: "x-ms-blob-content-language",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    co = {
                        parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
                        mapper: {
                            serializedName: "x-ms-blob-content-disposition",
                            xmlName: "x-ms-blob-content-disposition",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    uo = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "immutabilityPolicies",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    po = {
                        parameterPath: ["options", "immutabilityPolicyExpiry"],
                        mapper: {
                            serializedName: "x-ms-immutability-policy-until-date",
                            xmlName: "x-ms-immutability-policy-until-date",
                            type: {
                                name: "DateTimeRfc1123"
                            }
                        }
                    },
                    mo = {
                        parameterPath: ["options", "immutabilityPolicyMode"],
                        mapper: {
                            serializedName: "x-ms-immutability-policy-mode",
                            xmlName: "x-ms-immutability-policy-mode",
                            type: {
                                name: "Enum",
                                allowedValues: ["Mutable", "Unlocked", "Locked"]
                            }
                        }
                    },
                    fo = {
                        parameterPath: ["options", "encryptionScope"],
                        mapper: {
                            serializedName: "x-ms-encryption-scope",
                            xmlName: "x-ms-encryption-scope",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    ho = {
                        parameterPath: ["options", "tier"],
                        mapper: {
                            serializedName: "x-ms-access-tier",
                            xmlName: "x-ms-access-tier",
                            type: {
                                name: "Enum",
                                allowedValues: ["P4", "P6", "P10", "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive"]
                            }
                        }
                    },
                    yo = {
                        parameterPath: ["options", "rehydratePriority"],
                        mapper: {
                            serializedName: "x-ms-rehydrate-priority",
                            xmlName: "x-ms-rehydrate-priority",
                            type: {
                                name: "Enum",
                                allowedValues: ["High", "Standard"]
                            }
                        }
                    },
                    go = {
                        parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfModifiedSince"],
                        mapper: {
                            serializedName: "x-ms-source-if-modified-since",
                            xmlName: "x-ms-source-if-modified-since",
                            type: {
                                name: "DateTimeRfc1123"
                            }
                        }
                    },
                    bo = {
                        parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfUnmodifiedSince"],
                        mapper: {
                            serializedName: "x-ms-source-if-unmodified-since",
                            xmlName: "x-ms-source-if-unmodified-since",
                            type: {
                                name: "DateTimeRfc1123"
                            }
                        }
                    },
                    vo = {
                        parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
                        mapper: {
                            serializedName: "x-ms-source-if-match",
                            xmlName: "x-ms-source-if-match",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    _o = {
                        parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfNoneMatch"],
                        mapper: {
                            serializedName: "x-ms-source-if-none-match",
                            xmlName: "x-ms-source-if-none-match",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    xo = {
                        parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
                        mapper: {
                            serializedName: "x-ms-source-if-tags",
                            xmlName: "x-ms-source-if-tags",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    No = {
                        parameterPath: "copySource",
                        mapper: {
                            serializedName: "x-ms-copy-source",
                            required: !0,
                            xmlName: "x-ms-copy-source",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Po = {
                        parameterPath: ["options", "blobTagsString"],
                        mapper: {
                            serializedName: "x-ms-tags",
                            xmlName: "x-ms-tags",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    So = {
                        parameterPath: ["options", "legalHold"],
                        mapper: {
                            serializedName: "x-ms-legal-hold",
                            xmlName: "x-ms-legal-hold",
                            type: {
                                name: "Boolean"
                            }
                        }
                    },
                    wo = {
                        parameterPath: ["options", "sourceContentMD5"],
                        mapper: {
                            serializedName: "x-ms-source-content-md5",
                            xmlName: "x-ms-source-content-md5",
                            type: {
                                name: "ByteArray"
                            }
                        }
                    },
                    Co = {
                        parameterPath: ["options", "copySourceAuthorization"],
                        mapper: {
                            serializedName: "x-ms-copy-source-authorization",
                            xmlName: "x-ms-copy-source-authorization",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Eo = {
                        parameterPath: ["options", "queryRequest"],
                        mapper: Tt
                    },
                    Oo = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "tags",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    To = {
                        parameterPath: ["options", "tags"],
                        mapper: pt
                    },
                    Ro = {
                        parameterPath: ["options", "transactionalContentMD5"],
                        mapper: {
                            serializedName: "Content-MD5",
                            xmlName: "Content-MD5",
                            type: {
                                name: "ByteArray"
                            }
                        }
                    },
                    ko = {
                        parameterPath: ["options", "transactionalContentCrc64"],
                        mapper: {
                            serializedName: "x-ms-content-crc64",
                            xmlName: "x-ms-content-crc64",
                            type: {
                                name: "ByteArray"
                            }
                        }
                    },
                    zo = {
                        parameterPath: "blobContentLength",
                        mapper: {
                            serializedName: "x-ms-blob-content-length",
                            required: !0,
                            xmlName: "x-ms-blob-content-length",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Lo = {
                        parameterPath: ["options", "blobSequenceNumber"],
                        mapper: {
                            serializedName: "x-ms-blob-sequence-number",
                            xmlName: "x-ms-blob-sequence-number",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Ao = {
                        parameterPath: ["options", "contentType"],
                        mapper: {
                            defaultValue: "application/octet-stream",
                            isConstant: !0,
                            serializedName: "Content-Type",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Bo = {
                        parameterPath: "body",
                        mapper: {
                            serializedName: "body",
                            required: !0,
                            xmlName: "body",
                            type: {
                                name: "Stream"
                            }
                        }
                    },
                    Io = {
                        parameterPath: "accept",
                        mapper: {
                            defaultValue: "application/xml",
                            isConstant: !0,
                            serializedName: "Accept",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Mo = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "page",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    qo = {
                        parameterPath: "pageWrite",
                        mapper: {
                            defaultValue: "update",
                            isConstant: !0,
                            serializedName: "x-ms-page-write",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Do = {
                        parameterPath: ["options", "sequenceNumberAccessConditions", "ifSequenceNumberLessThanOrEqualTo"],
                        mapper: {
                            serializedName: "x-ms-if-sequence-number-le",
                            xmlName: "x-ms-if-sequence-number-le",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    jo = {
                        parameterPath: ["options", "sequenceNumberAccessConditions", "ifSequenceNumberLessThan"],
                        mapper: {
                            serializedName: "x-ms-if-sequence-number-lt",
                            xmlName: "x-ms-if-sequence-number-lt",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Fo = {
                        parameterPath: ["options", "sequenceNumberAccessConditions", "ifSequenceNumberEqualTo"],
                        mapper: {
                            serializedName: "x-ms-if-sequence-number-eq",
                            xmlName: "x-ms-if-sequence-number-eq",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Ho = {
                        parameterPath: "sourceUrl",
                        mapper: {
                            serializedName: "x-ms-copy-source",
                            required: !0,
                            xmlName: "x-ms-copy-source",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Uo = {
                        parameterPath: ["options", "sourceContentCrc64"],
                        mapper: {
                            serializedName: "x-ms-source-content-crc64",
                            xmlName: "x-ms-source-content-crc64",
                            type: {
                                name: "ByteArray"
                            }
                        }
                    },
                    $o = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "pagelist",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Vo = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "appendblock",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Ko = {
                        parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
                        mapper: {
                            serializedName: "x-ms-blob-condition-maxsize",
                            xmlName: "x-ms-blob-condition-maxsize",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Go = {
                        parameterPath: ["options", "appendPositionAccessConditions", "appendPosition"],
                        mapper: {
                            serializedName: "x-ms-blob-condition-appendpos",
                            xmlName: "x-ms-blob-condition-appendpos",
                            type: {
                                name: "Number"
                            }
                        }
                    },
                    Wo = {
                        parameterPath: ["options", "sourceRange"],
                        mapper: {
                            serializedName: "x-ms-source-range",
                            xmlName: "x-ms-source-range",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Xo = {
                        parameterPath: "blobType",
                        mapper: {
                            defaultValue: "BlockBlob",
                            isConstant: !0,
                            serializedName: "x-ms-blob-type",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Qo = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "block",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Jo = {
                        parameterPath: "blockId",
                        mapper: {
                            serializedName: "blockid",
                            required: !0,
                            xmlName: "blockid",
                            type: {
                                name: "String"
                            }
                        }
                    },
                    Yo = {
                        parameterPath: "blocks",
                        mapper: Pt
                    },
                    Zo = {
                        parameterPath: "comp",
                        mapper: {
                            defaultValue: "blocklist",
                            isConstant: !0,
                            serializedName: "comp",
                            type: {
                                name: "String"
                            }
                        }
                    };
                class blob_Blob {
                    constructor(t) {
                        this.client = t
                    }
                    download(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, ra)
                    }
                    getProperties(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, na)
                    }
                    delete(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, ia)
                    }
                    undelete(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, oa)
                    }
                    setExpiry(t, d) {
                        const h = {
                            expiryOptions: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, aa)
                    }
                    setHttpHeaders(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, la)
                    }
                    setImmutabilityPolicy(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, ca)
                    }
                    deleteImmutabilityPolicy(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, da)
                    }
                    setLegalHold(t, d) {
                        const h = {
                            legalHold: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, pa)
                    }
                    setMetadata(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, ma)
                    }
                    acquireLease(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, fa)
                    }
                    releaseLease(t, d) {
                        const h = {
                            leaseId: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, ha)
                    }
                    renewLease(t, d) {
                        const h = {
                            leaseId: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, ga)
                    }
                    changeLease(t, d, h) {
                        const y = {
                            leaseId: t,
                            proposedLeaseId: d,
                            options: operationOptionsToRequestOptionsBase(h || {})
                        };
                        return this.client.sendOperationRequest(y, ba)
                    }
                    breakLease(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, _a)
                    }
                    createSnapshot(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Na)
                    }
                    startCopyFromURL(t, d) {
                        const h = {
                            copySource: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, Pa)
                    }
                    copyFromURL(t, d) {
                        const h = {
                            copySource: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, Sa)
                    }
                    abortCopyFromURL(t, d) {
                        const h = {
                            copyId: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, Ea)
                    }
                    setTier(t, d) {
                        const h = {
                            tier: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, Oa)
                    }
                    getAccountInfo(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Ta)
                    }
                    query(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Ra)
                    }
                    getTags(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, ka)
                    }
                    setTags(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, La)
                    }
                }
                const ea = new Serializer(y, !0),
                    ra = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                bodyMapper: {
                                    type: {
                                        name: "Stream"
                                    },
                                    serializedName: "parsedResponse"
                                },
                                headersMapper: zr
                            },
                            206: {
                                bodyMapper: {
                                    type: {
                                        name: "Stream"
                                    },
                                    serializedName: "parsedResponse"
                                },
                                headersMapper: zr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Lr
                            }
                        },
                        queryParameters: [bi, Xi, Qi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, Ji, {
                            parameterPath: ["options", "rangeGetContentMD5"],
                            mapper: {
                                serializedName: "x-ms-range-get-content-md5",
                                xmlName: "x-ms-range-get-content-md5",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        }, {
                            parameterPath: ["options", "rangeGetContentCRC64"],
                            mapper: {
                                serializedName: "x-ms-range-get-content-crc64",
                                xmlName: "x-ms-range-get-content-crc64",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        }, Yi, Zi, eo, to, ro, no],
                        isXML: !0,
                        serializer: ea
                    },
                    na = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "HEAD",
                        responses: {
                            200: {
                                headersMapper: Ar
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Br
                            }
                        },
                        queryParameters: [bi, Xi, Qi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, Yi, Zi, eo, to, ro, no],
                        isXML: !0,
                        serializer: ea
                    },
                    ia = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "DELETE",
                        responses: {
                            202: {
                                headersMapper: Ir
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Mr
                            }
                        },
                        queryParameters: [bi, Xi, Qi, {
                            parameterPath: ["options", "blobDeleteType"],
                            mapper: {
                                serializedName: "deletetype",
                                xmlName: "deletetype",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, to, ro, no, {
                            parameterPath: ["options", "deleteSnapshots"],
                            mapper: {
                                serializedName: "x-ms-delete-snapshots",
                                xmlName: "x-ms-delete-snapshots",
                                type: {
                                    name: "Enum",
                                    allowedValues: ["include", "only"]
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ea
                    },
                    oa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: qr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Dr
                            }
                        },
                        queryParameters: [bi, Ii],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi],
                        isXML: !0,
                        serializer: ea
                    },
                    aa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: jr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Fr
                            }
                        },
                        queryParameters: [bi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "expiry",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, {
                            parameterPath: "expiryOptions",
                            mapper: {
                                serializedName: "x-ms-expiry-option",
                                required: !0,
                                xmlName: "x-ms-expiry-option",
                                type: {
                                    name: "String"
                                }
                            }
                        }, {
                            parameterPath: ["options", "expiresOn"],
                            mapper: {
                                serializedName: "x-ms-expiry-time",
                                xmlName: "x-ms-expiry-time",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ea
                    },
                    la = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: Hr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Ur
                            }
                        },
                        queryParameters: [gi, bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, to, ro, no, io, oo, ao, so, lo, co],
                        isXML: !0,
                        serializer: ea
                    },
                    ca = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: $r
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Vr
                            }
                        },
                        queryParameters: [bi, uo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Li, po, mo],
                        isXML: !0,
                        serializer: ea
                    },
                    da = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "DELETE",
                        responses: {
                            200: {
                                headersMapper: Kr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Gr
                            }
                        },
                        queryParameters: [bi, uo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi],
                        isXML: !0,
                        serializer: ea
                    },
                    pa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: Wr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Xr
                            }
                        },
                        queryParameters: [bi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "legalhold",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, {
                            parameterPath: "legalHold",
                            mapper: {
                                serializedName: "x-ms-legal-hold",
                                required: !0,
                                xmlName: "x-ms-legal-hold",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ea
                    },
                    ma = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: Qr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Jr
                            }
                        },
                        queryParameters: [bi, Ai],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ti, ki, zi, Li, Yi, Zi, eo, to, ro, no, fo],
                        isXML: !0,
                        serializer: ea
                    },
                    fa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: Yr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Zr
                            }
                        },
                        queryParameters: [bi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, qi, Di, ji, to, ro, no],
                        isXML: !0,
                        serializer: ea
                    },
                    ha = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: en
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: tn
                            }
                        },
                        queryParameters: [bi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, Fi, Hi, to, ro, no],
                        isXML: !0,
                        serializer: ea
                    },
                    ga = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: rn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: nn
                            }
                        },
                        queryParameters: [bi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, Hi, Ui, to, ro, no],
                        isXML: !0,
                        serializer: ea
                    },
                    ba = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: an
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: sn
                            }
                        },
                        queryParameters: [bi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, Hi, Ki, Gi, to, ro, no],
                        isXML: !0,
                        serializer: ea
                    },
                    _a = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            202: {
                                headersMapper: ln
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: cn
                            }
                        },
                        queryParameters: [bi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, $i, Vi, to, ro, no],
                        isXML: !0,
                        serializer: ea
                    },
                    Na = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: un
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: dn
                            }
                        },
                        queryParameters: [bi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "snapshot",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ti, ki, zi, Li, Yi, Zi, eo, to, ro, no, fo],
                        isXML: !0,
                        serializer: ea
                    },
                    Pa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            202: {
                                headersMapper: pn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: mn
                            }
                        },
                        queryParameters: [bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ti, ki, zi, Li, to, ro, no, po, mo, ho, yo, go, bo, vo, _o, xo, No, Po, {
                            parameterPath: ["options", "sealBlob"],
                            mapper: {
                                serializedName: "x-ms-seal-blob",
                                xmlName: "x-ms-seal-blob",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        }, So],
                        isXML: !0,
                        serializer: ea
                    },
                    Sa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            202: {
                                headersMapper: hn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: yn
                            }
                        },
                        queryParameters: [bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ti, ki, zi, Li, to, ro, no, po, mo, ho, go, bo, vo, _o, No, Po, So, {
                            parameterPath: "xMsRequiresSync",
                            mapper: {
                                defaultValue: "true",
                                isConstant: !0,
                                serializedName: "x-ms-requires-sync",
                                type: {
                                    name: "String"
                                }
                            }
                        }, wo, Co],
                        isXML: !0,
                        serializer: ea
                    },
                    Ea = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            204: {
                                headersMapper: gn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: bn
                            }
                        },
                        queryParameters: [bi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "copy",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }, {
                            parameterPath: "copyId",
                            mapper: {
                                serializedName: "copyid",
                                required: !0,
                                xmlName: "copyid",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, {
                            parameterPath: "copyActionAbortConstant",
                            mapper: {
                                defaultValue: "abort",
                                isConstant: !0,
                                serializedName: "x-ms-copy-action",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ea
                    },
                    Oa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: vn
                            },
                            202: {
                                headersMapper: vn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: _n
                            }
                        },
                        queryParameters: [bi, Xi, Qi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "tier",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, no, yo, {
                            parameterPath: "tier",
                            mapper: {
                                serializedName: "x-ms-access-tier",
                                required: !0,
                                xmlName: "x-ms-access-tier",
                                type: {
                                    name: "Enum",
                                    allowedValues: ["P4", "P6", "P10", "P15", "P20", "P30", "P40", "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive"]
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ea
                    },
                    Ta = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                headersMapper: xn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Nn
                            }
                        },
                        queryParameters: [gi, Ci],
                        urlParameters: [yi],
                        headerParameters: [vi, xi],
                        isXML: !0,
                        serializer: ea
                    },
                    Ra = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "POST",
                        responses: {
                            200: {
                                bodyMapper: {
                                    type: {
                                        name: "Stream"
                                    },
                                    serializedName: "parsedResponse"
                                },
                                headersMapper: Pn
                            },
                            206: {
                                bodyMapper: {
                                    type: {
                                        name: "Stream"
                                    },
                                    serializedName: "parsedResponse"
                                },
                                headersMapper: Pn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Sn
                            }
                        },
                        requestBody: Eo,
                        queryParameters: [bi, Xi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "query",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [fi, hi, vi, _i, ki, zi, Li, Yi, Zi, eo, to, ro, no],
                        isXML: !0,
                        contentType: "application/xml; charset=utf-8",
                        mediaType: "xml",
                        serializer: ea
                    },
                    ka = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                bodyMapper: pt,
                                headersMapper: wn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Cn
                            }
                        },
                        queryParameters: [bi, Xi, Qi, Oo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, no],
                        isXML: !0,
                        serializer: ea
                    },
                    La = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            204: {
                                headersMapper: En
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: On
                            }
                        },
                        requestBody: To,
                        queryParameters: [bi, Qi, Oo],
                        urlParameters: [yi],
                        headerParameters: [fi, hi, vi, _i, ki, no, Ro, ko],
                        isXML: !0,
                        contentType: "application/xml; charset=utf-8",
                        mediaType: "xml",
                        serializer: ea
                    };
                class AppendBlob {
                    constructor(t) {
                        this.client = t
                    }
                    create(t, d) {
                        const h = {
                            contentLength: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, ja)
                    }
                    appendBlock(t, d, h) {
                        const y = {
                            contentLength: t,
                            body: d,
                            options: operationOptionsToRequestOptionsBase(h || {})
                        };
                        return this.client.sendOperationRequest(y, Ua)
                    }
                    appendBlockFromUrl(t, d, h) {
                        const y = {
                            sourceUrl: t,
                            contentLength: d,
                            options: operationOptionsToRequestOptionsBase(h || {})
                        };
                        return this.client.sendOperationRequest(y, $a)
                    }
                    seal(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Va)
                    }
                }
                const Ia = new Serializer(y, !0),
                    Ma = new Serializer(y, !1),
                    ja = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: Gn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Wn
                            }
                        },
                        queryParameters: [bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ei, Ti, ki, zi, Li, Yi, Zi, eo, to, ro, no, io, oo, ao, so, lo, co, po, mo, fo, Po, So, {
                            parameterPath: "blobType",
                            mapper: {
                                defaultValue: "AppendBlob",
                                isConstant: !0,
                                serializedName: "x-ms-blob-type",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: Ia
                    },
                    Ua = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: Xn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Qn
                            }
                        },
                        requestBody: Bo,
                        queryParameters: [bi, Vo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, Ei, ki, zi, Li, Yi, Zi, eo, to, ro, no, fo, Ro, ko, Ao, Io, Ko, Go],
                        mediaType: "binary",
                        serializer: Ma
                    },
                    $a = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: Jn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Yn
                            }
                        },
                        queryParameters: [bi, Vo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ei, ki, zi, Li, Yi, Zi, eo, to, ro, no, fo, go, bo, vo, _o, wo, Co, Ro, Ho, Uo, Ko, Go, Wo],
                        isXML: !0,
                        serializer: Ia
                    },
                    Va = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: Zn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: ei
                            }
                        },
                        queryParameters: [bi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "seal",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, to, ro, Go],
                        isXML: !0,
                        serializer: Ia
                    };
                class BlockBlob {
                    constructor(t) {
                        this.client = t
                    }
                    upload(t, d, h) {
                        const y = {
                            contentLength: t,
                            body: d,
                            options: operationOptionsToRequestOptionsBase(h || {})
                        };
                        return this.client.sendOperationRequest(y, Xa)
                    }
                    putBlobFromUrl(t, d, h) {
                        const y = {
                            contentLength: t,
                            copySource: d,
                            options: operationOptionsToRequestOptionsBase(h || {})
                        };
                        return this.client.sendOperationRequest(y, Qa)
                    }
                    stageBlock(t, d, h, y) {
                        const _ = {
                            blockId: t,
                            contentLength: d,
                            body: h,
                            options: operationOptionsToRequestOptionsBase(y || {})
                        };
                        return this.client.sendOperationRequest(_, Ja)
                    }
                    stageBlockFromURL(t, d, h, y) {
                        const _ = {
                            blockId: t,
                            contentLength: d,
                            sourceUrl: h,
                            options: operationOptionsToRequestOptionsBase(y || {})
                        };
                        return this.client.sendOperationRequest(_, Ya)
                    }
                    commitBlockList(t, d) {
                        const h = {
                            blocks: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, Za)
                    }
                    getBlockList(t, d) {
                        const h = {
                            listType: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, es)
                    }
                }
                const Ka = new Serializer(y, !0),
                    Wa = new Serializer(y, !1),
                    Xa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: ti
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: ri
                            }
                        },
                        requestBody: Bo,
                        queryParameters: [bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, Ei, Ti, ki, zi, Li, Yi, Zi, eo, to, ro, no, io, oo, ao, so, lo, co, po, mo, fo, ho, Po, So, Ro, Ao, Io, Xo],
                        mediaType: "binary",
                        serializer: Wa
                    },
                    Qa = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: ni
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: ii
                            }
                        },
                        queryParameters: [bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ei, Ti, ki, zi, Li, Yi, Zi, eo, to, ro, no, io, oo, ao, so, lo, co, fo, ho, go, bo, vo, _o, xo, No, Po, wo, Co, Ro, Xo, {
                            parameterPath: ["options", "copySourceBlobProperties"],
                            mapper: {
                                serializedName: "x-ms-copy-source-blob-properties",
                                xmlName: "x-ms-copy-source-blob-properties",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: Ka
                    },
                    Ja = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: oi
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: ai
                            }
                        },
                        requestBody: Bo,
                        queryParameters: [bi, Qo, Jo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, Ei, ki, Yi, Zi, eo, fo, Ro, ko, Ao, Io],
                        mediaType: "binary",
                        serializer: Wa
                    },
                    Ya = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: si
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: li
                            }
                        },
                        queryParameters: [bi, Qo, Jo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ei, ki, Yi, Zi, eo, fo, go, bo, vo, _o, wo, Co, Ho, Uo, Wo],
                        isXML: !0,
                        serializer: Ka
                    },
                    Za = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: ci
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: ui
                            }
                        },
                        requestBody: Yo,
                        queryParameters: [bi, Zo],
                        urlParameters: [yi],
                        headerParameters: [fi, hi, vi, _i, Ti, ki, zi, Li, Yi, Zi, eo, to, ro, no, io, oo, ao, so, lo, co, po, mo, fo, ho, Po, So, Ro, ko],
                        isXML: !0,
                        contentType: "application/xml; charset=utf-8",
                        mediaType: "xml",
                        serializer: Ka
                    },
                    es = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                bodyMapper: St,
                                headersMapper: di
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: pi
                            }
                        },
                        queryParameters: [bi, Xi, Zo, {
                            parameterPath: "listType",
                            mapper: {
                                defaultValue: "committed",
                                serializedName: "blocklisttype",
                                required: !0,
                                xmlName: "blocklisttype",
                                type: {
                                    name: "Enum",
                                    allowedValues: ["committed", "uncommitted", "all"]
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, no],
                        isXML: !0,
                        serializer: Ka
                    };
                class PageBlob {
                    constructor(t) {
                        this.client = t
                    }
                    create(t, d, h) {
                        const y = {
                            contentLength: t,
                            blobContentLength: d,
                            options: operationOptionsToRequestOptionsBase(h || {})
                        };
                        return this.client.sendOperationRequest(y, ns)
                    }
                    uploadPages(t, d, h) {
                        const y = {
                            contentLength: t,
                            body: d,
                            options: operationOptionsToRequestOptionsBase(h || {})
                        };
                        return this.client.sendOperationRequest(y, is)
                    }
                    clearPages(t, d) {
                        const h = {
                            contentLength: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, os)
                    }
                    uploadPagesFromURL(t, d, h, y, _) {
                        const x = {
                            sourceUrl: t,
                            sourceRange: d,
                            contentLength: h,
                            range: y,
                            options: operationOptionsToRequestOptionsBase(_ || {})
                        };
                        return this.client.sendOperationRequest(x, as)
                    }
                    getPageRanges(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, ss)
                    }
                    getPageRangesDiff(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, ls)
                    }
                    resize(t, d) {
                        const h = {
                            blobContentLength: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, cs)
                    }
                    updateSequenceNumber(t, d) {
                        const h = {
                            sequenceNumberAction: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, us)
                    }
                    copyIncremental(t, d) {
                        const h = {
                            copySource: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, ds)
                    }
                }
                const ts = new Serializer(y, !0),
                    rs = new Serializer(y, !1),
                    ns = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: Tn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Rn
                            }
                        },
                        queryParameters: [bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ei, Ti, ki, zi, Li, Yi, Zi, eo, to, ro, no, io, oo, ao, so, lo, co, po, mo, fo, ho, Po, So, {
                            parameterPath: "blobType",
                            mapper: {
                                defaultValue: "PageBlob",
                                isConstant: !0,
                                serializedName: "x-ms-blob-type",
                                type: {
                                    name: "String"
                                }
                            }
                        }, zo, Lo],
                        isXML: !0,
                        serializer: ts
                    },
                    is = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: kn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: zn
                            }
                        },
                        requestBody: Bo,
                        queryParameters: [bi, Mo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, Ei, ki, zi, Li, Ji, Yi, Zi, eo, to, ro, no, fo, Ro, ko, Ao, Io, qo, Do, jo, Fo],
                        mediaType: "binary",
                        serializer: rs
                    },
                    os = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: Ln
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: An
                            }
                        },
                        queryParameters: [bi, Mo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ei, ki, zi, Li, Ji, Yi, Zi, eo, to, ro, no, fo, Do, jo, Fo, {
                            parameterPath: "pageWrite",
                            mapper: {
                                defaultValue: "clear",
                                isConstant: !0,
                                serializedName: "x-ms-page-write",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ts
                    },
                    as = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: Bn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: In
                            }
                        },
                        queryParameters: [bi, Mo],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ei, ki, zi, Li, Yi, Zi, eo, to, ro, no, fo, go, bo, vo, _o, wo, Co, qo, Do, jo, Fo, Ho, {
                            parameterPath: "sourceRange",
                            mapper: {
                                serializedName: "x-ms-source-range",
                                required: !0,
                                xmlName: "x-ms-source-range",
                                type: {
                                    name: "String"
                                }
                            }
                        }, Uo, {
                            parameterPath: "range",
                            mapper: {
                                serializedName: "x-ms-range",
                                required: !0,
                                xmlName: "x-ms-range",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ts
                    },
                    ss = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                bodyMapper: Ct,
                                headersMapper: Mn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: qn
                            }
                        },
                        queryParameters: [bi, Xi, $o],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, Ji, to, ro, no],
                        isXML: !0,
                        serializer: ts
                    },
                    ls = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                bodyMapper: Ct,
                                headersMapper: Dn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: jn
                            }
                        },
                        queryParameters: [bi, Xi, $o, {
                            parameterPath: ["options", "prevsnapshot"],
                            mapper: {
                                serializedName: "prevsnapshot",
                                xmlName: "prevsnapshot",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, Ji, to, ro, no, {
                            parameterPath: ["options", "prevSnapshotUrl"],
                            mapper: {
                                serializedName: "x-ms-previous-snapshot-url",
                                xmlName: "x-ms-previous-snapshot-url",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ts
                    },
                    cs = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: Fn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Hn
                            }
                        },
                        queryParameters: [gi, bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, Yi, Zi, eo, to, ro, no, fo, zo],
                        isXML: !0,
                        serializer: ts
                    },
                    us = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: Un
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: $n
                            }
                        },
                        queryParameters: [gi, bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li, to, ro, no, Lo, {
                            parameterPath: "sequenceNumberAction",
                            mapper: {
                                serializedName: "x-ms-sequence-number-action",
                                required: !0,
                                xmlName: "x-ms-sequence-number-action",
                                type: {
                                    name: "Enum",
                                    allowedValues: ["max", "update", "increment"]
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: ts
                    },
                    ds = {
                        path: "/{containerName}/{blob}",
                        httpMethod: "PUT",
                        responses: {
                            202: {
                                headersMapper: Vn
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Kn
                            }
                        },
                        queryParameters: [bi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "incrementalcopy",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, to, ro, no, No],
                        isXML: !0,
                        serializer: ts
                    },
                    ps = "2020-10-02",
                    ms = 268435456,
                    fs = 4194304e3,
                    hs = 5e4,
                    ys = 4194304,
                    gs = {
                        FORCE_BROWSER_NO_CACHE: "_",
                        SIGNATURE: "sig",
                        SNAPSHOT: "snapshot",
                        VERSIONID: "versionid",
                        TIMEOUT: "timeout"
                    },
                    bs = "Content-Length",
                    vs = "Cookie",
                    _s = "User-Agent",
                    xs = "",
                    Ns = ["Access-Control-Allow-Origin", "Cache-Control", "Content-Length", "Content-Type", "Date", "Request-Id", "traceparent", "Transfer-Encoding", "User-Agent", "x-ms-client-request-id", "x-ms-date", "x-ms-error-code", "x-ms-request-id", "x-ms-return-client-request-id", "x-ms-version", "Accept-Ranges", "Content-Disposition", "Content-Encoding", "Content-Language", "Content-MD5", "Content-Range", "ETag", "Last-Modified", "Server", "Vary", "x-ms-content-crc64", "x-ms-copy-action", "x-ms-copy-completion-time", "x-ms-copy-id", "x-ms-copy-progress", "x-ms-copy-status", "x-ms-has-immutability-policy", "x-ms-has-legal-hold", "x-ms-lease-state", "x-ms-lease-status", "x-ms-range", "x-ms-request-server-encrypted", "x-ms-server-encrypted", "x-ms-snapshot", "x-ms-source-range", "If-Match", "If-Modified-Since", "If-None-Match", "If-Unmodified-Since", "x-ms-access-tier", "x-ms-access-tier-change-time", "x-ms-access-tier-inferred", "x-ms-account-kind", "x-ms-archive-status", "x-ms-blob-append-offset", "x-ms-blob-cache-control", "x-ms-blob-committed-block-count", "x-ms-blob-condition-appendpos", "x-ms-blob-condition-maxsize", "x-ms-blob-content-disposition", "x-ms-blob-content-encoding", "x-ms-blob-content-language", "x-ms-blob-content-length", "x-ms-blob-content-md5", "x-ms-blob-content-type", "x-ms-blob-public-access", "x-ms-blob-sequence-number", "x-ms-blob-type", "x-ms-copy-destination-snapshot", "x-ms-creation-time", "x-ms-default-encryption-scope", "x-ms-delete-snapshots", "x-ms-delete-type-permanent", "x-ms-deny-encryption-scope-override", "x-ms-encryption-algorithm", "x-ms-if-sequence-number-eq", "x-ms-if-sequence-number-le", "x-ms-if-sequence-number-lt", "x-ms-incremental-copy", "x-ms-lease-action", "x-ms-lease-break-period", "x-ms-lease-duration", "x-ms-lease-id", "x-ms-lease-time", "x-ms-page-write", "x-ms-proposed-lease-id", "x-ms-range-get-content-md5", "x-ms-rehydrate-priority", "x-ms-sequence-number-action", "x-ms-sku-name", "x-ms-source-content-md5", "x-ms-source-if-match", "x-ms-source-if-modified-since", "x-ms-source-if-none-match", "x-ms-source-if-unmodified-since", "x-ms-tag-count", "x-ms-encryption-key-sha256", "x-ms-if-tags", "x-ms-source-if-tags"],
                    Ps = ["comp", "maxresults", "rscc", "rscd", "rsce", "rscl", "rsct", "se", "si", "sip", "sp", "spr", "sr", "srt", "ss", "st", "sv", "include", "marker", "prefix", "copyid", "restype", "blockid", "blocklisttype", "delimiter", "prevsnapshot", "ske", "skoid", "sks", "skt", "sktid", "skv", "snapshot"];
                var Ss, ws;

                function toAccessTier(t) {
                    if (void 0 !== t) return t
                }

                function ensureCpkIfSpecified(t, d) {
                    if (t && !d) throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
                    t && !t.encryptionAlgorithm && (t.encryptionAlgorithm = "AES256")
                }

                function rangeResponseFromModel(t) {
                    const d = (t._response.parsedBody.pageRange || []).map((t => ({
                            offset: t.start,
                            count: t.end - t.start
                        }))),
                        h = (t._response.parsedBody.clearRange || []).map((t => ({
                            offset: t.start,
                            count: t.end - t.start
                        })));
                    return Object.assign(Object.assign({}, t), {
                        pageRange: d,
                        clearRange: h,
                        _response: Object.assign(Object.assign({}, t._response), {
                            parsedBody: {
                                pageRange: d,
                                clearRange: h
                            }
                        })
                    })
                }

                function createSpanFunction(t) {
                    return function(d, h) {
                        const y = function getTracer(t, d) {
                                return $e.getTracer(t || "azure/core-tracing", d)
                            }(),
                            _ = (null == h ? void 0 : h.tracingOptions) || {},
                            x = Object.assign({
                                kind: Ve.INTERNAL
                            }, _.spanOptions),
                            C = t.packagePrefix ? `${t.packagePrefix}.${d}` : d;
                        let E;
                        E = function isTracingDisabled() {
                            var t;
                            if ("undefined" == typeof process) return !1;
                            const d = null === (t = process.env.AZURE_TRACING_DISABLED) || void 0 === t ? void 0 : t.toLowerCase();
                            return "false" !== d && "0" !== d && Boolean(d)
                        }() ? $e.wrapSpanContext(Ne) : y.startSpan(C, x, _.tracingContext), t.namespace && E.setAttribute("az.namespace", t.namespace);
                        let O = _.spanOptions || {};
                        E.isRecording() && t.namespace && (O = Object.assign(Object.assign({}, _.spanOptions), {
                            attributes: Object.assign(Object.assign({}, x.attributes), {
                                "az.namespace": t.namespace
                            })
                        }));
                        const k = Object.assign(Object.assign({}, _), {
                            spanOptions: O,
                            tracingContext: interfaces_setSpan(_.tracingContext || Ke.active(), E)
                        });
                        return {
                            span: E,
                            updatedOptions: Object.assign(Object.assign({}, h), {
                                tracingOptions: k
                            })
                        }
                    }
                }! function(t) {
                    t.Hot = "Hot", t.Cool = "Cool", t.Archive = "Archive"
                }(Ss || (Ss = {})),
                function(t) {
                    t.P4 = "P4", t.P6 = "P6", t.P10 = "P10", t.P15 = "P15", t.P20 = "P20", t.P30 = "P30", t.P40 = "P40", t.P50 = "P50", t.P60 = "P60", t.P70 = "P70", t.P80 = "P80"
                }(ws || (ws = {}));
                const Cs = "undefined" != typeof process && process.env && process.env.DEBUG || void 0;
                let Es, Os = [],
                    Ts = [];
                const Rs = [];
                Cs && enable(Cs);
                const ks = Object.assign((t => createDebugger(t)), {
                    enable,
                    enabled,
                    disable: function disable() {
                        const t = Es || "";
                        return enable(""), t
                    },
                    log: function log(...t) {
                        if (t.length > 0) {
                            const d = String(t[0]);
                            d.includes(":error") ? console.error(...t) : d.includes(":warning") ? console.warn(...t) : d.includes(":info") ? console.info(...t) : (d.includes(":verbose"), console.debug(...t))
                        }
                    }
                });

                function enable(t) {
                    Es = t, Os = [], Ts = [];
                    const d = /\*/g,
                        h = t.split(",").map((t => t.trim().replace(d, ".*?")));
                    for (const y of h) y.startsWith("-") ? Ts.push(new RegExp(`^${y.substr(1)}$`)) : Os.push(new RegExp(`^${y}$`));
                    for (const y of Rs) y.enabled = enabled(y.namespace)
                }

                function enabled(t) {
                    if (t.endsWith("*")) return !0;
                    for (const d of Ts)
                        if (d.test(t)) return !1;
                    for (const d of Os)
                        if (d.test(t)) return !0;
                    return !1
                }

                function createDebugger(t) {
                    const d = Object.assign((function debug(...h) {
                        if (!d.enabled) return;
                        h.length > 0 && (h[0] = `${t} ${h[0]}`);
                        d.log(...h)
                    }), {
                        enabled: enabled(t),
                        destroy,
                        log: ks.log,
                        namespace: t,
                        extend
                    });
                    return Rs.push(d), d
                }

                function destroy() {
                    const t = Rs.indexOf(this);
                    return t >= 0 && (Rs.splice(t, 1), !0)
                }

                function extend(t) {
                    const d = createDebugger(`${this.namespace}:${t}`);
                    return d.log = this.log, d
                }
                const zs = ks,
                    Ls = new Set,
                    As = "undefined" != typeof process && process.env && process.env.AZURE_LOG_LEVEL || void 0;
                let Bs;
                const Is = zs("azure");
                Is.log = (...t) => {
                    zs.log(...t)
                };
                const Ms = ["verbose", "info", "warning", "error"];
                As && (isAzureLogLevel(As) ? function setLogLevel(t) {
                    if (t && !isAzureLogLevel(t)) throw new Error(`Unknown log level '${t}'. Acceptable values: ${Ms.join(",")}`);
                    Bs = t;
                    const d = [];
                    for (const h of Ls) shouldEnable(h) && d.push(h.namespace);
                    zs.enable(d.join(","))
                }(As) : console.error(`AZURE_LOG_LEVEL set to unknown log level '${As}'; logging is not enabled. Acceptable values: ${Ms.join(", ")}.`));
                const qs = {
                    verbose: 400,
                    info: 300,
                    warning: 200,
                    error: 100
                };

                function createClientLogger(t) {
                    const d = Is.extend(t);
                    return patchLogMethod(Is, d), {
                        error: createLogger(d, "error"),
                        warning: createLogger(d, "warning"),
                        info: createLogger(d, "info"),
                        verbose: createLogger(d, "verbose")
                    }
                }

                function patchLogMethod(t, d) {
                    d.log = (...d) => {
                        t.log(...d)
                    }
                }

                function createLogger(t, d) {
                    const h = Object.assign(t.extend(d), {
                        level: d
                    });
                    if (patchLogMethod(t, h), shouldEnable(h)) {
                        const t = zs.disable();
                        zs.enable(t + "," + h.namespace)
                    }
                    return Ls.add(h), h
                }

                function shouldEnable(t) {
                    return !!(Bs && qs[t.level] <= qs[Bs])
                }

                function isAzureLogLevel(t) {
                    return Ms.includes(t)
                }
                const Ds = createClientLogger("core-http"),
                    js = createSpanFunction({
                        packagePrefix: "",
                        namespace: ""
                    });

                function tracingPolicy_tracingPolicy(t = {}) {
                    return {
                        create: (d, h) => new TracingPolicy(d, h, t)
                    }
                }
                class TracingPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h) {
                        super(t, d), this.userAgent = h.userAgent
                    }
                    async sendRequest(t) {
                        if (!t.tracingContext) return this._nextPolicy.sendRequest(t);
                        const d = this.tryCreateSpan(t);
                        if (!d) return this._nextPolicy.sendRequest(t);
                        try {
                            const h = await this._nextPolicy.sendRequest(t);
                            return this.tryProcessResponse(d, h), h
                        } catch (h) {
                            throw this.tryProcessError(d, h), h
                        }
                    }
                    tryCreateSpan(t) {
                        var d;
                        try {
                            const h = url_URLBuilder.parse(t.url).getPath() || "/",
                                {
                                    span: y
                                } = js(h, {
                                    tracingOptions: {
                                        spanOptions: Object.assign(Object.assign({}, t.spanOptions), {
                                            kind: Ve.CLIENT
                                        }),
                                        tracingContext: t.tracingContext
                                    }
                                });
                            if (!y.isRecording()) return void y.end();
                            const _ = null === (d = t.tracingContext) || void 0 === d ? void 0 : d.getValue(Symbol.for("az.namespace"));
                            "string" == typeof _ && y.setAttribute("az.namespace", _), y.setAttributes({
                                "http.method": t.method,
                                "http.url": t.url,
                                requestId: t.requestId
                            }), this.userAgent && y.setAttribute("http.user_agent", this.userAgent);
                            const x = y.spanContext(),
                                C = function getTraceParentHeader(t) {
                                    const d = [];
                                    if (t.traceId || d.push("traceId"), t.spanId || d.push("spanId"), d.length) return;
                                    const h = (t.traceFlags || 0).toString(16),
                                        y = 1 === h.length ? `0${h}` : h;
                                    return `00-${t.traceId}-${t.spanId}-${y}`
                                }(x);
                            if (C && function interfaces_isSpanContextValid(t) {
                                    return $e.isSpanContextValid(t)
                                }(x)) {
                                t.headers.set("traceparent", C);
                                const d = x.traceState && x.traceState.serialize();
                                d && t.headers.set("tracestate", d)
                            }
                            return y
                        } catch (h) {
                            return void Ds.warning(`Skipping creating a tracing span due to an error: ${h.message}`)
                        }
                    }
                    tryProcessError(t, d) {
                        try {
                            t.setStatus({
                                code: Ge.ERROR,
                                message: d.message
                            }), d.statusCode && t.setAttribute("http.status_code", d.statusCode), t.end()
                        } catch (h) {
                            Ds.warning(`Skipping tracing span processing due to an error: ${h.message}`)
                        }
                    }
                    tryProcessResponse(t, d) {
                        try {
                            t.setAttribute("http.status_code", d.status);
                            const h = d.headers.get("x-ms-request-id");
                            h && t.setAttribute("serviceRequestId", h), t.setStatus({
                                code: Ge.OK
                            }), t.end()
                        } catch (h) {
                            Ds.warning(`Skipping tracing span processing due to an error: ${h.message}`)
                        }
                    }
                }
                const Fs = {
                    enable: !0
                };
                class KeepAlivePolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h) {
                        super(t, d), this.keepAliveOptions = h
                    }
                    async sendRequest(t) {
                        return t.keepAlive = this.keepAliveOptions.enable, this._nextPolicy.sendRequest(t)
                    }
                }

                function generateClientRequestIdPolicy_generateClientRequestIdPolicy(t = "x-ms-client-request-id") {
                    return {
                        create: (d, h) => new GenerateClientRequestIdPolicy(d, h, t)
                    }
                }
                class GenerateClientRequestIdPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h) {
                        super(t, d), this._requestIdHeaderName = h
                    }
                    sendRequest(t) {
                        return t.headers.contains(this._requestIdHeaderName) || t.headers.set(this._requestIdHeaderName, t.requestId), this._nextPolicy.sendRequest(t)
                    }
                }
                const Hs = "REDACTED",
                    Us = ["x-ms-client-request-id", "x-ms-return-client-request-id", "x-ms-useragent", "x-ms-correlation-request-id", "x-ms-request-id", "client-request-id", "ms-cv", "return-client-request-id", "traceparent", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Origin", "Accept", "Accept-Encoding", "Cache-Control", "Connection", "Content-Length", "Content-Type", "Date", "ETag", "Expires", "If-Match", "If-Modified-Since", "If-None-Match", "If-Unmodified-Since", "Last-Modified", "Pragma", "Request-Id", "Retry-After", "Server", "Transfer-Encoding", "User-Agent"],
                    $s = ["api-version"];
                class Sanitizer {
                    constructor({
                        allowedHeaderNames: t = [],
                        allowedQueryParameters: d = []
                    } = {}) {
                        t = Array.isArray(t) ? Us.concat(t) : Us, d = Array.isArray(d) ? $s.concat(d) : $s, this.allowedHeaderNames = new Set(t.map((t => t.toLowerCase()))), this.allowedQueryParameters = new Set(d.map((t => t.toLowerCase())))
                    }
                    sanitize(t) {
                        const d = new Set;
                        return JSON.stringify(t, ((t, h) => {
                            if (h instanceof Error) return Object.assign(Object.assign({}, h), {
                                name: h.name,
                                message: h.message
                            });
                            if ("_headersMap" === t) return this.sanitizeHeaders(h);
                            if ("url" === t) return this.sanitizeUrl(h);
                            if ("query" === t) return this.sanitizeQuery(h);
                            if ("body" !== t && "response" !== t && "operationSpec" !== t) {
                                if (Array.isArray(h) || function isObject(t) {
                                        return !("object" != typeof t || null === t || Array.isArray(t) || t instanceof RegExp || t instanceof Date)
                                    }(h)) {
                                    if (d.has(h)) return "[Circular]";
                                    d.add(h)
                                }
                                return h
                            }
                        }), 2)
                    }
                    sanitizeHeaders(t) {
                        return this.sanitizeObject(t, this.allowedHeaderNames, ((t, d) => t[d].value))
                    }
                    sanitizeQuery(t) {
                        return this.sanitizeObject(t, this.allowedQueryParameters, ((t, d) => t[d]))
                    }
                    sanitizeObject(t, d, h) {
                        if ("object" != typeof t || null === t) return t;
                        const y = {};
                        for (const _ of Object.keys(t)) d.has(_.toLowerCase()) ? y[_] = h(t, _) : y[_] = Hs;
                        return y
                    }
                    sanitizeUrl(t) {
                        if ("string" != typeof t || null === t) return t;
                        const d = url_URLBuilder.parse(t),
                            h = d.getQuery();
                        if (!h) return t;
                        const y = URLQuery.parse(h);
                        for (const _ of y.keys()) this.allowedQueryParameters.has(_.toLowerCase()) || y.set(_, Hs);
                        return d.setQuery(y.toString()), d.toString()
                    }
                }
                const Vs = {},
                    Ks = new Sanitizer;
                class RestError extends Error {
                    constructor(t, d, h, y, _) {
                        super(t), this.name = "RestError", this.code = d, this.statusCode = h, this.request = y, this.response = _, Object.setPrototypeOf(this, RestError.prototype)
                    } [Vs]() {
                        return `RestError: ${this.message} \n ${Ks.sanitize(this)}`
                    }
                }
                if (RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR", RestError.PARSE_ERROR = "PARSE_ERROR", !(self.document && self.DOMParser && self.Node && self.XMLSerializer)) throw new Error('This library depends on the following DOM objects: ["document", "DOMParser", "Node", "XMLSerializer"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. ');
                const Gs = document.implementation.createDocument(null, null, null),
                    Ws = new DOMParser;

                function parseXML(t, d = {}) {
                    var h, y, _;
                    try {
                        const x = {
                                rootName: null !== (h = d.rootName) && void 0 !== h ? h : "",
                                includeRoot: null !== (y = d.includeRoot) && void 0 !== y && y,
                                xmlCharKey: null !== (_ = d.xmlCharKey) && void 0 !== _ ? _ : E
                            },
                            C = Ws.parseFromString(t, "application/xml");
                        let O;
                        return function throwIfError(t) {
                            const d = t.getElementsByTagName("parsererror");
                            if (d.length > 0 && function getErrorNamespace() {
                                    var t;
                                    if (void 0 === Xs) try {
                                        Xs = null !== (t = Ws.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI) && void 0 !== t ? t : ""
                                    } catch (d) {
                                        Xs = ""
                                    }
                                    return Xs
                                }())
                                for (let h = 0; h < d.length; h++)
                                    if (d[h].namespaceURI === Xs) throw new Error(d[h].innerHTML)
                        }(C), O = x.includeRoot ? domToObject(C, x) : domToObject(C.childNodes[0], x), Promise.resolve(O)
                    } catch (x) {
                        return Promise.reject(x)
                    }
                }
                let Xs;

                function domToObject(t, d) {
                    let h = {};
                    const y = t.childNodes.length,
                        _ = t.childNodes[0],
                        x = _ && 1 === y && _.nodeType === Node.TEXT_NODE && _.nodeValue || void 0,
                        E = function asElementWithAttributes(t) {
                            return function isElement(t) {
                                return !!t.attributes
                            }(t) && t.hasAttributes() ? t : void 0
                        }(t);
                    if (E) {
                        h[C] = {};
                        for (let t = 0; t < E.attributes.length; t++) {
                            const d = E.attributes[t];
                            h[C][d.nodeName] = d.nodeValue
                        }
                        x && (h[d.xmlCharKey] = x)
                    } else 0 === y ? h = "" : x && (h = x);
                    if (!x)
                        for (let C = 0; C < y; C++) {
                            const y = t.childNodes[C];
                            if (y.nodeType !== Node.TEXT_NODE) {
                                const t = domToObject(y, d);
                                h[y.nodeName] ? Array.isArray(h[y.nodeName]) ? h[y.nodeName].push(t) : h[y.nodeName] = [h[y.nodeName], t] : h[y.nodeName] = t
                            }
                        }
                    return h
                }
                const Qs = new XMLSerializer;

                function stringifyXML(t, d = {}) {
                    var h, y, _;
                    const x = {
                            rootName: null !== (h = d.rootName) && void 0 !== h ? h : "root",
                            includeRoot: null !== (y = d.includeRoot) && void 0 !== y && y,
                            xmlCharKey: null !== (_ = d.xmlCharKey) && void 0 !== _ ? _ : E
                        },
                        C = buildNode(t, x.rootName, x)[0];
                    return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + Qs.serializeToString(C)
                }

                function buildAttributes(t) {
                    const d = [];
                    for (const h of Object.keys(t)) {
                        const y = Gs.createAttribute(h);
                        y.value = t[h].toString(), d.push(y)
                    }
                    return d
                }

                function buildNode(t, d, h) {
                    if (null == t || "string" == typeof t || "number" == typeof t || "boolean" == typeof t) {
                        const h = Gs.createElement(d);
                        return h.textContent = null == t ? "" : t.toString(), [h]
                    }
                    if (Array.isArray(t)) {
                        const y = [];
                        for (const _ of t)
                            for (const t of buildNode(_, d, h)) y.push(t);
                        return y
                    }
                    if ("object" == typeof t) {
                        const y = Gs.createElement(d);
                        for (const d of Object.keys(t))
                            if (d === C)
                                for (const h of buildAttributes(t[d])) y.attributes.setNamedItem(h);
                            else if (d === h.xmlCharKey) y.textContent = t[d].toString();
                        else
                            for (const _ of buildNode(t[d], d, h)) y.appendChild(_);
                        return [y]
                    }
                    throw new Error(`Illegal value passed to buildObject: ${t}`)
                }

                function deserializationPolicy_deserializationPolicy(t, d) {
                    return {
                        create: (h, y) => new DeserializationPolicy(h, y, t, d)
                    }
                }
                const Js = ["application/json", "text/json"],
                    Ys = ["application/xml", "application/atom+xml"];
                class DeserializationPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h, y = {}) {
                        var _;
                        super(t, d), this.jsonContentTypes = h && h.json || Js, this.xmlContentTypes = h && h.xml || Ys, this.xmlCharKey = null !== (_ = y.xmlCharKey) && void 0 !== _ ? _ : E
                    }
                    async sendRequest(t) {
                        return this._nextPolicy.sendRequest(t).then((t => function deserializeResponseBody(t, d, h, y = {}) {
                            var _, x, C;
                            const O = {
                                rootName: null !== (_ = y.rootName) && void 0 !== _ ? _ : "",
                                includeRoot: null !== (x = y.includeRoot) && void 0 !== x && x,
                                xmlCharKey: null !== (C = y.xmlCharKey) && void 0 !== C ? C : E
                            };
                            return function parse(t, d, h, y) {
                                var _;
                                const errorHandler = t => {
                                    const d = `Error "${t}" occurred while parsing the response body - ${h.bodyAsText}.`,
                                        y = t.code || RestError.PARSE_ERROR,
                                        _ = new RestError(d, y, h.status, h.request, h);
                                    return Promise.reject(_)
                                };
                                if (!(null === (_ = h.request.streamResponseStatusCodes) || void 0 === _ ? void 0 : _.has(h.status)) && !h.request.streamResponseBody && h.bodyAsText) {
                                    const _ = h.bodyAsText,
                                        x = h.headers.get("Content-Type") || "",
                                        C = x ? x.split(";").map((t => t.toLowerCase())) : [];
                                    if (0 === C.length || C.some((d => -1 !== t.indexOf(d)))) return new Promise((t => {
                                        h.parsedBody = JSON.parse(_), t(h)
                                    })).catch(errorHandler);
                                    if (C.some((t => -1 !== d.indexOf(t)))) return parseXML(_, y).then((t => (h.parsedBody = t, h))).catch(errorHandler)
                                }
                                return Promise.resolve(h)
                            }(t, d, h, O).then((t => {
                                if (! function shouldDeserializeResponse(t) {
                                        const d = t.request.shouldDeserialize;
                                        let h;
                                        h = void 0 === d || ("boolean" == typeof d ? d : d(t));
                                        return h
                                    }(t)) return t;
                                const d = t.request.operationSpec;
                                if (!d || !d.responses) return t;
                                const _ = function getOperationResponse(t) {
                                        let d;
                                        const h = t.request,
                                            y = h.operationSpec;
                                        if (y) {
                                            const _ = h.operationResponseGetter;
                                            d = _ ? _(y, t) : y.responses[t.status]
                                        }
                                        return d
                                    }(t),
                                    {
                                        error: x,
                                        shouldReturnResponse: C
                                    } = function handleErrorResponse(t, d, h) {
                                        var y;
                                        const _ = 200 <= t.status && t.status < 300;
                                        if (function isOperationSpecEmpty(t) {
                                                const d = Object.keys(t.responses);
                                                return 0 === d.length || 1 === d.length && "default" === d[0]
                                            }(d) ? _ : h) {
                                            if (!h) return {
                                                error: null,
                                                shouldReturnResponse: !1
                                            };
                                            if (!h.isError) return {
                                                error: null,
                                                shouldReturnResponse: !1
                                            }
                                        }
                                        const x = null != h ? h : d.responses.default,
                                            C = (null === (y = t.request.streamResponseStatusCodes) || void 0 === y ? void 0 : y.has(t.status)) || t.request.streamResponseBody ? `Unexpected status code: ${t.status}` : t.bodyAsText,
                                            E = new RestError(C, void 0, t.status, t.request, t);
                                        if (!x) throw E;
                                        const O = x.bodyMapper,
                                            k = x.headersMapper;
                                        try {
                                            if (t.parsedBody) {
                                                const h = t.parsedBody;
                                                let y;
                                                if (O) {
                                                    let t = h;
                                                    d.isXML && O.type.name === Xe.Sequence && (t = "object" == typeof h ? h[O.xmlElementName] : []), y = d.serializer.deserialize(O, t, "error.response.parsedBody")
                                                }
                                                const _ = h.error || y || h;
                                                E.code = _.code, _.message && (E.message = _.message), O && (E.response.parsedBody = y)
                                            }
                                            t.headers && k && (E.response.parsedHeaders = d.serializer.deserialize(k, t.headers.rawHeaders(), "operationRes.parsedHeaders"))
                                        } catch (z) {
                                            E.message = `Error "${z.message}" occurred in deserializing the responseBody - "${t.bodyAsText}" for the default response.`
                                        }
                                        return {
                                            error: E,
                                            shouldReturnResponse: !1
                                        }
                                    }(t, d, _);
                                if (x) throw x;
                                if (C) return t;
                                if (_) {
                                    if (_.bodyMapper) {
                                        let h = t.parsedBody;
                                        d.isXML && _.bodyMapper.type.name === Xe.Sequence && (h = "object" == typeof h ? h[_.bodyMapper.xmlElementName] : []);
                                        try {
                                            t.parsedBody = d.serializer.deserialize(_.bodyMapper, h, "operationRes.parsedBody", y)
                                        } catch (E) {
                                            throw new RestError(`Error ${E} occurred in deserializing the responseBody - ${t.bodyAsText}`, void 0, t.status, t.request, t)
                                        }
                                    } else "HEAD" === d.httpMethod && (t.parsedBody = h.status >= 200 && h.status < 300);
                                    _.headersMapper && (t.parsedHeaders = d.serializer.deserialize(_.headersMapper, t.headers.rawHeaders(), "operationRes.parsedHeaders", y))
                                }
                                return t
                            }))
                        }(this.jsonContentTypes, this.xmlContentTypes, t, {
                            xmlCharKey: this.xmlCharKey
                        })))
                    }
                }

                function logPolicy_logPolicy(t = {}) {
                    return {
                        create: (d, h) => new LogPolicy(d, h, t)
                    }
                }
                class LogPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, {
                        logger: h = Ds.info,
                        allowedHeaderNames: y = [],
                        allowedQueryParameters: _ = []
                    } = {}) {
                        super(t, d), this.logger = h, this.sanitizer = new Sanitizer({
                            allowedHeaderNames: y,
                            allowedQueryParameters: _
                        })
                    }
                    get allowedHeaderNames() {
                        return this.sanitizer.allowedHeaderNames
                    }
                    set allowedHeaderNames(t) {
                        this.sanitizer.allowedHeaderNames = t
                    }
                    get allowedQueryParameters() {
                        return this.sanitizer.allowedQueryParameters
                    }
                    set allowedQueryParameters(t) {
                        this.sanitizer.allowedQueryParameters = t
                    }
                    sendRequest(t) {
                        return this.logger.enabled ? (this.logRequest(t), this._nextPolicy.sendRequest(t).then((t => this.logResponse(t)))) : this._nextPolicy.sendRequest(t)
                    }
                    logRequest(t) {
                        this.logger(`Request: ${this.sanitizer.sanitize(t)}`)
                    }
                    logResponse(t) {
                        return this.logger(`Response status code: ${t.status}`), this.logger(`Headers: ${this.sanitizer.sanitize(t.headers)}`), t
                    }
                }
                const Zs = new Error("DisableResponseDecompressionPolicy is not supported in browser environment");
                const el = "2.2.3",
                    tl = {
                        HttpVerbs: {
                            PUT: "PUT",
                            GET: "GET",
                            DELETE: "DELETE",
                            POST: "POST",
                            MERGE: "MERGE",
                            HEAD: "HEAD",
                            PATCH: "PATCH"
                        },
                        StatusCodes: {
                            TooManyRequests: 429,
                            ServiceUnavailable: 503
                        }
                    },
                    rl = {
                        AUTHORIZATION: "authorization",
                        AUTHORIZATION_SCHEME: "Bearer",
                        RETRY_AFTER: "Retry-After",
                        USER_AGENT: "User-Agent"
                    };
                var nl = new WeakMap,
                    il = new WeakMap,
                    ol = function() {
                        function AbortSignal() {
                            this.onabort = null, nl.set(this, []), il.set(this, !1)
                        }
                        return Object.defineProperty(AbortSignal.prototype, "aborted", {
                            get: function() {
                                if (!il.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
                                return il.get(this)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(AbortSignal, "none", {
                            get: function() {
                                return new AbortSignal
                            },
                            enumerable: !1,
                            configurable: !0
                        }), AbortSignal.prototype.addEventListener = function(t, d) {
                            if (!nl.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
                            nl.get(this).push(d)
                        }, AbortSignal.prototype.removeEventListener = function(t, d) {
                            if (!nl.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
                            var h = nl.get(this),
                                y = h.indexOf(d);
                            y > -1 && h.splice(y, 1)
                        }, AbortSignal.prototype.dispatchEvent = function(t) {
                            throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.")
                        }, AbortSignal
                    }();

                function abortSignal(t) {
                    if (!t.aborted) {
                        t.onabort && t.onabort.call(t);
                        var d = nl.get(t);
                        d && d.slice().forEach((function(d) {
                            d.call(t, {
                                type: "abort"
                            })
                        })), il.set(t, !0)
                    }
                }
                var al = function(t) {
                    function AbortError(d) {
                        var h = t.call(this, d) || this;
                        return h.name = "AbortError", h
                    }
                    return function __extends(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Class extends value " + String(d) + " is not a constructor or null");

                        function __() {
                            this.constructor = t
                        }
                        extendStatics(t, d), t.prototype = null === d ? Object.create(d) : (__.prototype = d.prototype, new __)
                    }(AbortError, t), AbortError
                }(Error);
                ! function() {
                    function AbortController(t) {
                        var d = this;
                        if (this._signal = new ol, t) {
                            Array.isArray(t) || (t = arguments);
                            for (var h = 0, y = t; h < y.length; h++) {
                                var _ = y[h];
                                _.aborted ? this.abort() : _.addEventListener("abort", (function() {
                                    d.abort()
                                }))
                            }
                        }
                    }
                    Object.defineProperty(AbortController.prototype, "signal", {
                        get: function() {
                            return this._signal
                        },
                        enumerable: !1,
                        configurable: !0
                    }), AbortController.prototype.abort = function() {
                        abortSignal(this._signal)
                    }, AbortController.timeout = function(t) {
                        var d = new ol,
                            h = setTimeout(abortSignal, t, d);
                        return "function" == typeof h.unref && h.unref(), d
                    }
                }();

                function delay(t, d, h) {
                    return new Promise(((y, _) => {
                        let x, C;
                        const rejectOnAbort = () => _(new al((null == h ? void 0 : h.abortErrorMsg) ? null == h ? void 0 : h.abortErrorMsg : "The operation was aborted.")),
                            removeListeners = () => {
                                (null == h ? void 0 : h.abortSignal) && C && h.abortSignal.removeEventListener("abort", C)
                            };
                        if (C = () => (function isDefined(t) {
                                return null != t
                            }(x) && clearTimeout(x), removeListeners(), rejectOnAbort()), (null == h ? void 0 : h.abortSignal) && h.abortSignal.aborted) return rejectOnAbort();
                        x = setTimeout((() => {
                            removeListeners(), y(d)
                        }), t), (null == h ? void 0 : h.abortSignal) && h.abortSignal.addEventListener("abort", C)
                    }))
                }
                const sl = {
                    forcedRefreshWindowInMs: 1e3,
                    retryIntervalInMs: 3e3,
                    refreshWindowInMs: 12e4
                };

                function createTokenCycler(t, d, h) {
                    let y = null,
                        _ = null;
                    const x = Object.assign(Object.assign({}, sl), h),
                        C = {
                            get isRefreshing() {
                                return null !== y
                            },
                            get shouldRefresh() {
                                var t;
                                return !C.isRefreshing && (null !== (t = null == _ ? void 0 : _.expiresOnTimestamp) && void 0 !== t ? t : 0) - x.refreshWindowInMs < Date.now()
                            },
                            get mustRefresh() {
                                return null === _ || _.expiresOnTimestamp - x.forcedRefreshWindowInMs < Date.now()
                            }
                        };

                    function refresh(h) {
                        var E;
                        if (!C.isRefreshing) {
                            y = async function beginRefresh(t, d, h) {
                                async function tryGetAccessToken() {
                                    if (!(Date.now() < h)) {
                                        const d = await t();
                                        if (null === d) throw new Error("Failed to refresh access token.");
                                        return d
                                    }
                                    try {
                                        return await t()
                                    } catch (E) {
                                        return null
                                    }
                                }
                                let y = await tryGetAccessToken();
                                for (; null === y;) await delay(d), y = await tryGetAccessToken();
                                return y
                            }((() => t.getToken(d, h)), x.retryIntervalInMs, null !== (E = null == _ ? void 0 : _.expiresOnTimestamp) && void 0 !== E ? E : Date.now()).then((t => (y = null, _ = t, _))).catch((t => {
                                throw y = null, _ = null, t
                            }))
                        }
                        return y
                    }
                    return async t => C.mustRefresh ? refresh(t) : (C.shouldRefresh && refresh(t), _)
                }

                function bearerTokenAuthenticationPolicy(t, d) {
                    const h = createTokenCycler(t, d);
                    class BearerTokenAuthenticationPolicy extends requestPolicy_BaseRequestPolicy {
                        constructor(t, d) {
                            super(t, d)
                        }
                        async sendRequest(t) {
                            if (!t.url.toLowerCase().startsWith("https://")) throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
                            const {
                                token: d
                            } = await h({
                                abortSignal: t.abortSignal,
                                tracingOptions: {
                                    tracingContext: t.tracingContext
                                }
                            });
                            return t.headers.set(rl.AUTHORIZATION, `Bearer ${d}`), this._nextPolicy.sendRequest(t)
                        }
                    }
                    return {
                        create: (t, d) => new BearerTokenAuthenticationPolicy(t, d)
                    }
                }
                const ll = createClientLogger("storage-blob");

                function escapeURLPath(t) {
                    const d = url_URLBuilder.parse(t);
                    let h = d.getPath();
                    return h = h || "/", h = function utils_common_escape(t) {
                        return encodeURIComponent(t).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%")
                    }(h), d.setPath(h), d.toString()
                }

                function getValueInConnString(t, d) {
                    const h = t.split(";");
                    for (const y of h)
                        if (y.trim().startsWith(d)) return y.trim().match(d + "=(.*)")[1];
                    return ""
                }

                function extractConnectionStringParts(t) {
                    let d = "";
                    t.startsWith("UseDevelopmentStorage=true") && (d = function getProxyUriFromDevConnString(t) {
                        let d = "";
                        if (-1 !== t.search("DevelopmentStorageProxyUri=")) {
                            const h = t.split(";");
                            for (const t of h) t.trim().startsWith("DevelopmentStorageProxyUri=") && (d = t.trim().match("DevelopmentStorageProxyUri=(.*)")[1])
                        }
                        return d
                    }(t), t = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;");
                    let h = getValueInConnString(t, "BlobEndpoint");
                    if (h = h.endsWith("/") ? h.slice(0, -1) : h, -1 !== t.search("DefaultEndpointsProtocol=") && -1 !== t.search("AccountKey=")) {
                        let y = "",
                            _ = "",
                            x = Buffer.from("accountKey", "base64"),
                            C = "";
                        if (_ = getValueInConnString(t, "AccountName"), x = Buffer.from(getValueInConnString(t, "AccountKey"), "base64"), !h) {
                            y = getValueInConnString(t, "DefaultEndpointsProtocol");
                            const d = y.toLowerCase();
                            if ("https" !== d && "http" !== d) throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
                            if (C = getValueInConnString(t, "EndpointSuffix"), !C) throw new Error("Invalid EndpointSuffix in the provided Connection String");
                            h = `${y}://${_}.blob.${C}`
                        }
                        if (!_) throw new Error("Invalid AccountName in the provided Connection String");
                        if (0 === x.length) throw new Error("Invalid AccountKey in the provided Connection String");
                        return {
                            kind: "AccountConnString",
                            url: h,
                            accountName: _,
                            accountKey: x,
                            proxyUri: d
                        }
                    } {
                        const d = getValueInConnString(t, "SharedAccessSignature"),
                            y = getAccountNameFromUrl(h);
                        if (!h) throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
                        if (!d) throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
                        return {
                            kind: "SASConnString",
                            url: h,
                            accountName: y,
                            accountSas: d
                        }
                    }
                }

                function appendToURLPath(t, d) {
                    const h = url_URLBuilder.parse(t);
                    let y = h.getPath();
                    return y = y ? y.endsWith("/") ? `${y}${d}` : `${y}/${d}` : d, h.setPath(y), h.toString()
                }

                function setURLParameter(t, d, h) {
                    const y = url_URLBuilder.parse(t);
                    return y.setQueryParameter(d, h), y.toString()
                }

                function getURLParameter(t, d) {
                    return url_URLBuilder.parse(t).getQueryParameterValue(d)
                }

                function truncatedISO8061Date(t, d = !0) {
                    const h = t.toISOString();
                    return d ? h.substring(0, h.length - 1) + "0000Z" : h.substring(0, h.length - 5) + "Z"
                }

                function generateBlockID(t, d) {
                    t.length > 42 && (t = t.slice(0, 42));
                    return function base64encode(t) {
                        return H ? Buffer.from(t).toString("base64") : btoa(t)
                    }(t + function padStart(t, d, h = " ") {
                        if (String.prototype.padStart) return t.padStart(d, h);
                        return h = h || " ", t.length > d ? t : ((d -= t.length) > h.length && (h += h.repeat(d / h.length)), h.slice(0, d) + t)
                    }(d.toString(), 48 - t.length, "0"))
                }

                function getAccountNameFromUrl(t) {
                    const d = url_URLBuilder.parse(t);
                    let h;
                    try {
                        return h = "blob" === d.getHost().split(".")[1] ? d.getHost().split(".")[0] : isIpEndpointStyle(d) ? d.getPath().split("/")[1] : "", h
                    } catch (y) {
                        throw new Error("Unable to extract accountName with provided information.")
                    }
                }

                function isIpEndpointStyle(t) {
                    if (void 0 === t.getHost()) return !1;
                    const d = t.getHost() + (void 0 === t.getPort() ? "" : ":" + t.getPort());
                    return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(d)
                }

                function toBlobTagsString(t) {
                    if (void 0 === t) return;
                    const d = [];
                    for (const h in t)
                        if (Object.prototype.hasOwnProperty.call(t, h)) {
                            const y = t[h];
                            d.push(`${encodeURIComponent(h)}=${encodeURIComponent(y)}`)
                        } return d.join("&")
                }

                function toBlobTags(t) {
                    if (void 0 === t) return;
                    const d = {
                        blobTagSet: []
                    };
                    for (const h in t)
                        if (Object.prototype.hasOwnProperty.call(t, h)) {
                            const y = t[h];
                            d.blobTagSet.push({
                                key: h,
                                value: y
                            })
                        } return d
                }

                function toTags(t) {
                    if (void 0 === t) return;
                    const d = {};
                    for (const h of t.blobTagSet) d[h.key] = h.value;
                    return d
                }

                function toQuerySerialization(t) {
                    if (void 0 !== t) switch (t.kind) {
                        case "csv":
                            return {
                                format: {
                                    type: "delimited",
                                    delimitedTextConfiguration: {
                                        columnSeparator: t.columnSeparator || ",",
                                        fieldQuote: t.fieldQuote || "",
                                        recordSeparator: t.recordSeparator,
                                        escapeChar: t.escapeCharacter || "",
                                        headersPresent: t.hasHeaders || !1
                                    }
                                }
                            };
                        case "json":
                            return {
                                format: {
                                    type: "json",
                                    jsonTextConfiguration: {
                                        recordSeparator: t.recordSeparator
                                    }
                                }
                            };
                        case "arrow":
                            return {
                                format: {
                                    type: "arrow",
                                    arrowConfiguration: {
                                        schema: t.schema
                                    }
                                }
                            };
                        case "parquet":
                            return {
                                format: {
                                    type: "parquet"
                                }
                            };
                        default:
                            throw Error("Invalid BlobQueryTextConfiguration.")
                    }
                }

                function parseObjectReplicationRecord(t) {
                    if (!t) return;
                    if ("policy-id" in t) return;
                    const d = [];
                    for (const h in t) {
                        const y = h.split("_"),
                            _ = "or-";
                        y[0].startsWith(_) && (y[0] = y[0].substring(_.length));
                        const x = {
                                ruleId: y[1],
                                replicationStatus: t[h]
                            },
                            C = d.findIndex((t => t.policyId === y[0]));
                        C > -1 ? d[C].rules.push(x) : d.push({
                            policyId: y[0],
                            rules: [x]
                        })
                    }
                    return d
                }

                function httpAuthorizationToString(t) {
                    return t ? t.scheme + " " + t.value : void 0
                }
                class StorageBrowserPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d) {
                        super(t, d)
                    }
                    async sendRequest(t) {
                        return H || ("GET" !== t.method.toUpperCase() && "HEAD" !== t.method.toUpperCase() || (t.url = setURLParameter(t.url, gs.FORCE_BROWSER_NO_CACHE, (new Date).getTime().toString())), t.headers.remove(vs), t.headers.remove(bs)), this._nextPolicy.sendRequest(t)
                    }
                }
                class StorageBrowserPolicyFactory {
                    create(t, d) {
                        return new StorageBrowserPolicy(t, d)
                    }
                }
                var cl;
                ! function(t) {
                    t[t.EXPONENTIAL = 0] = "EXPONENTIAL", t[t.FIXED = 1] = "FIXED"
                }(cl || (cl = {}));
                const ul = {
                        maxRetryDelayInMs: 12e4,
                        maxTries: 4,
                        retryDelayInMs: 4e3,
                        retryPolicyType: cl.EXPONENTIAL,
                        secondaryHost: "",
                        tryTimeoutInMs: void 0
                    },
                    dl = new al("The operation was aborted.");
                class StorageRetryPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h = ul) {
                        super(t, d), this.retryOptions = {
                            retryPolicyType: h.retryPolicyType ? h.retryPolicyType : ul.retryPolicyType,
                            maxTries: h.maxTries && h.maxTries >= 1 ? Math.floor(h.maxTries) : ul.maxTries,
                            tryTimeoutInMs: h.tryTimeoutInMs && h.tryTimeoutInMs >= 0 ? h.tryTimeoutInMs : ul.tryTimeoutInMs,
                            retryDelayInMs: h.retryDelayInMs && h.retryDelayInMs >= 0 ? Math.min(h.retryDelayInMs, h.maxRetryDelayInMs ? h.maxRetryDelayInMs : ul.maxRetryDelayInMs) : ul.retryDelayInMs,
                            maxRetryDelayInMs: h.maxRetryDelayInMs && h.maxRetryDelayInMs >= 0 ? h.maxRetryDelayInMs : ul.maxRetryDelayInMs,
                            secondaryHost: h.secondaryHost ? h.secondaryHost : ul.secondaryHost
                        }
                    }
                    async sendRequest(t) {
                        return this.attemptSendRequest(t, !1, 1)
                    }
                    async attemptSendRequest(t, d, h) {
                        const y = t.clone(),
                            _ = d || !this.retryOptions.secondaryHost || !("GET" === t.method || "HEAD" === t.method || "OPTIONS" === t.method) || h % 2 == 1;
                        let x;
                        _ || (y.url = function setURLHost(t, d) {
                            const h = url_URLBuilder.parse(t);
                            return h.setHost(d), h.toString()
                        }(y.url, this.retryOptions.secondaryHost)), this.retryOptions.tryTimeoutInMs && (y.url = setURLParameter(y.url, gs.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1e3).toString()));
                        try {
                            if (ll.info(`RetryPolicy: =====> Try=${h} ${_?"Primary":"Secondary"}`), x = await this._nextPolicy.sendRequest(y), !this.shouldRetry(_, h, x)) return x;
                            d = d || !_ && 404 === x.status
                        } catch (C) {
                            if (ll.error(`RetryPolicy: Caught error, message: ${C.message}, code: ${C.code}`), !this.shouldRetry(_, h, x, C)) throw C
                        }
                        return await this.delay(_, h, t.abortSignal), this.attemptSendRequest(t, d, ++h)
                    }
                    shouldRetry(t, d, h, y) {
                        if (d >= this.retryOptions.maxTries) return ll.info(`RetryPolicy: Attempt(s) ${d} >= maxTries ${this.retryOptions.maxTries}, no further try.`), !1;
                        const _ = ["ETIMEDOUT", "ESOCKETTIMEDOUT", "ECONNREFUSED", "ECONNRESET", "ENOENT", "ENOTFOUND", "TIMEOUT", "EPIPE", "REQUEST_SEND_ERROR"];
                        if (y)
                            for (const x of _)
                                if (y.name.toUpperCase().includes(x) || y.message.toUpperCase().includes(x) || y.code && y.code.toString().toUpperCase() === x) return ll.info(`RetryPolicy: Network error ${x} found, will retry.`), !0;
                        if (h || y) {
                            const d = h ? h.status : y ? y.statusCode : 0;
                            if (!t && 404 === d) return ll.info("RetryPolicy: Secondary access with 404, will retry."), !0;
                            if (503 === d || 500 === d) return ll.info(`RetryPolicy: Will retry for status code ${d}.`), !0
                        }
                        return !("PARSE_ERROR" !== (null == y ? void 0 : y.code) || !(null == y ? void 0 : y.message.startsWith('Error "Error: Unclosed root tag'))) && (ll.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0)
                    }
                    async delay(t, d, h) {
                        let y = 0;
                        if (t) switch (this.retryOptions.retryPolicyType) {
                            case cl.EXPONENTIAL:
                                y = Math.min((Math.pow(2, d - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
                                break;
                            case cl.FIXED:
                                y = this.retryOptions.retryDelayInMs
                        } else y = 1e3 * Math.random();
                        return ll.info(`RetryPolicy: Delay for ${y}ms`), async function utils_common_delay(t, d, h) {
                            return new Promise(((y, _) => {
                                let x;
                                const abortHandler = () => {
                                    void 0 !== x && clearTimeout(x), _(h)
                                };
                                x = setTimeout((() => {
                                    void 0 !== d && d.removeEventListener("abort", abortHandler), y()
                                }), t), void 0 !== d && d.addEventListener("abort", abortHandler)
                            }))
                        }(y, h, dl)
                    }
                }
                class StorageRetryPolicyFactory {
                    constructor(t) {
                        this.retryOptions = t
                    }
                    create(t, d) {
                        return new StorageRetryPolicy(t, d, this.retryOptions)
                    }
                }
                var pl = h(4598);

                function getHeaderKey(t) {
                    return t.toLowerCase()
                }

                function isHttpHeadersLike(t) {
                    if (t && "object" == typeof t) {
                        const d = t;
                        if ("function" == typeof d.rawHeaders && "function" == typeof d.clone && "function" == typeof d.get && "function" == typeof d.set && "function" == typeof d.contains && "function" == typeof d.remove && "function" == typeof d.headersArray && "function" == typeof d.headerValues && "function" == typeof d.headerNames && "function" == typeof d.toJson) return !0
                    }
                    return !1
                }
                class httpHeaders_HttpHeaders {
                    constructor(t) {
                        if (this._headersMap = {}, t)
                            for (const d in t) this.set(d, t[d])
                    }
                    set(t, d) {
                        this._headersMap[getHeaderKey(t)] = {
                            name: t,
                            value: d.toString()
                        }
                    }
                    get(t) {
                        const d = this._headersMap[getHeaderKey(t)];
                        return d ? d.value : void 0
                    }
                    contains(t) {
                        return !!this._headersMap[getHeaderKey(t)]
                    }
                    remove(t) {
                        const d = this.contains(t);
                        return delete this._headersMap[getHeaderKey(t)], d
                    }
                    rawHeaders() {
                        return this.toJson({
                            preserveCase: !0
                        })
                    }
                    headersArray() {
                        const t = [];
                        for (const d in this._headersMap) t.push(this._headersMap[d]);
                        return t
                    }
                    headerNames() {
                        const t = [],
                            d = this.headersArray();
                        for (let h = 0; h < d.length; ++h) t.push(d[h].name);
                        return t
                    }
                    headerValues() {
                        const t = [],
                            d = this.headersArray();
                        for (let h = 0; h < d.length; ++h) t.push(d[h].value);
                        return t
                    }
                    toJson(t = {}) {
                        const d = {};
                        if (t.preserveCase)
                            for (const h in this._headersMap) {
                                const t = this._headersMap[h];
                                d[t.name] = t.value
                            } else
                                for (const h in this._headersMap) {
                                    const t = this._headersMap[h];
                                    d[getHeaderKey(t.name)] = t.value
                                }
                        return d
                    }
                    toString() {
                        return JSON.stringify(this.toJson({
                            preserveCase: !0
                        }))
                    }
                    clone() {
                        const t = {};
                        for (const d in this._headersMap) {
                            const h = this._headersMap[d];
                            t[h.name] = h.value
                        }
                        return new httpHeaders_HttpHeaders(t)
                    }
                }
                class TelemetryPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h) {
                        super(t, d), this.telemetry = h
                    }
                    async sendRequest(t) {
                        return H && (t.headers || (t.headers = new httpHeaders_HttpHeaders), t.headers.get(_s) || t.headers.set(_s, this.telemetry)), this._nextPolicy.sendRequest(t)
                    }
                }
                class TelemetryPolicyFactory {
                    constructor(t) {
                        const d = [];
                        if (H) {
                            if (t) {
                                const h = t.userAgentPrefix || "";
                                h.length > 0 && -1 === d.indexOf(h) && d.push(h)
                            }
                            const h = "azsdk-js-storageblob/12.8.0"; - 1 === d.indexOf(h) && d.push(h);
                            const y = `(NODE-VERSION ${process.version}; ${pl.type()} ${pl.release()})`; - 1 === d.indexOf(y) && d.push(y)
                        }
                        this.telemetryString = d.join(" ")
                    }
                    create(t, d) {
                        return new TelemetryPolicy(t, d, this.telemetryString)
                    }
                }
                class XhrHttpClient {
                    sendRequest(t) {
                        var d;
                        const h = new XMLHttpRequest;
                        if (t.proxySettings) throw new Error("HTTP proxy is not supported in browser environment");
                        const y = t.abortSignal;
                        if (y) {
                            if (y.aborted) return Promise.reject(new al("The operation was aborted."));
                            const listener = () => {
                                h.abort()
                            };
                            y.addEventListener("abort", listener), h.addEventListener("readystatechange", (() => {
                                h.readyState === XMLHttpRequest.DONE && y.removeEventListener("abort", listener)
                            }))
                        }
                        if (addProgressListener(h.upload, t.onUploadProgress), addProgressListener(h, t.onDownloadProgress), t.formData) {
                            const d = t.formData,
                                h = new FormData,
                                appendFormValue = (t, d) => {
                                    d && Object.prototype.hasOwnProperty.call(d, "value") && Object.prototype.hasOwnProperty.call(d, "options") ? h.append(t, d.value, d.options) : h.append(t, d)
                                };
                            for (const t of Object.keys(d)) {
                                const h = d[t];
                                if (Array.isArray(h))
                                    for (let d = 0; d < h.length; d++) appendFormValue(t, h[d]);
                                else appendFormValue(t, h)
                            }
                            t.body = h, t.formData = void 0;
                            const y = t.headers.get("Content-Type");
                            y && -1 !== y.indexOf("multipart/form-data") && t.headers.remove("Content-Type")
                        }
                        h.open(t.method, t.url), h.timeout = t.timeout, h.withCredentials = t.withCredentials;
                        for (const _ of t.headers.headersArray()) h.setRequestHeader(_.name, _.value);
                        return h.responseType = (null === (d = t.streamResponseStatusCodes) || void 0 === d ? void 0 : d.size) || t.streamResponseBody ? "blob" : "text", h.send(void 0 === t.body ? null : t.body), "blob" === h.responseType ? new Promise(((d, y) => {
                            ! function handleBlobResponse(t, d, h, y) {
                                t.addEventListener("readystatechange", (() => {
                                    var _;
                                    if (t.readyState === XMLHttpRequest.HEADERS_RECEIVED)
                                        if (d.streamResponseBody || (null === (_ = d.streamResponseStatusCodes) || void 0 === _ ? void 0 : _.has(t.status))) {
                                            const y = new Promise(((h, y) => {
                                                t.addEventListener("load", (() => {
                                                    h(t.response)
                                                })), rejectOnTerminalEvent(d, t, y)
                                            }));
                                            h({
                                                request: d,
                                                status: t.status,
                                                headers: parseHeaders(t),
                                                blobBody: y
                                            })
                                        } else t.addEventListener("load", (() => {
                                            if (t.response) {
                                                const _ = new FileReader;
                                                _.onload = function(y) {
                                                    var _;
                                                    const x = null === (_ = y.target) || void 0 === _ ? void 0 : _.result;
                                                    h({
                                                        request: d,
                                                        status: t.status,
                                                        headers: parseHeaders(t),
                                                        bodyAsText: x
                                                    })
                                                }, _.onerror = function(t) {
                                                    y(_.error)
                                                }, _.readAsText(t.response, "UTF-8")
                                            } else h({
                                                request: d,
                                                status: t.status,
                                                headers: parseHeaders(t)
                                            })
                                        }))
                                }))
                            }(h, t, d, y), rejectOnTerminalEvent(t, h, y)
                        })) : new Promise((function(d, y) {
                            h.addEventListener("load", (() => d({
                                request: t,
                                status: h.status,
                                headers: parseHeaders(h),
                                bodyAsText: h.responseText
                            }))), rejectOnTerminalEvent(t, h, y)
                        }))
                    }
                }

                function addProgressListener(t, d) {
                    d && t.addEventListener("progress", (t => d({
                        loadedBytes: t.loaded
                    })))
                }

                function parseHeaders(t) {
                    const d = new httpHeaders_HttpHeaders,
                        h = t.getAllResponseHeaders().trim().split(/[\r\n]+/);
                    for (const y of h) {
                        const t = y.indexOf(":"),
                            h = y.slice(0, t),
                            _ = y.slice(t + 2);
                        d.set(h, _)
                    }
                    return d
                }

                function rejectOnTerminalEvent(t, d, h) {
                    d.addEventListener("error", (() => h(new RestError(`Failed to send request to ${t.url}`, RestError.REQUEST_SEND_ERROR, void 0, t))));
                    const y = new al("The operation was aborted.");
                    d.addEventListener("abort", (() => h(y))), d.addEventListener("timeout", (() => h(y)))
                }
                const ml = new XhrHttpClient;

                function isPipelineLike(t) {
                    if (!t || "object" != typeof t) return !1;
                    const d = t;
                    return Array.isArray(d.factories) && "object" == typeof d.options && "function" == typeof d.toServiceClientOptions
                }
                class Pipeline {
                    constructor(t, d = {}) {
                        this.factories = t, this.options = Object.assign(Object.assign({}, d), {
                            httpClient: d.httpClient || ml
                        })
                    }
                    toServiceClientOptions() {
                        return {
                            httpClient: this.options.httpClient,
                            requestPolicyFactories: this.factories
                        }
                    }
                }

                function newPipeline(t, d = {}) {
                    void 0 === t && (t = new AnonymousCredential);
                    const h = new TelemetryPolicyFactory(d.userAgentOptions),
                        y = [tracingPolicy_tracingPolicy({
                            userAgent: h.telemetryString
                        }), (_ = d.keepAliveOptions, {
                            create: (t, d) => new KeepAlivePolicy(t, d, _ || Fs)
                        }), h, generateClientRequestIdPolicy_generateClientRequestIdPolicy(), new StorageBrowserPolicyFactory, new StorageRetryPolicyFactory(d.retryOptions), deserializationPolicy_deserializationPolicy(void 0, {
                            xmlCharKey: "#"
                        }), logPolicy_logPolicy({
                            logger: ll.info,
                            allowedHeaderNames: Ns,
                            allowedQueryParameters: Ps
                        })];
                    var _;
                    return H && (y.push(proxyPolicy_browser_proxyPolicy(d.proxyOptions)), y.push(function disableResponseDecompressionPolicy_browser_disableResponseDecompressionPolicy() {
                        return {
                            create: (t, d) => {
                                throw Zs
                            }
                        }
                    }())), y.push(isTokenCredential(t) ? function attachCredential(t, d) {
                        return t.credential = d, t
                    }(bearerTokenAuthenticationPolicy(t, "https://storage.azure.com/.default"), t) : t), new Pipeline(y, d)
                }
                class PollerStoppedError extends Error {
                    constructor(t) {
                        super(t), this.name = "PollerStoppedError", Object.setPrototypeOf(this, PollerStoppedError.prototype)
                    }
                }
                class PollerCancelledError extends Error {
                    constructor(t) {
                        super(t), this.name = "PollerCancelledError", Object.setPrototypeOf(this, PollerCancelledError.prototype)
                    }
                }
                class BlobBeginCopyFromUrlPoller extends class Poller {
                    constructor(t) {
                        this.stopped = !0, this.pollProgressCallbacks = [], this.operation = t, this.promise = new Promise(((t, d) => {
                            this.resolve = t, this.reject = d
                        })), this.promise.catch((() => {}))
                    }
                    async startPolling() {
                        for (this.stopped && (this.stopped = !1); !this.isStopped() && !this.isDone();) await this.poll(), await this.delay()
                    }
                    async pollOnce(t = {}) {
                        try {
                            this.isDone() || (this.operation = await this.operation.update({
                                abortSignal: t.abortSignal,
                                fireProgress: this.fireProgress.bind(this)
                            }), this.isDone() && this.resolve && this.resolve(this.operation.state.result))
                        } catch (d) {
                            throw this.operation.state.error = d, this.reject && this.reject(d), d
                        }
                    }
                    fireProgress(t) {
                        for (const d of this.pollProgressCallbacks) d(t)
                    }
                    async cancelOnce(t = {}) {
                        this.operation = await this.operation.cancel(t), this.reject && this.reject(new PollerCancelledError("Poller cancelled"))
                    }
                    poll(t = {}) {
                        if (!this.pollOncePromise) {
                            this.pollOncePromise = this.pollOnce(t);
                            const clearPollOncePromise = () => {
                                this.pollOncePromise = void 0
                            };
                            this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject)
                        }
                        return this.pollOncePromise
                    }
                    async pollUntilDone() {
                        return this.stopped && this.startPolling().catch(this.reject), this.promise
                    }
                    onProgress(t) {
                        return this.pollProgressCallbacks.push(t), () => {
                            this.pollProgressCallbacks = this.pollProgressCallbacks.filter((d => d !== t))
                        }
                    }
                    isDone() {
                        const t = this.operation.state;
                        return Boolean(t.isCompleted || t.isCancelled || t.error)
                    }
                    stopPolling() {
                        this.stopped || (this.stopped = !0, this.reject && this.reject(new PollerStoppedError("This poller is already stopped")))
                    }
                    isStopped() {
                        return this.stopped
                    }
                    cancelOperation(t = {}) {
                        if (this.stopped || (this.stopped = !0), this.cancelPromise) {
                            if (t.abortSignal) throw new Error("A cancel request is currently pending")
                        } else this.cancelPromise = this.cancelOnce(t);
                        return this.cancelPromise
                    }
                    getOperationState() {
                        return this.operation.state
                    }
                    getResult() {
                        return this.operation.state.result
                    }
                    toString() {
                        return this.operation.toString()
                    }
                } {
                    constructor(t) {
                        const {
                            blobClient: d,
                            copySource: h,
                            intervalInMs: y = 15e3,
                            onProgress: _,
                            resumeFrom: x,
                            startCopyFromURLOptions: C
                        } = t;
                        let E;
                        x && (E = JSON.parse(x).state);
                        super(makeBlobBeginCopyFromURLPollOperation(Object.assign(Object.assign({}, E), {
                            blobClient: d,
                            copySource: h,
                            startCopyFromURLOptions: C
                        }))), "function" == typeof _ && this.onProgress(_), this.intervalInMs = y
                    }
                    delay() {
                        return delay(this.intervalInMs)
                    }
                }
                const fl = async function cancel(t = {}) {
                    const d = this.state,
                        {
                            copyId: h
                        } = d;
                    return d.isCompleted ? makeBlobBeginCopyFromURLPollOperation(d) : h ? (await d.blobClient.abortCopyFromURL(h, {
                        abortSignal: t.abortSignal
                    }), d.isCancelled = !0, makeBlobBeginCopyFromURLPollOperation(d)) : (d.isCancelled = !0, makeBlobBeginCopyFromURLPollOperation(d))
                }, hl = async function update(t = {}) {
                    const d = this.state,
                        {
                            blobClient: h,
                            copySource: y,
                            startCopyFromURLOptions: _
                        } = d;
                    if (d.isStarted) {
                        if (!d.isCompleted) try {
                            const h = await d.blobClient.getProperties({
                                    abortSignal: t.abortSignal
                                }),
                                {
                                    copyStatus: y,
                                    copyProgress: _
                                } = h,
                                x = d.copyProgress;
                            _ && (d.copyProgress = _), "pending" === y && _ !== x && "function" == typeof t.fireProgress ? t.fireProgress(d) : "success" === y ? (d.result = h, d.isCompleted = !0) : "failed" === y && (d.error = new Error(`Blob copy failed with reason: "${h.copyStatusDescription||"unknown"}"`), d.isCompleted = !0)
                        } catch (x) {
                            d.error = x, d.isCompleted = !0
                        }
                    } else {
                        d.isStarted = !0;
                        const t = await h.startCopyFromURL(y, _);
                        d.copyId = t.copyId, "success" === t.copyStatus && (d.result = t, d.isCompleted = !0)
                    }
                    return makeBlobBeginCopyFromURLPollOperation(d)
                }, yl = function toString() {
                    return JSON.stringify({
                        state: this.state
                    }, ((t, d) => {
                        if ("blobClient" !== t) return d
                    }))
                };

                function makeBlobBeginCopyFromURLPollOperation(t) {
                    return {
                        state: Object.assign({}, t),
                        cancel: fl,
                        toString: yl,
                        update: hl
                    }
                }

                function rangeToString(t) {
                    if (t.offset < 0) throw new RangeError("Range.offset cannot be smaller than 0.");
                    if (t.count && t.count <= 0) throw new RangeError("Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.");
                    return t.count ? `bytes=${t.offset}-${t.offset+t.count-1}` : `bytes=${t.offset}-`
                }
                const gl = ["GET", "HEAD"];
                class RedirectPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h = 20) {
                        super(t, d), this.maxRetries = h
                    }
                    sendRequest(t) {
                        return this._nextPolicy.sendRequest(t).then((t => handleRedirect(this, t, 0)))
                    }
                }

                function handleRedirect(t, d, h) {
                    const {
                        request: y,
                        status: _
                    } = d, x = d.headers.get("location");
                    if (x && (300 === _ || 301 === _ && gl.includes(y.method) || 302 === _ && gl.includes(y.method) || 303 === _ && "POST" === y.method || 307 === _) && (!t.maxRetries || h < t.maxRetries)) {
                        const d = url_URLBuilder.parse(y.url);
                        return d.setPath(x), y.url = d.toString(), 303 === _ && (y.method = "GET", delete y.body), t._nextPolicy.sendRequest(y).then((d => handleRedirect(t, d, h + 1)))
                    }
                    return Promise.resolve(d)
                }
                const bl = 3e4,
                    vl = 9e4;

                function isNumber(t) {
                    return "number" == typeof t
                }

                function shouldRetry(t, d, h, y, _) {
                    return !!d(y, _) && h.retryCount < t
                }

                function updateRetryData(t, d = {
                    retryCount: 0,
                    retryInterval: 0
                }, h) {
                    h && (d.error && (h.innerError = d.error), d.error = h), d.retryCount++;
                    let y = Math.pow(2, d.retryCount - 1) - 1;
                    return y *= .8 * t.retryInterval + Math.floor(Math.random() * (.4 * t.retryInterval)), d.retryInterval = Math.min(t.minRetryInterval + y, t.maxRetryInterval), d
                }
                var _l;
                ! function(t) {
                    t[t.Exponential = 0] = "Exponential"
                }(_l || (_l = {}));
                class ExponentialRetryPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h, y, _) {
                        super(t, d), this.retryCount = isNumber(h) ? h : 3, this.retryInterval = isNumber(y) ? y : bl, this.maxRetryInterval = isNumber(_) ? _ : vl
                    }
                    sendRequest(t) {
                        return this._nextPolicy.sendRequest(t.clone()).then((d => retry(this, t, d))).catch((d => retry(this, t, d.response, void 0, d)))
                    }
                }
                async function retry(t, d, h, y, _) {
                    y = updateRetryData({
                        retryInterval: t.retryInterval,
                        minRetryInterval: 0,
                        maxRetryInterval: t.maxRetryInterval
                    }, y, _);
                    const x = d.abortSignal && d.abortSignal.aborted;
                    if (x || !shouldRetry(t.retryCount, (function shouldPolicyRetry(t) {
                            const d = null == t ? void 0 : t.status;
                            return (503 !== d || !(null == h ? void 0 : h.headers.get(rl.RETRY_AFTER))) && !(void 0 === d || d < 500 && 408 !== d || 501 === d || 505 === d)
                        }), y, h)) {
                        if (x || _ || !h) {
                            throw y.error || new RestError("Failed to send the request.", RestError.REQUEST_SEND_ERROR, h && h.status, h && h.request, h)
                        }
                        return h
                    }
                    Ds.info(`Retrying request in ${y.retryInterval}`);
                    try {
                        await delay(y.retryInterval);
                        const h = await t._nextPolicy.sendRequest(d.clone());
                        return retry(t, d, h, y)
                    } catch (C) {
                        return retry(t, d, h, y, C)
                    }
                }

                function getPathStringFromParameter(t) {
                    return getPathStringFromParameterPath(t.parameterPath, t.mapper)
                }

                function getPathStringFromParameterPath(t, d) {
                    let h;
                    return h = "string" == typeof t ? t : Array.isArray(t) ? t.join(".") : d.serializedName, h
                }
                class WebResource {
                    constructor(t, d, h, y, _, x, C, E, O, k, z, A, B, I, q) {
                        this.streamResponseBody = x, this.streamResponseStatusCodes = q, this.url = t || "", this.method = d || "GET", this.headers = isHttpHeadersLike(_) ? _ : new httpHeaders_HttpHeaders(_), this.body = h, this.query = y, this.formData = void 0, this.withCredentials = C || !1, this.abortSignal = E, this.timeout = O || 0, this.onUploadProgress = k, this.onDownloadProgress = z, this.proxySettings = A, this.keepAlive = B, this.decompressResponse = I, this.requestId = this.headers.get("x-ms-client-request-id") || generateUuid()
                    }
                    validateRequestProperties() {
                        if (!this.method) throw new Error("WebResource.method is required.");
                        if (!this.url) throw new Error("WebResource.url is required.")
                    }
                    prepare(t) {
                        if (!t) throw new Error("options object is required");
                        if (void 0 === t.method || null === t.method || "string" != typeof t.method.valueOf()) throw new Error("options.method must be a string.");
                        if (t.url && t.pathTemplate) throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
                        if (!(void 0 !== t.pathTemplate && null !== t.pathTemplate && "string" == typeof t.pathTemplate.valueOf() || void 0 !== t.url && null !== t.url && "string" == typeof t.url.valueOf())) throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
                        if (t.url) {
                            if ("string" != typeof t.url) throw new Error('options.url must be of type "string".');
                            this.url = t.url
                        }
                        if (t.method) {
                            const d = ["GET", "PUT", "HEAD", "DELETE", "OPTIONS", "POST", "PATCH", "TRACE"];
                            if (-1 === d.indexOf(t.method.toUpperCase())) throw new Error('The provided method "' + t.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(d))
                        }
                        if (this.method = t.method.toUpperCase(), t.pathTemplate) {
                            const {
                                pathTemplate: d,
                                pathParameters: h
                            } = t;
                            if ("string" != typeof d) throw new Error('options.pathTemplate must be of type "string".');
                            t.baseUrl || (t.baseUrl = "https://management.azure.com");
                            const y = t.baseUrl;
                            let _ = y + (y.endsWith("/") ? "" : "/") + (d.startsWith("/") ? d.slice(1) : d);
                            const x = _.match(/({[\w-]*\s*[\w-]*})/gi);
                            if (x && x.length) {
                                if (!h) throw new Error(`pathTemplate: ${d} has been provided. Hence, options.pathParameters must also be provided.`);
                                x.forEach((function(t) {
                                    const y = t.slice(1, -1),
                                        x = h[y];
                                    if (null == x || "string" != typeof x && "object" != typeof x) {
                                        const t = JSON.stringify(h, void 0, 2);
                                        throw new Error(`pathTemplate: ${d} contains the path parameter ${y} however, it is not present in parameters: ${t}.The value of the path parameter can either be a "string" of the form { ${y}: "some sample value" } or it can be an "object" of the form { "${y}": { value: "some sample value", skipUrlEncoding: true } }.`)
                                    }
                                    if ("string" == typeof x.valueOf() && (_ = _.replace(t, encodeURIComponent(x))), "object" == typeof x.valueOf()) {
                                        if (!x.value) throw new Error(`options.pathParameters[${y}] is of type "object" but it does not contain a "value" property.`);
                                        _ = x.skipUrlEncoding ? _.replace(t, x.value) : _.replace(t, encodeURIComponent(x.value))
                                    }
                                }))
                            }
                            this.url = _
                        }
                        if (t.queryParameters) {
                            const d = t.queryParameters;
                            if ("object" != typeof d) throw new Error('options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.');
                            this.url && -1 === this.url.indexOf("?") && (this.url += "?");
                            const h = [];
                            this.query = {};
                            for (const t in d) {
                                const y = d[t];
                                if (y)
                                    if ("string" == typeof y) h.push(t + "=" + encodeURIComponent(y)), this.query[t] = encodeURIComponent(y);
                                    else if ("object" == typeof y) {
                                    if (!y.value) throw new Error(`options.queryParameters[${t}] is of type "object" but it does not contain a "value" property.`);
                                    y.skipUrlEncoding ? (h.push(t + "=" + y.value), this.query[t] = y.value) : (h.push(t + "=" + encodeURIComponent(y.value)), this.query[t] = encodeURIComponent(y.value))
                                }
                            }
                            this.url += h.join("&")
                        }
                        if (t.headers) {
                            const d = t.headers;
                            for (const h of Object.keys(t.headers)) this.headers.set(h, d[h])
                        }
                        return this.headers.get("accept-language") || this.headers.set("accept-language", "en-US"), this.headers.get("x-ms-client-request-id") || t.disableClientRequestId || this.headers.set("x-ms-client-request-id", this.requestId), this.headers.get("Content-Type") || this.headers.set("Content-Type", "application/json; charset=utf-8"), this.body = t.body, void 0 !== t.body && null !== t.body && (t.bodyIsStream ? (this.headers.get("Transfer-Encoding") || this.headers.set("Transfer-Encoding", "chunked"), "application/octet-stream" !== this.headers.get("Content-Type") && this.headers.set("Content-Type", "application/octet-stream")) : (t.serializationMapper && (this.body = new Serializer(t.mappers).serialize(t.serializationMapper, t.body, "requestBody")), t.disableJsonStringifyOnBody || (this.body = JSON.stringify(t.body)))), t.spanOptions && (this.spanOptions = t.spanOptions), t.tracingContext && (this.tracingContext = t.tracingContext), this.abortSignal = t.abortSignal, this.onDownloadProgress = t.onDownloadProgress, this.onUploadProgress = t.onUploadProgress, this
                    }
                    clone() {
                        const t = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes);
                        return this.formData && (t.formData = this.formData), this.operationSpec && (t.operationSpec = this.operationSpec), this.shouldDeserialize && (t.shouldDeserialize = this.shouldDeserialize), this.operationResponseGetter && (t.operationResponseGetter = this.operationResponseGetter), t
                    }
                }

                function getDefaultUserAgentKey() {
                    return "x-ms-useragent"
                }
                const xl = getDefaultUserAgentKey;

                function userAgentPolicy_getDefaultUserAgentValue() {
                    const t = function getRuntimeInfo() {
                            return [{
                                key: "core-http",
                                value: el
                            }]
                        }(),
                        d = function getPlatformSpecificData() {
                            const t = self.navigator;
                            return [{
                                key: "OS",
                                value: (t.oscpu || t.platform).replace(" ", "")
                            }]
                        }();
                    return function getUserAgentString(t, d = " ", h = "/") {
                        return t.map((t => {
                            const d = t.value ? `${h}${t.value}` : "";
                            return `${t.key}${d}`
                        })).join(d)
                    }(t.concat(d))
                }
                class UserAgentPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h, y) {
                        super(t, d), this._nextPolicy = t, this._options = d, this.headerKey = h, this.headerValue = y
                    }
                    sendRequest(t) {
                        return this.addUserAgentHeader(t), this._nextPolicy.sendRequest(t)
                    }
                    addUserAgentHeader(t) {
                        t.headers || (t.headers = new httpHeaders_HttpHeaders), !t.headers.get(this.headerKey) && this.headerValue && t.headers.set(this.headerKey, this.headerValue)
                    }
                }
                const Nl = URL;
                let Pl;
                class RPRegistrationPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h = 30) {
                        super(t, d), this._retryTimeout = h
                    }
                    sendRequest(t) {
                        return this._nextPolicy.sendRequest(t.clone()).then((d => function registerIfNeeded(t, d, h) {
                            if (409 === h.status) {
                                const y = function checkRPNotRegisteredError(t) {
                                    let d, h;
                                    if (t) {
                                        try {
                                            h = JSON.parse(t)
                                        } catch (y) {}
                                        if (h && h.error && h.error.message && h.error.code && "MissingSubscriptionRegistration" === h.error.code) {
                                            const t = h.error.message.match(/.*'(.*)'/i);
                                            t && (d = t.pop())
                                        }
                                    }
                                    return d
                                }(h.bodyAsText);
                                if (y) {
                                    const _ = function extractSubscriptionUrl(t) {
                                        let d;
                                        const h = t.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
                                        if (!h || !h[0]) throw new Error(`Unable to extract subscriptionId from the given url - ${t}.`);
                                        d = h[0];
                                        return d
                                    }(d.url);
                                    return async function registerRP(t, d, h, y) {
                                        const _ = `${d}providers/${h}/register?api-version=2016-02-01`,
                                            x = `${d}providers/${h}?api-version=2016-02-01`,
                                            C = getRequestEssentials(y);
                                        C.method = "POST", C.url = _;
                                        if (200 !== (await t._nextPolicy.sendRequest(C)).status) throw new Error(`Autoregistration of ${h} failed. Please try registering manually.`);
                                        return getRegistrationStatus(t, x, y)
                                    }(t, _, y, d).catch((() => !1)).then((y => y ? (d.headers.set("x-ms-client-request-id", generateUuid()), t._nextPolicy.sendRequest(d.clone())) : h))
                                }
                            }
                            return Promise.resolve(h)
                        }(this, t, d)))
                    }
                }

                function getRequestEssentials(t, d = !1) {
                    const h = t.clone();
                    return d && (h.url = t.url), h.headers.set("x-ms-client-request-id", generateUuid()), h.headers.set("Content-Type", "application/json; charset=utf-8"), h
                }
                async function getRegistrationStatus(t, d, h) {
                    const y = getRequestEssentials(h);
                    y.url = d, y.method = "GET";
                    const _ = await t._nextPolicy.sendRequest(y),
                        x = _.parsedBody;
                    return !(!_.parsedBody || !x.registrationState || "Registered" !== x.registrationState) || (await delay(1e3 * t._retryTimeout), getRegistrationStatus(t, d, h))
                }
                class SigningPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h) {
                        super(t, d), this.authenticationProvider = h
                    }
                    signRequest(t) {
                        return this.authenticationProvider.signRequest(t)
                    }
                    sendRequest(t) {
                        return this.signRequest(t).then((t => this._nextPolicy.sendRequest(t)))
                    }
                }
                class SystemErrorRetryPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h, y, _, x) {
                        super(t, d), this.retryCount = isNumber(h) ? h : 3, this.retryInterval = isNumber(y) ? y : bl, this.minRetryInterval = isNumber(_) ? _ : 3e3, this.maxRetryInterval = isNumber(x) ? x : vl
                    }
                    sendRequest(t) {
                        return this._nextPolicy.sendRequest(t.clone()).catch((d => systemErrorRetryPolicy_retry(this, t, d.response, d)))
                    }
                }
                async function systemErrorRetryPolicy_retry(t, d, h, y, _) {
                    if (_ = updateRetryData(t, _, y), !shouldRetry(t.retryCount, (function shouldPolicyRetry(t, d) {
                            return !(!d || !d.code || "ETIMEDOUT" !== d.code && "ESOCKETTIMEDOUT" !== d.code && "ECONNREFUSED" !== d.code && "ECONNRESET" !== d.code && "ENOENT" !== d.code)
                        }), _, h, y)) return y ? Promise.reject(_.error) : h;
                    try {
                        return await delay(_.retryInterval), t._nextPolicy.sendRequest(d.clone())
                    } catch (x) {
                        return systemErrorRetryPolicy_retry(t, d, h, x, _)
                    }
                }
                const Sl = tl.StatusCodes;
                const wl = "The operation was aborted.";
                class ThrottlingRetryPolicy extends requestPolicy_BaseRequestPolicy {
                    constructor(t, d, h) {
                        super(t, d), this.numberOfRetries = 0, this._handleResponse = h || this._defaultResponseHandler
                    }
                    async sendRequest(t) {
                        const d = await this._nextPolicy.sendRequest(t.clone());
                        return d.status !== Sl.TooManyRequests && d.status !== Sl.ServiceUnavailable ? d : this._handleResponse(t, d)
                    }
                    async _defaultResponseHandler(t, d) {
                        var h;
                        const y = d.headers.get(rl.RETRY_AFTER);
                        if (y) {
                            const d = ThrottlingRetryPolicy.parseRetryAfterHeader(y);
                            if (d) {
                                if (this.numberOfRetries += 1, await delay(d, void 0, {
                                        abortSignal: t.abortSignal,
                                        abortErrorMsg: wl
                                    }), null === (h = t.abortSignal) || void 0 === h ? void 0 : h.aborted) throw new al(wl);
                                return this.numberOfRetries < 3 ? this.sendRequest(t) : this._nextPolicy.sendRequest(t)
                            }
                        }
                        return d
                    }
                    static parseRetryAfterHeader(t) {
                        const d = Number(t);
                        return Number.isNaN(d) ? ThrottlingRetryPolicy.parseDateRetryAfterHeader(t) : 1e3 * d
                    }
                    static parseDateRetryAfterHeader(t) {
                        try {
                            const d = Date.now(),
                                h = Date.parse(t) - d;
                            return Number.isNaN(h) ? void 0 : h
                        } catch (d) {
                            return
                        }
                    }
                }

                function getValueOrFunctionResult(t, d) {
                    let h;
                    return "string" == typeof t ? h = t : (h = d(), "function" == typeof t && (h = t(h))), h
                }

                function getOperationArgumentValueFromParameter(t, d, h, y) {
                    return getOperationArgumentValueFromParameterPath(t, d, h.parameterPath, h.mapper, y)
                }

                function getOperationArgumentValueFromParameterPath(t, d, h, y, _) {
                    var x;
                    let C;
                    "string" == typeof h && (h = [h]);
                    const E = null === (x = d.options) || void 0 === x ? void 0 : x.serializerOptions;
                    if (Array.isArray(h)) {
                        if (h.length > 0) {
                            if (y.isConstant) C = y.defaultValue;
                            else {
                                let _ = getPropertyFromParameterPath(d, h);
                                _.propertyFound || (_ = getPropertyFromParameterPath(t, h));
                                let x = !1;
                                _.propertyFound || (x = y.required || "options" === h[0] && 2 === h.length), C = x ? y.defaultValue : _.propertyValue
                            }
                            const x = getPathStringFromParameterPath(h, y);
                            _.serialize(y, C, x, E)
                        }
                    } else {
                        y.required && (C = {});
                        for (const x in h) {
                            const O = y.type.modelProperties[x],
                                k = h[x],
                                z = getOperationArgumentValueFromParameterPath(t, d, k, O, _),
                                A = getPathStringFromParameterPath(k, O);
                            _.serialize(O, z, A, E), null != z && (C || (C = {}), C[x] = z)
                        }
                    }
                    return C
                }

                function getPropertyFromParameterPath(t, d) {
                    const h = {
                        propertyFound: !1
                    };
                    let y = 0;
                    for (; y < d.length; ++y) {
                        const h = d[y];
                        if (null == t || !(h in t)) break;
                        t = t[h]
                    }
                    return y === d.length && (h.propertyValue = t, h.propertyFound = !0), h
                }

                function flattenResponse(t, d) {
                    const h = t.parsedHeaders,
                        y = d && d.bodyMapper,
                        addOperationResponse = d => Object.defineProperty(d, "_response", {
                            value: t
                        });
                    if (y) {
                        const d = y.type.name;
                        if ("Stream" === d) return addOperationResponse(Object.assign(Object.assign({}, h), {
                            blobBody: t.blobBody,
                            readableStreamBody: t.readableStreamBody
                        }));
                        const _ = "Composite" === d && y.type.modelProperties || {},
                            x = Object.keys(_).some((t => "" === _[t].serializedName));
                        if ("Sequence" === d || x) {
                            const d = [...t.parsedBody || []];
                            for (const h of Object.keys(_)) _[h].serializedName && (d[h] = t.parsedBody[h]);
                            if (h)
                                for (const t of Object.keys(h)) d[t] = h[t];
                            return addOperationResponse(d), d
                        }
                        if ("Composite" === d || "Dictionary" === d) return addOperationResponse(Object.assign(Object.assign({}, h), t.parsedBody))
                    }
                    return y || "HEAD" === t.request.method || function isPrimitiveType(t) {
                        return "object" != typeof t && "function" != typeof t || null === t
                    }(t.parsedBody) ? addOperationResponse(Object.assign(Object.assign({}, h), {
                        body: t.parsedBody
                    })) : addOperationResponse(Object.assign(Object.assign({}, h), t.parsedBody))
                }
                class StorageClientContext extends class ServiceClient {
                    constructor(t, d) {
                        let h;
                        if (d || (d = {}), this._withCredentials = d.withCredentials || !1, this._httpClient = d.httpClient || function httpClientCache_getCachedDefaultHttpClient() {
                                return Pl || (Pl = new XhrHttpClient), Pl
                            }(), this._requestPolicyOptions = new RequestPolicyOptions(d.httpPipelineLogger), Array.isArray(d.requestPolicyFactories)) Ds.info("ServiceClient: using custom request policies"), h = d.requestPolicyFactories;
                        else {
                            let y;
                            if (isTokenCredential(t)) {
                                Ds.info("ServiceClient: creating bearer token authentication policy from provided credentials");
                                const wrappedPolicyFactory = () => {
                                    let h;
                                    const y = this,
                                        _ = d;
                                    return {
                                        create(d, x) {
                                            const C = function getCredentialScopes(t, d) {
                                                if (null == t ? void 0 : t.credentialScopes) {
                                                    const d = t.credentialScopes;
                                                    return Array.isArray(d) ? d.map((t => new Nl(t).toString())) : new Nl(d).toString()
                                                }
                                                if (d) return `${d}/.default`;
                                                return
                                            }(_, y.baseUri);
                                            if (!C) throw new Error("When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy");
                                            return null == h && (h = bearerTokenAuthenticationPolicy(t, C)), h.create(d, x)
                                        }
                                    }
                                };
                                y = wrappedPolicyFactory()
                            } else if (t && "function" == typeof t.signRequest) Ds.info("ServiceClient: creating signing policy from provided credentials"), y = function signingPolicy(t) {
                                return {
                                    create: (d, h) => new SigningPolicy(d, h, t)
                                }
                            }(t);
                            else if (null != t) throw new Error("The credentials argument must implement the TokenCredential interface");
                            if (Ds.info("ServiceClient: using default request policies"), h = function createDefaultRequestPolicyFactories(t, d) {
                                    const h = [];
                                    d.generateClientRequestIdHeader && h.push(generateClientRequestIdPolicy_generateClientRequestIdPolicy(d.clientRequestIdHeaderName));
                                    t && h.push(t);
                                    const y = getValueOrFunctionResult(d.userAgentHeaderName, xl),
                                        _ = getValueOrFunctionResult(d.userAgent, userAgentPolicy_getDefaultUserAgentValue);
                                    y && _ && h.push(function userAgentPolicy_userAgentPolicy(t) {
                                        const d = t && void 0 !== t.key && null !== t.key ? t.key : "x-ms-useragent",
                                            h = t && void 0 !== t.value && null !== t.value ? t.value : userAgentPolicy_getDefaultUserAgentValue();
                                        return {
                                            create: (t, y) => new UserAgentPolicy(t, y, d, h)
                                        }
                                    }({
                                        key: y,
                                        value: _
                                    }));
                                    h.push(function redirectPolicy_redirectPolicy(t = 20) {
                                        return {
                                            create: (d, h) => new RedirectPolicy(d, h, t)
                                        }
                                    }()), h.push(function rpRegistrationPolicy(t = 30) {
                                        return {
                                            create: (d, h) => new RPRegistrationPolicy(d, h, t)
                                        }
                                    }(d.rpRegistrationRetryTimeout)), d.noRetryPolicy || (h.push(function exponentialRetryPolicy_exponentialRetryPolicy(t, d, h) {
                                        return {
                                            create: (y, _) => new ExponentialRetryPolicy(y, _, t, d, h)
                                        }
                                    }()), h.push(function systemErrorRetryPolicy_systemErrorRetryPolicy(t, d, h, y) {
                                        return {
                                            create: (_, x) => new SystemErrorRetryPolicy(_, x, t, d, h, y)
                                        }
                                    }()), h.push(function throttlingRetryPolicy_throttlingRetryPolicy() {
                                        return {
                                            create: (t, d) => new ThrottlingRetryPolicy(t, d)
                                        }
                                    }()));
                                    h.push(deserializationPolicy_deserializationPolicy(d.deserializationContentTypes)), H && h.push(proxyPolicy_browser_proxyPolicy(d.proxySettings));
                                    return h.push(logPolicy_logPolicy({
                                        logger: Ds.info
                                    })), h
                                }(y, d), d.requestPolicyFactories) {
                                const t = d.requestPolicyFactories(h);
                                t && (h = t)
                            }
                        }
                        this._requestPolicyFactories = h
                    }
                    sendRequest(t) {
                        if (null == t || "object" != typeof t) throw new Error("options cannot be null or undefined and it must be of type object.");
                        let d;
                        try {
                            ! function isWebResourceLike(t) {
                                if (t && "object" == typeof t) {
                                    const d = t;
                                    if ("string" == typeof d.url && "string" == typeof d.method && "object" == typeof d.headers && isHttpHeadersLike(d.headers) && "function" == typeof d.validateRequestProperties && "function" == typeof d.prepare && "function" == typeof d.clone) return !0
                                }
                                return !1
                            }(t) ? (d = new WebResource, d = d.prepare(t)) : (t.validateRequestProperties(), d = t)
                        } catch (y) {
                            return Promise.reject(y)
                        }
                        let h = this._httpClient;
                        if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0)
                            for (let _ = this._requestPolicyFactories.length - 1; _ >= 0; --_) h = this._requestPolicyFactories[_].create(h, this._requestPolicyOptions);
                        return h.sendRequest(d)
                    }
                    async sendOperationRequest(t, d, h) {
                        var y;
                        "function" == typeof t.options && (h = t.options, t.options = void 0);
                        const _ = null === (y = t.options) || void 0 === y ? void 0 : y.serializerOptions,
                            x = new WebResource;
                        let O;
                        try {
                            const h = d.baseUrl || this.baseUri;
                            if (!h) throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
                            x.method = d.httpMethod, x.operationSpec = d;
                            const y = url_URLBuilder.parse(h);
                            if (d.path && y.appendPath(d.path), d.urlParameters && d.urlParameters.length > 0)
                                for (const x of d.urlParameters) {
                                    let h = getOperationArgumentValueFromParameter(this, t, x, d.serializer);
                                    h = d.serializer.serialize(x.mapper, h, getPathStringFromParameter(x), _), x.skipEncoding || (h = encodeURIComponent(h)), y.replaceAll(`{${x.mapper.serializedName||getPathStringFromParameter(x)}}`, h)
                                }
                            if (d.queryParameters && d.queryParameters.length > 0)
                                for (const x of d.queryParameters) {
                                    let h = getOperationArgumentValueFromParameter(this, t, x, d.serializer);
                                    if (null != h) {
                                        if (h = d.serializer.serialize(x.mapper, h, getPathStringFromParameter(x), _), void 0 !== x.collectionFormat && null !== x.collectionFormat)
                                            if (x.collectionFormat === mi.Multi) {
                                                if (0 === h.length) continue;
                                                for (const t in h) {
                                                    const d = h[t];
                                                    h[t] = null == d ? "" : d.toString()
                                                }
                                            } else x.collectionFormat !== mi.Ssv && x.collectionFormat !== mi.Tsv || (h = h.join(x.collectionFormat));
                                        if (!x.skipEncoding)
                                            if (Array.isArray(h))
                                                for (const t in h) void 0 !== h[t] && null !== h[t] && (h[t] = encodeURIComponent(h[t]));
                                            else h = encodeURIComponent(h);
                                        void 0 !== x.collectionFormat && null !== x.collectionFormat && x.collectionFormat !== mi.Multi && x.collectionFormat !== mi.Ssv && x.collectionFormat !== mi.Tsv && (h = h.join(x.collectionFormat)), y.setQueryParameter(x.mapper.serializedName || getPathStringFromParameter(x), h)
                                    }
                                }
                            x.url = y.toString();
                            const k = d.contentType || this.requestContentType;
                            if (k && d.requestBody && x.headers.set("Content-Type", k), d.headerParameters)
                                for (const C of d.headerParameters) {
                                    let h = getOperationArgumentValueFromParameter(this, t, C, d.serializer);
                                    if (null != h) {
                                        h = d.serializer.serialize(C.mapper, h, getPathStringFromParameter(C), _);
                                        const t = C.mapper.headerCollectionPrefix;
                                        if (t)
                                            for (const d of Object.keys(h)) x.headers.set(t + d, h[d]);
                                        else x.headers.set(C.mapper.serializedName || getPathStringFromParameter(C), h)
                                    }
                                }
                            const A = t.options;
                            if (A) {
                                if (A.customHeaders)
                                    for (const t in A.customHeaders) x.headers.set(t, A.customHeaders[t]);
                                A.abortSignal && (x.abortSignal = A.abortSignal), A.timeout && (x.timeout = A.timeout), A.onUploadProgress && (x.onUploadProgress = A.onUploadProgress), A.onDownloadProgress && (x.onDownloadProgress = A.onDownloadProgress), A.spanOptions && (x.spanOptions = A.spanOptions), A.tracingContext && (x.tracingContext = A.tracingContext), void 0 !== A.shouldDeserialize && null !== A.shouldDeserialize && (x.shouldDeserialize = A.shouldDeserialize)
                            }
                            let B, I;
                            x.withCredentials = this._withCredentials,
                                function serializeRequestBody(t, d, h, y) {
                                    var _, x, O, k, z, A;
                                    const B = null !== (x = null === (_ = h.options) || void 0 === _ ? void 0 : _.serializerOptions) && void 0 !== x ? x : {},
                                        I = {
                                            rootName: null !== (O = B.rootName) && void 0 !== O ? O : "",
                                            includeRoot: null !== (k = B.includeRoot) && void 0 !== k && k,
                                            xmlCharKey: null !== (z = B.xmlCharKey) && void 0 !== z ? z : E
                                        },
                                        q = B.xmlCharKey;
                                    if (y.requestBody && y.requestBody.mapper) {
                                        d.body = getOperationArgumentValueFromParameter(t, h, y.requestBody, y.serializer);
                                        const _ = y.requestBody.mapper,
                                            {
                                                required: x,
                                                xmlName: E,
                                                xmlElementName: O,
                                                serializedName: k,
                                                xmlNamespace: z,
                                                xmlNamespacePrefix: B
                                            } = _,
                                            j = _.type.name;
                                        try {
                                            if (void 0 !== d.body && null !== d.body || x) {
                                                const t = getPathStringFromParameter(y.requestBody);
                                                d.body = y.serializer.serialize(_, d.body, t, I);
                                                const h = j === Xe.Stream;
                                                if (y.isXML) {
                                                    const t = B ? `xmlns:${B}` : "xmlns",
                                                        y = function getXmlValueWithNamespace(t, d, h, y, _) {
                                                            if (t && !["Composite", "Sequence", "Dictionary"].includes(h)) {
                                                                const h = {};
                                                                return h[_.xmlCharKey] = y, h[C] = {
                                                                    [d]: t
                                                                }, h
                                                            }
                                                            return y
                                                        }(z, t, j, d.body, I);
                                                    j === Xe.Sequence ? d.body = stringifyXML(function prepareXMLRootList(t, d, h, y) {
                                                        if (Array.isArray(t) || (t = [t]), !h || !y) return {
                                                            [d]: t
                                                        };
                                                        const _ = {
                                                            [d]: t
                                                        };
                                                        return _[C] = {
                                                            [h]: y
                                                        }, _
                                                    }(y, O || E || k, t, z), {
                                                        rootName: E || k,
                                                        xmlCharKey: q
                                                    }) : h || (d.body = stringifyXML(y, {
                                                        rootName: E || k,
                                                        xmlCharKey: q
                                                    }))
                                                } else {
                                                    if (j === Xe.String && ((null === (A = y.contentType) || void 0 === A ? void 0 : A.match("text/plain")) || "text" === y.mediaType)) return;
                                                    h || (d.body = JSON.stringify(d.body))
                                                }
                                            }
                                        } catch (D) {
                                            throw new Error(`Error "${D.message}" occurred in serializing the payload - ${JSON.stringify(k,void 0,"  ")}.`)
                                        }
                                    } else if (y.formDataParameters && y.formDataParameters.length > 0) {
                                        d.formData = {};
                                        for (const _ of y.formDataParameters) {
                                            const x = getOperationArgumentValueFromParameter(t, h, _, y.serializer);
                                            if (null != x) {
                                                const t = _.mapper.serializedName || getPathStringFromParameter(_);
                                                d.formData[t] = y.serializer.serialize(_.mapper, x, getPathStringFromParameter(_), I)
                                            }
                                        }
                                    }
                                }(this, x, t, d), void 0 === x.streamResponseStatusCodes && (x.streamResponseStatusCodes = function getStreamResponseStatusCodes(t) {
                                    const d = new Set;
                                    for (const h in t.responses) {
                                        const y = t.responses[h];
                                        y.bodyMapper && y.bodyMapper.type.name === Xe.Stream && d.add(Number(h))
                                    }
                                    return d
                                }(d));
                            try {
                                B = await this.sendRequest(x)
                            } catch (z) {
                                I = z
                            }
                            I ? (I.response && (I.details = flattenResponse(I.response, d.responses[I.statusCode] || d.responses.default)), O = Promise.reject(I)) : O = Promise.resolve(flattenResponse(B, d.responses[B.status]))
                        } catch (z) {
                            O = Promise.reject(z)
                        }
                        const k = h;
                        return k && O.then((t => k(null, t._response.parsedBody, t._response.request, t._response))).catch((t => k(t))), O
                    }
                } {
                    constructor(t, d) {
                        if (void 0 === t) throw new Error("'url' cannot be null");
                        if (d || (d = {}), !d.userAgent) {
                            const t = userAgentPolicy_getDefaultUserAgentValue();
                            d.userAgent = `azure-storage-blob/12.8.0 ${t}`
                        }
                        super(void 0, d), this.requestContentType = "application/json; charset=utf-8", this.baseUri = d.endpoint || "{url}", this.url = t, this.version = d.version || "2020-10-02"
                    }
                }
                var Cl, El = h(7187);
                ! function(t) {
                    t[t.Good = 0] = "Good", t[t.Error = 1] = "Error"
                }(Cl || (Cl = {}));
                class Batch {
                    constructor(t = 5) {
                        if (this.actives = 0, this.completed = 0, this.offset = 0, this.operations = [], this.state = Cl.Good, t < 1) throw new RangeError("concurrency must be larger than 0");
                        this.concurrency = t, this.emitter = new El.EventEmitter
                    }
                    addOperation(t) {
                        this.operations.push((async () => {
                            try {
                                this.actives++, await t(), this.actives--, this.completed++, this.parallelExecute()
                            } catch (d) {
                                this.emitter.emit("error", d)
                            }
                        }))
                    }
                    async
                        do() {
                            return 0 === this.operations.length ? Promise.resolve() : (this.parallelExecute(), new Promise(((t, d) => {
                                this.emitter.on("finish", t), this.emitter.on("error", (t => {
                                    this.state = Cl.Error, d(t)
                                }))
                            })))
                        }
                        nextOperation() {
                            return this.offset < this.operations.length ? this.operations[this.offset++] : null
                        }
                    parallelExecute() {
                        if (this.state !== Cl.Error)
                            if (this.completed >= this.operations.length) this.emitter.emit("finish");
                            else
                                for (; this.actives < this.concurrency;) {
                                    const t = this.nextOperation();
                                    if (!t) return;
                                    t()
                                }
                    }
                }
                class BufferScheduler {}
                const Ol = createSpanFunction({
                    packagePrefix: "Azure.Storage.Blob",
                    namespace: "Microsoft.Storage"
                });

                function convertTracingToRequestOptionsBase(t) {
                    var d, h;
                    return {
                        spanOptions: null === (d = null == t ? void 0 : t.tracingOptions) || void 0 === d ? void 0 : d.spanOptions,
                        tracingContext: null === (h = null == t ? void 0 : t.tracingOptions) || void 0 === h ? void 0 : h.tracingContext
                    }
                }
                class BlobSASPermissions {
                    constructor() {
                        this.read = !1, this.add = !1, this.create = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.tag = !1, this.move = !1, this.execute = !1, this.setImmutabilityPolicy = !1
                    }
                    static parse(t) {
                        const d = new BlobSASPermissions;
                        for (const h of t) switch (h) {
                            case "r":
                                d.read = !0;
                                break;
                            case "a":
                                d.add = !0;
                                break;
                            case "c":
                                d.create = !0;
                                break;
                            case "w":
                                d.write = !0;
                                break;
                            case "d":
                                d.delete = !0;
                                break;
                            case "x":
                                d.deleteVersion = !0;
                                break;
                            case "t":
                                d.tag = !0;
                                break;
                            case "m":
                                d.move = !0;
                                break;
                            case "e":
                                d.execute = !0;
                                break;
                            case "i":
                                d.setImmutabilityPolicy = !0;
                                break;
                            default:
                                throw new RangeError(`Invalid permission: ${h}`)
                        }
                        return d
                    }
                    static from(t) {
                        const d = new BlobSASPermissions;
                        return t.read && (d.read = !0), t.add && (d.add = !0), t.create && (d.create = !0), t.write && (d.write = !0), t.delete && (d.delete = !0), t.deleteVersion && (d.deleteVersion = !0), t.tag && (d.tag = !0), t.move && (d.move = !0), t.execute && (d.execute = !0), t.setImmutabilityPolicy && (d.setImmutabilityPolicy = !0), d
                    }
                    toString() {
                        const t = [];
                        return this.read && t.push("r"), this.add && t.push("a"), this.create && t.push("c"), this.write && t.push("w"), this.delete && t.push("d"), this.deleteVersion && t.push("x"), this.tag && t.push("t"), this.move && t.push("m"), this.execute && t.push("e"), this.setImmutabilityPolicy && t.push("i"), t.join("")
                    }
                }
                class ContainerSASPermissions {
                    constructor() {
                        this.read = !1, this.add = !1, this.create = !1, this.write = !1, this.delete = !1, this.deleteVersion = !1, this.list = !1, this.tag = !1, this.move = !1, this.execute = !1, this.setImmutabilityPolicy = !1
                    }
                    static parse(t) {
                        const d = new ContainerSASPermissions;
                        for (const h of t) switch (h) {
                            case "r":
                                d.read = !0;
                                break;
                            case "a":
                                d.add = !0;
                                break;
                            case "c":
                                d.create = !0;
                                break;
                            case "w":
                                d.write = !0;
                                break;
                            case "d":
                                d.delete = !0;
                                break;
                            case "l":
                                d.list = !0;
                                break;
                            case "t":
                                d.tag = !0;
                                break;
                            case "x":
                                d.deleteVersion = !0;
                                break;
                            case "m":
                                d.move = !0;
                                break;
                            case "e":
                                d.execute = !0;
                                break;
                            case "i":
                                d.setImmutabilityPolicy = !0;
                                break;
                            default:
                                throw new RangeError(`Invalid permission ${h}`)
                        }
                        return d
                    }
                    static from(t) {
                        const d = new ContainerSASPermissions;
                        return t.read && (d.read = !0), t.add && (d.add = !0), t.create && (d.create = !0), t.write && (d.write = !0), t.delete && (d.delete = !0), t.list && (d.list = !0), t.deleteVersion && (d.deleteVersion = !0), t.tag && (d.tag = !0), t.move && (d.move = !0), t.execute && (d.execute = !0), t.setImmutabilityPolicy && (d.setImmutabilityPolicy = !0), d
                    }
                    toString() {
                        const t = [];
                        return this.read && t.push("r"), this.add && t.push("a"), this.create && t.push("c"), this.write && t.push("w"), this.delete && t.push("d"), this.deleteVersion && t.push("x"), this.list && t.push("l"), this.tag && t.push("t"), this.move && t.push("m"), this.execute && t.push("e"), this.setImmutabilityPolicy && t.push("i"), t.join("")
                    }
                }
                class UserDelegationKeyCredential {}

                function ipRangeToString(t) {
                    return t.end ? `${t.start}-${t.end}` : t.start
                }
                var Tl;
                ! function(t) {
                    t.Https = "https", t.HttpsAndHttp = "https,http"
                }(Tl || (Tl = {}));
                class SASQueryParameters {
                    constructor(t, d, h, y, _, x, C, E, O, k, z, A, B, I, q, D, j, H, $) {
                        this.version = t, this.signature = d, void 0 !== h && "string" != typeof h ? (this.permissions = h.permissions, this.services = h.services, this.resourceTypes = h.resourceTypes, this.protocol = h.protocol, this.startsOn = h.startsOn, this.expiresOn = h.expiresOn, this.ipRangeInner = h.ipRange, this.identifier = h.identifier, this.resource = h.resource, this.cacheControl = h.cacheControl, this.contentDisposition = h.contentDisposition, this.contentEncoding = h.contentEncoding, this.contentLanguage = h.contentLanguage, this.contentType = h.contentType, h.userDelegationKey && (this.signedOid = h.userDelegationKey.signedObjectId, this.signedTenantId = h.userDelegationKey.signedTenantId, this.signedStartsOn = h.userDelegationKey.signedStartsOn, this.signedExpiresOn = h.userDelegationKey.signedExpiresOn, this.signedService = h.userDelegationKey.signedService, this.signedVersion = h.userDelegationKey.signedVersion, this.preauthorizedAgentObjectId = h.preauthorizedAgentObjectId, this.correlationId = h.correlationId)) : (this.services = y, this.resourceTypes = _, this.expiresOn = E, this.permissions = h, this.protocol = x, this.startsOn = C, this.ipRangeInner = O, this.identifier = k, this.resource = z, this.cacheControl = A, this.contentDisposition = B, this.contentEncoding = I, this.contentLanguage = q, this.contentType = D, j && (this.signedOid = j.signedObjectId, this.signedTenantId = j.signedTenantId, this.signedStartsOn = j.signedStartsOn, this.signedExpiresOn = j.signedExpiresOn, this.signedService = j.signedService, this.signedVersion = j.signedVersion, this.preauthorizedAgentObjectId = H, this.correlationId = $))
                    }
                    get ipRange() {
                        if (this.ipRangeInner) return {
                            end: this.ipRangeInner.end,
                            start: this.ipRangeInner.start
                        }
                    }
                    toString() {
                        const t = ["sv", "ss", "srt", "spr", "st", "se", "sip", "si", "skoid", "sktid", "skt", "ske", "sks", "skv", "sr", "sp", "sig", "rscc", "rscd", "rsce", "rscl", "rsct", "saoid", "scid"],
                            d = [];
                        for (const h of t) switch (h) {
                            case "sv":
                                this.tryAppendQueryParameter(d, h, this.version);
                                break;
                            case "ss":
                                this.tryAppendQueryParameter(d, h, this.services);
                                break;
                            case "srt":
                                this.tryAppendQueryParameter(d, h, this.resourceTypes);
                                break;
                            case "spr":
                                this.tryAppendQueryParameter(d, h, this.protocol);
                                break;
                            case "st":
                                this.tryAppendQueryParameter(d, h, this.startsOn ? truncatedISO8061Date(this.startsOn, !1) : void 0);
                                break;
                            case "se":
                                this.tryAppendQueryParameter(d, h, this.expiresOn ? truncatedISO8061Date(this.expiresOn, !1) : void 0);
                                break;
                            case "sip":
                                this.tryAppendQueryParameter(d, h, this.ipRange ? ipRangeToString(this.ipRange) : void 0);
                                break;
                            case "si":
                                this.tryAppendQueryParameter(d, h, this.identifier);
                                break;
                            case "skoid":
                                this.tryAppendQueryParameter(d, h, this.signedOid);
                                break;
                            case "sktid":
                                this.tryAppendQueryParameter(d, h, this.signedTenantId);
                                break;
                            case "skt":
                                this.tryAppendQueryParameter(d, h, this.signedStartsOn ? truncatedISO8061Date(this.signedStartsOn, !1) : void 0);
                                break;
                            case "ske":
                                this.tryAppendQueryParameter(d, h, this.signedExpiresOn ? truncatedISO8061Date(this.signedExpiresOn, !1) : void 0);
                                break;
                            case "sks":
                                this.tryAppendQueryParameter(d, h, this.signedService);
                                break;
                            case "skv":
                                this.tryAppendQueryParameter(d, h, this.signedVersion);
                                break;
                            case "sr":
                                this.tryAppendQueryParameter(d, h, this.resource);
                                break;
                            case "sp":
                                this.tryAppendQueryParameter(d, h, this.permissions);
                                break;
                            case "sig":
                                this.tryAppendQueryParameter(d, h, this.signature);
                                break;
                            case "rscc":
                                this.tryAppendQueryParameter(d, h, this.cacheControl);
                                break;
                            case "rscd":
                                this.tryAppendQueryParameter(d, h, this.contentDisposition);
                                break;
                            case "rsce":
                                this.tryAppendQueryParameter(d, h, this.contentEncoding);
                                break;
                            case "rscl":
                                this.tryAppendQueryParameter(d, h, this.contentLanguage);
                                break;
                            case "rsct":
                                this.tryAppendQueryParameter(d, h, this.contentType);
                                break;
                            case "saoid":
                                this.tryAppendQueryParameter(d, h, this.preauthorizedAgentObjectId);
                                break;
                            case "scid":
                                this.tryAppendQueryParameter(d, h, this.correlationId)
                        }
                        return d.join("&")
                    }
                    tryAppendQueryParameter(t, d, h) {
                        h && (d = encodeURIComponent(d), h = encodeURIComponent(h), d.length > 0 && h.length > 0 && t.push(`${d}=${h}`))
                    }
                }

                function generateBlobSASQueryParameters(t, d, h) {
                    const y = t.version ? t.version : ps,
                        _ = d instanceof StorageSharedKeyCredential ? d : void 0;
                    let x;
                    if (void 0 === _ && void 0 !== h && (x = new UserDelegationKeyCredential(h, d)), void 0 === _ && void 0 === x) throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
                    if (y >= "2018-11-09") return void 0 !== _ ? function generateBlobSASQueryParameters20181109(t, d) {
                        if (!((t = SASSignatureValuesSanityCheckAndAutofill(t)).identifier || t.permissions && t.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
                        let h, y = "c",
                            _ = t.snapshotTime;
                        t.blobName && (y = "b", t.snapshotTime ? y = "bs" : t.versionId && (y = "bv", _ = t.versionId));
                        t.permissions && (h = t.blobName ? BlobSASPermissions.parse(t.permissions.toString()).toString() : ContainerSASPermissions.parse(t.permissions.toString()).toString());
                        const x = [h || "", t.startsOn ? truncatedISO8061Date(t.startsOn, !1) : "", t.expiresOn ? truncatedISO8061Date(t.expiresOn, !1) : "", getCanonicalName(d.accountName, t.containerName, t.blobName), t.identifier, t.ipRange ? ipRangeToString(t.ipRange) : "", t.protocol ? t.protocol : "", t.version, y, _, t.cacheControl ? t.cacheControl : "", t.contentDisposition ? t.contentDisposition : "", t.contentEncoding ? t.contentEncoding : "", t.contentLanguage ? t.contentLanguage : "", t.contentType ? t.contentType : ""].join("\n"),
                            C = d.computeHMACSHA256(x);
                        return new SASQueryParameters(t.version, C, h, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, y, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType)
                    }(t, _) : y >= "2020-02-10" ? function generateBlobSASQueryParametersUDK20200210(t, d) {
                        if (!(t = SASSignatureValuesSanityCheckAndAutofill(t)).permissions || !t.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
                        let h, y = "c",
                            _ = t.snapshotTime;
                        t.blobName && (y = "b", t.snapshotTime ? y = "bs" : t.versionId && (y = "bv", _ = t.versionId));
                        t.permissions && (h = t.blobName ? BlobSASPermissions.parse(t.permissions.toString()).toString() : ContainerSASPermissions.parse(t.permissions.toString()).toString());
                        const x = [h || "", t.startsOn ? truncatedISO8061Date(t.startsOn, !1) : "", t.expiresOn ? truncatedISO8061Date(t.expiresOn, !1) : "", getCanonicalName(d.accountName, t.containerName, t.blobName), d.userDelegationKey.signedObjectId, d.userDelegationKey.signedTenantId, d.userDelegationKey.signedStartsOn ? truncatedISO8061Date(d.userDelegationKey.signedStartsOn, !1) : "", d.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(d.userDelegationKey.signedExpiresOn, !1) : "", d.userDelegationKey.signedService, d.userDelegationKey.signedVersion, t.preauthorizedAgentObjectId, void 0, t.correlationId, t.ipRange ? ipRangeToString(t.ipRange) : "", t.protocol ? t.protocol : "", t.version, y, _, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType].join("\n"),
                            C = d.computeHMACSHA256(x);
                        return new SASQueryParameters(t.version, C, h, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, y, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, d.userDelegationKey, t.preauthorizedAgentObjectId, t.correlationId)
                    }(t, x) : function generateBlobSASQueryParametersUDK20181109(t, d) {
                        if (!(t = SASSignatureValuesSanityCheckAndAutofill(t)).permissions || !t.expiresOn) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
                        let h, y = "c",
                            _ = t.snapshotTime;
                        t.blobName && (y = "b", t.snapshotTime ? y = "bs" : t.versionId && (y = "bv", _ = t.versionId));
                        t.permissions && (h = t.blobName ? BlobSASPermissions.parse(t.permissions.toString()).toString() : ContainerSASPermissions.parse(t.permissions.toString()).toString());
                        const x = [h || "", t.startsOn ? truncatedISO8061Date(t.startsOn, !1) : "", t.expiresOn ? truncatedISO8061Date(t.expiresOn, !1) : "", getCanonicalName(d.accountName, t.containerName, t.blobName), d.userDelegationKey.signedObjectId, d.userDelegationKey.signedTenantId, d.userDelegationKey.signedStartsOn ? truncatedISO8061Date(d.userDelegationKey.signedStartsOn, !1) : "", d.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(d.userDelegationKey.signedExpiresOn, !1) : "", d.userDelegationKey.signedService, d.userDelegationKey.signedVersion, t.ipRange ? ipRangeToString(t.ipRange) : "", t.protocol ? t.protocol : "", t.version, y, _, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType].join("\n"),
                            C = d.computeHMACSHA256(x);
                        return new SASQueryParameters(t.version, C, h, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, y, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType, d.userDelegationKey)
                    }(t, x);
                    if (y >= "2015-04-05") {
                        if (void 0 !== _) return function generateBlobSASQueryParameters20150405(t, d) {
                            if (!((t = SASSignatureValuesSanityCheckAndAutofill(t)).identifier || t.permissions && t.expiresOn)) throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
                            let h, y = "c";
                            t.blobName && (y = "b");
                            t.permissions && (h = t.blobName ? BlobSASPermissions.parse(t.permissions.toString()).toString() : ContainerSASPermissions.parse(t.permissions.toString()).toString());
                            const _ = [h || "", t.startsOn ? truncatedISO8061Date(t.startsOn, !1) : "", t.expiresOn ? truncatedISO8061Date(t.expiresOn, !1) : "", getCanonicalName(d.accountName, t.containerName, t.blobName), t.identifier, t.ipRange ? ipRangeToString(t.ipRange) : "", t.protocol ? t.protocol : "", t.version, t.cacheControl ? t.cacheControl : "", t.contentDisposition ? t.contentDisposition : "", t.contentEncoding ? t.contentEncoding : "", t.contentLanguage ? t.contentLanguage : "", t.contentType ? t.contentType : ""].join("\n"),
                                x = d.computeHMACSHA256(_);
                            return new SASQueryParameters(t.version, x, h, void 0, void 0, t.protocol, t.startsOn, t.expiresOn, t.ipRange, t.identifier, y, t.cacheControl, t.contentDisposition, t.contentEncoding, t.contentLanguage, t.contentType)
                        }(t, _);
                        throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.")
                    }
                    throw new RangeError("'version' must be >= '2015-04-05'.")
                }

                function getCanonicalName(t, d, h) {
                    const y = [`/blob/${t}/${d}`];
                    return h && y.push(`/${h}`), y.join("")
                }

                function SASSignatureValuesSanityCheckAndAutofill(t) {
                    const d = t.version ? t.version : ps;
                    if (t.snapshotTime && d < "2018-11-09") throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
                    if (void 0 === t.blobName && t.snapshotTime) throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
                    if (t.versionId && d < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
                    if (void 0 === t.blobName && t.versionId) throw RangeError("Must provide 'blobName' when providing 'versionId'.");
                    if (t.permissions && t.permissions.setImmutabilityPolicy && d < "2020-08-04") throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
                    if (t.permissions && t.permissions.deleteVersion && d < "2019-10-10") throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
                    if (t.permissions && t.permissions.tag && d < "2019-12-12") throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
                    if (d < "2020-02-10" && t.permissions && (t.permissions.move || t.permissions.execute)) throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
                    if (d < "2020-02-10" && (t.preauthorizedAgentObjectId || t.correlationId)) throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
                    return t.version = d, t
                }
                class Container {
                    constructor(t) {
                        this.client = t
                    }
                    create(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, kl)
                    }
                    getProperties(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, zl)
                    }
                    delete(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Ll)
                    }
                    setMetadata(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Al)
                    }
                    getAccessPolicy(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Bl)
                    }
                    setAccessPolicy(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Il)
                    }
                    restore(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Ml)
                    }
                    rename(t, d) {
                        const h = {
                            sourceContainerName: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, ql)
                    }
                    submitBatch(t, d, h, y) {
                        const _ = {
                            contentLength: t,
                            multipartContentType: d,
                            body: h,
                            options: operationOptionsToRequestOptionsBase(y || {})
                        };
                        return this.client.sendOperationRequest(_, Dl)
                    }
                    acquireLease(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, jl)
                    }
                    releaseLease(t, d) {
                        const h = {
                            leaseId: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, Fl)
                    }
                    renewLease(t, d) {
                        const h = {
                            leaseId: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, Hl)
                    }
                    breakLease(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Ul)
                    }
                    changeLease(t, d, h) {
                        const y = {
                            leaseId: t,
                            proposedLeaseId: d,
                            options: operationOptionsToRequestOptionsBase(h || {})
                        };
                        return this.client.sendOperationRequest(y, $l)
                    }
                    listBlobFlatSegment(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Vl)
                    }
                    listBlobHierarchySegment(t, d) {
                        const h = {
                            delimiter: t,
                            options: operationOptionsToRequestOptionsBase(d || {})
                        };
                        return this.client.sendOperationRequest(h, Kl)
                    }
                    getAccountInfo(t) {
                        const d = {
                            options: operationOptionsToRequestOptionsBase(t || {})
                        };
                        return this.client.sendOperationRequest(d, Gl)
                    }
                }
                const Rl = new Serializer(y, !0),
                    kl = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: Yt
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Zt
                            }
                        },
                        queryParameters: [bi, Oi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ti, Ri, {
                            parameterPath: ["options", "containerEncryptionScope", "defaultEncryptionScope"],
                            mapper: {
                                serializedName: "x-ms-default-encryption-scope",
                                xmlName: "x-ms-default-encryption-scope",
                                type: {
                                    name: "String"
                                }
                            }
                        }, {
                            parameterPath: ["options", "containerEncryptionScope", "preventEncryptionScopeOverride"],
                            mapper: {
                                serializedName: "x-ms-deny-encryption-scope-override",
                                xmlName: "x-ms-deny-encryption-scope-override",
                                type: {
                                    name: "Boolean"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: Rl
                    },
                    zl = {
                        path: "/{containerName}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                headersMapper: er
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: tr
                            }
                        },
                        queryParameters: [bi, Oi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki],
                        isXML: !0,
                        serializer: Rl
                    },
                    Ll = {
                        path: "/{containerName}",
                        httpMethod: "DELETE",
                        responses: {
                            202: {
                                headersMapper: rr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: nr
                            }
                        },
                        queryParameters: [bi, Oi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki, zi, Li],
                        isXML: !0,
                        serializer: Rl
                    },
                    Al = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: ir
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: or
                            }
                        },
                        queryParameters: [bi, Oi, Ai],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, Ti, ki, zi],
                        isXML: !0,
                        serializer: Rl
                    },
                    Bl = {
                        path: "/{containerName}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                bodyMapper: {
                                    type: {
                                        name: "Sequence",
                                        element: {
                                            type: {
                                                name: "Composite",
                                                className: "SignedIdentifier"
                                            }
                                        }
                                    },
                                    serializedName: "SignedIdentifiers",
                                    xmlName: "SignedIdentifiers",
                                    xmlIsWrapped: !0,
                                    xmlElementName: "SignedIdentifier"
                                },
                                headersMapper: ar
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: sr
                            }
                        },
                        queryParameters: [bi, Oi, Bi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, ki],
                        isXML: !0,
                        serializer: Rl
                    },
                    Il = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: lr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: cr
                            }
                        },
                        requestBody: {
                            parameterPath: ["options", "containerAcl"],
                            mapper: {
                                serializedName: "containerAcl",
                                xmlName: "SignedIdentifiers",
                                xmlIsWrapped: !0,
                                xmlElementName: "SignedIdentifier",
                                type: {
                                    name: "Sequence",
                                    element: {
                                        type: {
                                            name: "Composite",
                                            className: "SignedIdentifier"
                                        }
                                    }
                                }
                            }
                        },
                        queryParameters: [bi, Oi, Bi],
                        urlParameters: [yi],
                        headerParameters: [fi, hi, vi, _i, Ri, ki, zi, Li],
                        isXML: !0,
                        contentType: "application/xml; charset=utf-8",
                        mediaType: "xml",
                        serializer: Rl
                    },
                    Ml = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: ur
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: dr
                            }
                        },
                        queryParameters: [bi, Oi, Ii],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, {
                            parameterPath: ["options", "deletedContainerName"],
                            mapper: {
                                serializedName: "x-ms-deleted-container-name",
                                xmlName: "x-ms-deleted-container-name",
                                type: {
                                    name: "String"
                                }
                            }
                        }, {
                            parameterPath: ["options", "deletedContainerVersion"],
                            mapper: {
                                serializedName: "x-ms-deleted-container-version",
                                xmlName: "x-ms-deleted-container-version",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: Rl
                    },
                    ql = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: pr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: mr
                            }
                        },
                        queryParameters: [bi, Oi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "rename",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, {
                            parameterPath: "sourceContainerName",
                            mapper: {
                                serializedName: "x-ms-source-container-name",
                                required: !0,
                                xmlName: "x-ms-source-container-name",
                                type: {
                                    name: "String"
                                }
                            }
                        }, {
                            parameterPath: ["options", "sourceLeaseId"],
                            mapper: {
                                serializedName: "x-ms-source-lease-id",
                                xmlName: "x-ms-source-lease-id",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        serializer: Rl
                    },
                    Dl = {
                        path: "/{containerName}",
                        httpMethod: "POST",
                        responses: {
                            202: {
                                bodyMapper: {
                                    type: {
                                        name: "Stream"
                                    },
                                    serializedName: "parsedResponse"
                                },
                                headersMapper: fr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: hr
                            }
                        },
                        requestBody: {
                            parameterPath: "body",
                            mapper: {
                                serializedName: "body",
                                required: !0,
                                xmlName: "body",
                                type: {
                                    name: "Stream"
                                }
                            }
                        },
                        queryParameters: [bi, {
                            parameterPath: "comp",
                            mapper: {
                                defaultValue: "batch",
                                isConstant: !0,
                                serializedName: "comp",
                                type: {
                                    name: "String"
                                }
                            }
                        }, Oi],
                        urlParameters: [yi],
                        headerParameters: [fi, hi, vi, _i, Ei, {
                            parameterPath: "multipartContentType",
                            mapper: {
                                serializedName: "Content-Type",
                                required: !0,
                                xmlName: "Content-Type",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        isXML: !0,
                        contentType: "application/xml; charset=utf-8",
                        mediaType: "xml",
                        serializer: Rl
                    },
                    jl = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            201: {
                                headersMapper: yr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: gr
                            }
                        },
                        queryParameters: [bi, Oi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, qi, Di, ji],
                        isXML: !0,
                        serializer: Rl
                    },
                    Fl = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: br
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: vr
                            }
                        },
                        queryParameters: [bi, Oi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, Fi, Hi],
                        isXML: !0,
                        serializer: Rl
                    },
                    Hl = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: _r
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: xr
                            }
                        },
                        queryParameters: [bi, Oi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, Hi, Ui],
                        isXML: !0,
                        serializer: Rl
                    },
                    Ul = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            202: {
                                headersMapper: Nr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Pr
                            }
                        },
                        queryParameters: [bi, Oi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, $i, Vi],
                        isXML: !0,
                        serializer: Rl
                    },
                    $l = {
                        path: "/{containerName}",
                        httpMethod: "PUT",
                        responses: {
                            200: {
                                headersMapper: Sr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: wr
                            }
                        },
                        queryParameters: [bi, Oi, Mi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi, zi, Li, Hi, Ki, Gi],
                        isXML: !0,
                        serializer: Rl
                    },
                    Vl = {
                        path: "/{containerName}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                bodyMapper: yt,
                                headersMapper: Cr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Er
                            }
                        },
                        queryParameters: [bi, Ni, Pi, Si, wi, Oi, Wi],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi],
                        isXML: !0,
                        serializer: Rl
                    },
                    Kl = {
                        path: "/{containerName}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                bodyMapper: _t,
                                headersMapper: Or
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: Tr
                            }
                        },
                        queryParameters: [bi, Ni, Pi, Si, wi, Oi, Wi, {
                            parameterPath: "delimiter",
                            mapper: {
                                serializedName: "delimiter",
                                required: !0,
                                xmlName: "delimiter",
                                type: {
                                    name: "String"
                                }
                            }
                        }],
                        urlParameters: [yi],
                        headerParameters: [vi, _i, xi],
                        isXML: !0,
                        serializer: Rl
                    },
                    Gl = {
                        path: "/{containerName}",
                        httpMethod: "GET",
                        responses: {
                            200: {
                                headersMapper: Rr
                            },
                            default: {
                                bodyMapper: rt,
                                headersMapper: kr
                            }
                        },
                        queryParameters: [gi, Ci],
                        urlParameters: [yi],
                        headerParameters: [vi, xi],
                        isXML: !0,
                        serializer: Rl
                    };
                class BlobLeaseClient {
                    constructor(t, d) {
                        const h = new StorageClientContext(t.url, t.pipeline.toServiceClientOptions());
                        this._url = t.url, void 0 === t.name ? (this._isContainer = !0, this._containerOrBlobOperation = new Container(h)) : (this._isContainer = !1, this._containerOrBlobOperation = new blob_Blob(h)), d || (d = generateUuid()), this._leaseId = d
                    }
                    get leaseId() {
                        return this._leaseId
                    }
                    get url() {
                        return this._url
                    }
                    async acquireLease(t, d = {}) {
                        var h, y, _, x, C, E;
                        const {
                            span: O,
                            updatedOptions: k
                        } = Ol("BlobLeaseClient-acquireLease", d);
                        if (this._isContainer && ((null === (h = d.conditions) || void 0 === h ? void 0 : h.ifMatch) && (null === (y = d.conditions) || void 0 === y ? void 0 : y.ifMatch) !== xs || (null === (_ = d.conditions) || void 0 === _ ? void 0 : _.ifNoneMatch) && (null === (x = d.conditions) || void 0 === x ? void 0 : x.ifNoneMatch) !== xs || (null === (C = d.conditions) || void 0 === C ? void 0 : C.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                        try {
                            return await this._containerOrBlobOperation.acquireLease(Object.assign({
                                abortSignal: d.abortSignal,
                                duration: t,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (E = d.conditions) || void 0 === E ? void 0 : E.tagConditions
                                }),
                                proposedLeaseId: this._leaseId
                            }, convertTracingToRequestOptionsBase(k)))
                        } catch (z) {
                            throw O.setStatus({
                                code: Ge.ERROR,
                                message: z.message
                            }), z
                        } finally {
                            O.end()
                        }
                    }
                    async changeLease(t, d = {}) {
                        var h, y, _, x, C, E;
                        const {
                            span: O,
                            updatedOptions: k
                        } = Ol("BlobLeaseClient-changeLease", d);
                        if (this._isContainer && ((null === (h = d.conditions) || void 0 === h ? void 0 : h.ifMatch) && (null === (y = d.conditions) || void 0 === y ? void 0 : y.ifMatch) !== xs || (null === (_ = d.conditions) || void 0 === _ ? void 0 : _.ifNoneMatch) && (null === (x = d.conditions) || void 0 === x ? void 0 : x.ifNoneMatch) !== xs || (null === (C = d.conditions) || void 0 === C ? void 0 : C.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                        try {
                            const h = await this._containerOrBlobOperation.changeLease(this._leaseId, t, Object.assign({
                                abortSignal: d.abortSignal,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (E = d.conditions) || void 0 === E ? void 0 : E.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(k)));
                            return this._leaseId = t, h
                        } catch (z) {
                            throw O.setStatus({
                                code: Ge.ERROR,
                                message: z.message
                            }), z
                        } finally {
                            O.end()
                        }
                    }
                    async releaseLease(t = {}) {
                        var d, h, y, _, x, C;
                        const {
                            span: E,
                            updatedOptions: O
                        } = Ol("BlobLeaseClient-releaseLease", t);
                        if (this._isContainer && ((null === (d = t.conditions) || void 0 === d ? void 0 : d.ifMatch) && (null === (h = t.conditions) || void 0 === h ? void 0 : h.ifMatch) !== xs || (null === (y = t.conditions) || void 0 === y ? void 0 : y.ifNoneMatch) && (null === (_ = t.conditions) || void 0 === _ ? void 0 : _.ifNoneMatch) !== xs || (null === (x = t.conditions) || void 0 === x ? void 0 : x.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                        try {
                            return await this._containerOrBlobOperation.releaseLease(this._leaseId, Object.assign({
                                abortSignal: t.abortSignal,
                                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), {
                                    ifTags: null === (C = t.conditions) || void 0 === C ? void 0 : C.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(O)))
                        } catch (k) {
                            throw E.setStatus({
                                code: Ge.ERROR,
                                message: k.message
                            }), k
                        } finally {
                            E.end()
                        }
                    }
                    async renewLease(t = {}) {
                        var d, h, y, _, x, C;
                        const {
                            span: E,
                            updatedOptions: O
                        } = Ol("BlobLeaseClient-renewLease", t);
                        if (this._isContainer && ((null === (d = t.conditions) || void 0 === d ? void 0 : d.ifMatch) && (null === (h = t.conditions) || void 0 === h ? void 0 : h.ifMatch) !== xs || (null === (y = t.conditions) || void 0 === y ? void 0 : y.ifNoneMatch) && (null === (_ = t.conditions) || void 0 === _ ? void 0 : _.ifNoneMatch) !== xs || (null === (x = t.conditions) || void 0 === x ? void 0 : x.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                        try {
                            return await this._containerOrBlobOperation.renewLease(this._leaseId, Object.assign({
                                abortSignal: t.abortSignal,
                                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), {
                                    ifTags: null === (C = t.conditions) || void 0 === C ? void 0 : C.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(O)))
                        } catch (k) {
                            throw E.setStatus({
                                code: Ge.ERROR,
                                message: k.message
                            }), k
                        } finally {
                            E.end()
                        }
                    }
                    async breakLease(t, d = {}) {
                        var h, y, _, x, C, E;
                        const {
                            span: O,
                            updatedOptions: k
                        } = Ol("BlobLeaseClient-breakLease", d);
                        if (this._isContainer && ((null === (h = d.conditions) || void 0 === h ? void 0 : h.ifMatch) && (null === (y = d.conditions) || void 0 === y ? void 0 : y.ifMatch) !== xs || (null === (_ = d.conditions) || void 0 === _ ? void 0 : _.ifNoneMatch) && (null === (x = d.conditions) || void 0 === x ? void 0 : x.ifNoneMatch) !== xs || (null === (C = d.conditions) || void 0 === C ? void 0 : C.tagConditions))) throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
                        try {
                            const h = Object.assign({
                                abortSignal: d.abortSignal,
                                breakPeriod: t,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (E = d.conditions) || void 0 === E ? void 0 : E.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(k));
                            return await this._containerOrBlobOperation.breakLease(h)
                        } catch (z) {
                            throw O.setStatus({
                                code: Ge.ERROR,
                                message: z.message
                            }), z
                        } finally {
                            O.end()
                        }
                    }
                }
                class BlobClient extends class StorageClient {
                    constructor(t, d) {
                        this.url = escapeURLPath(t), this.accountName = getAccountNameFromUrl(t), this.pipeline = d, this.storageClientContext = new StorageClientContext(this.url, d.toServiceClientOptions()), this.isHttps = function iEqual(t, d) {
                            return t.toLocaleLowerCase() === d.toLocaleLowerCase()
                        }(function getURLScheme(t) {
                            return url_URLBuilder.parse(t).getScheme()
                        }(this.url) || "", "https"), this.credential = new AnonymousCredential;
                        for (const h of this.pipeline.factories) H && h instanceof StorageSharedKeyCredential || h instanceof AnonymousCredential ? this.credential = h : isTokenCredential(h.credential) && (this.credential = h.credential);
                        this.storageClientContext.requestContentType = void 0
                    }
                } {
                    constructor(t, d, h, y) {
                        let _, x;
                        if (y = y || {}, isPipelineLike(d)) x = t, _ = d;
                        else if (H && d instanceof StorageSharedKeyCredential || d instanceof AnonymousCredential || isTokenCredential(d)) x = t, _ = newPipeline(d, y = h);
                        else if (d || "string" == typeof d) {
                            if (!d || "string" != typeof d || !h || "string" != typeof h) throw new Error("Expecting non-empty strings for containerName and blobName parameters"); {
                                const C = d,
                                    E = h,
                                    O = extractConnectionStringParts(t);
                                if ("AccountConnString" === O.kind) {
                                    if (!H) throw new Error("Account connection string is only supported in Node.js environment"); {
                                        const t = new StorageSharedKeyCredential(O.accountName, O.accountKey);
                                        x = appendToURLPath(appendToURLPath(O.url, encodeURIComponent(C)), encodeURIComponent(E)), y.proxyOptions = void O.proxyUri, _ = newPipeline(t, y)
                                    }
                                } else {
                                    if ("SASConnString" !== O.kind) throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                                    x = appendToURLPath(appendToURLPath(O.url, encodeURIComponent(C)), encodeURIComponent(E)) + "?" + O.accountSas, _ = newPipeline(new AnonymousCredential, y)
                                }
                            }
                        } else x = t, _ = newPipeline(new AnonymousCredential, y);
                        super(x, _), ({
                            blobName: this._name,
                            containerName: this._containerName
                        } = this.getBlobAndContainerNamesFromUrl()), this.blobContext = new blob_Blob(this.storageClientContext), this._snapshot = getURLParameter(this.url, gs.SNAPSHOT), this._versionId = getURLParameter(this.url, gs.VERSIONID)
                    }
                    get name() {
                        return this._name
                    }
                    get containerName() {
                        return this._containerName
                    }
                    withSnapshot(t) {
                        return new BlobClient(setURLParameter(this.url, gs.SNAPSHOT, 0 === t.length ? void 0 : t), this.pipeline)
                    }
                    withVersion(t) {
                        return new BlobClient(setURLParameter(this.url, gs.VERSIONID, 0 === t.length ? void 0 : t), this.pipeline)
                    }
                    getAppendBlobClient() {
                        return new AppendBlobClient(this.url, this.pipeline)
                    }
                    getBlockBlobClient() {
                        return new BlockBlobClient(this.url, this.pipeline)
                    }
                    getPageBlobClient() {
                        return new PageBlobClient(this.url, this.pipeline)
                    }
                    async download(t = 0, d, h = {}) {
                        var y;
                        h.conditions = h.conditions || {}, h.conditions = h.conditions || {}, ensureCpkIfSpecified(h.customerProvidedKey, this.isHttps);
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("BlobClient-download", h);
                        try {
                            const C = await this.blobContext.download(Object.assign({
                                    abortSignal: h.abortSignal,
                                    leaseAccessConditions: h.conditions,
                                    modifiedAccessConditions: Object.assign(Object.assign({}, h.conditions), {
                                        ifTags: null === (y = h.conditions) || void 0 === y ? void 0 : y.tagConditions
                                    }),
                                    requestOptions: {
                                        onDownloadProgress: H ? void 0 : h.onProgress
                                    },
                                    range: 0 !== t || d ? rangeToString({
                                        offset: t,
                                        count: d
                                    }) : void 0,
                                    rangeGetContentMD5: h.rangeGetContentMD5,
                                    rangeGetContentCRC64: h.rangeGetContentCrc64,
                                    snapshot: h.snapshot,
                                    cpkInfo: h.customerProvidedKey
                                }, convertTracingToRequestOptionsBase(x))),
                                E = Object.assign(Object.assign({}, C), {
                                    _response: C._response,
                                    objectReplicationDestinationPolicyId: C.objectReplicationPolicyId,
                                    objectReplicationSourceProperties: parseObjectReplicationRecord(C.objectReplicationRules)
                                });
                            if (!H) return E;
                            if ((void 0 === h.maxRetryRequests || h.maxRetryRequests < 0) && (h.maxRetryRequests = 5), void 0 === C.contentLength) throw new RangeError("File download response doesn't contain valid content length header");
                            if (!C.etag) throw new RangeError("File download response doesn't contain valid etag header");
                            return new 1(E, (async d => {
                                var y;
                                const _ = {
                                    leaseAccessConditions: h.conditions,
                                    modifiedAccessConditions: {
                                        ifMatch: h.conditions.ifMatch || C.etag,
                                        ifModifiedSince: h.conditions.ifModifiedSince,
                                        ifNoneMatch: h.conditions.ifNoneMatch,
                                        ifUnmodifiedSince: h.conditions.ifUnmodifiedSince,
                                        ifTags: null === (y = h.conditions) || void 0 === y ? void 0 : y.tagConditions
                                    },
                                    range: rangeToString({
                                        count: t + C.contentLength - d,
                                        offset: d
                                    }),
                                    rangeGetContentMD5: h.rangeGetContentMD5,
                                    rangeGetContentCRC64: h.rangeGetContentCrc64,
                                    snapshot: h.snapshot,
                                    cpkInfo: h.customerProvidedKey
                                };
                                return (await this.blobContext.download(Object.assign({
                                    abortSignal: h.abortSignal
                                }, _))).readableStreamBody
                            }), t, C.contentLength, {
                                maxRetryRequests: h.maxRetryRequests,
                                onProgress: h.onProgress
                            })
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    async exists(t = {}) {
                        const {
                            span: d,
                            updatedOptions: h
                        } = Ol("BlobClient-exists", t);
                        try {
                            return ensureCpkIfSpecified(t.customerProvidedKey, this.isHttps), await this.getProperties({
                                abortSignal: t.abortSignal,
                                customerProvidedKey: t.customerProvidedKey,
                                conditions: t.conditions,
                                tracingOptions: h.tracingOptions
                            }), !0
                        } catch (y) {
                            if (404 === y.statusCode) return d.setStatus({
                                code: Ge.ERROR,
                                message: "Expected exception when checking blob existence"
                            }), !1;
                            throw d.setStatus({
                                code: Ge.ERROR,
                                message: y.message
                            }), y
                        } finally {
                            d.end()
                        }
                    }
                    async getProperties(t = {}) {
                        var d;
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlobClient-getProperties", t);
                        try {
                            t.conditions = t.conditions || {}, ensureCpkIfSpecified(t.customerProvidedKey, this.isHttps);
                            const _ = await this.blobContext.getProperties(Object.assign({
                                abortSignal: t.abortSignal,
                                leaseAccessConditions: t.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), {
                                    ifTags: null === (d = t.conditions) || void 0 === d ? void 0 : d.tagConditions
                                }),
                                cpkInfo: t.customerProvidedKey
                            }, convertTracingToRequestOptionsBase(y)));
                            return Object.assign(Object.assign({}, _), {
                                _response: _._response,
                                objectReplicationDestinationPolicyId: _.objectReplicationPolicyId,
                                objectReplicationSourceProperties: parseObjectReplicationRecord(_.objectReplicationRules)
                            })
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async delete(t = {}) {
                        var d;
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlobClient-delete", t);
                        t.conditions = t.conditions || {};
                        try {
                            return await this.blobContext.delete(Object.assign({
                                abortSignal: t.abortSignal,
                                deleteSnapshots: t.deleteSnapshots,
                                leaseAccessConditions: t.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), {
                                    ifTags: null === (d = t.conditions) || void 0 === d ? void 0 : d.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(y)))
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async deleteIfExists(t = {}) {
                        var d, h;
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("BlobClient-deleteIfExists", t);
                        try {
                            const t = await this.delete(_);
                            return Object.assign(Object.assign({
                                succeeded: !0
                            }, t), {
                                _response: t._response
                            })
                        } catch (x) {
                            if ("BlobNotFound" === (null === (d = x.details) || void 0 === d ? void 0 : d.errorCode)) return y.setStatus({
                                code: Ge.ERROR,
                                message: "Expected exception when deleting a blob or snapshot only if it exists."
                            }), Object.assign(Object.assign({
                                succeeded: !1
                            }, null === (h = x.response) || void 0 === h ? void 0 : h.parsedHeaders), {
                                _response: x.response
                            });
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async undelete(t = {}) {
                        const {
                            span: d,
                            updatedOptions: h
                        } = Ol("BlobClient-undelete", t);
                        try {
                            return await this.blobContext.undelete(Object.assign({
                                abortSignal: t.abortSignal
                            }, convertTracingToRequestOptionsBase(h)))
                        } catch (y) {
                            throw d.setStatus({
                                code: Ge.ERROR,
                                message: y.message
                            }), y
                        } finally {
                            d.end()
                        }
                    }
                    async setHTTPHeaders(t, d = {}) {
                        var h;
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("BlobClient-setHTTPHeaders", d);
                        d.conditions = d.conditions || {};
                        try {
                            return ensureCpkIfSpecified(d.customerProvidedKey, this.isHttps), await this.blobContext.setHttpHeaders(Object.assign({
                                abortSignal: d.abortSignal,
                                blobHttpHeaders: t,
                                leaseAccessConditions: d.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(_)))
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async setMetadata(t, d = {}) {
                        var h;
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("BlobClient-setMetadata", d);
                        d.conditions = d.conditions || {};
                        try {
                            return ensureCpkIfSpecified(d.customerProvidedKey, this.isHttps), await this.blobContext.setMetadata(Object.assign({
                                abortSignal: d.abortSignal,
                                leaseAccessConditions: d.conditions,
                                metadata: t,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                }),
                                cpkInfo: d.customerProvidedKey,
                                encryptionScope: d.encryptionScope
                            }, convertTracingToRequestOptionsBase(_)))
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async setTags(t, d = {}) {
                        var h;
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("BlobClient-setTags", d);
                        try {
                            return await this.blobContext.setTags(Object.assign(Object.assign({
                                abortSignal: d.abortSignal,
                                leaseAccessConditions: d.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(_)), {
                                tags: toBlobTags(t)
                            }))
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async getTags(t = {}) {
                        var d;
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlobClient-getTags", t);
                        try {
                            const _ = await this.blobContext.getTags(Object.assign({
                                abortSignal: t.abortSignal,
                                leaseAccessConditions: t.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), {
                                    ifTags: null === (d = t.conditions) || void 0 === d ? void 0 : d.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(y)));
                            return Object.assign(Object.assign({}, _), {
                                _response: _._response,
                                tags: toTags({
                                    blobTagSet: _.blobTagSet
                                }) || {}
                            })
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    getBlobLeaseClient(t) {
                        return new BlobLeaseClient(this, t)
                    }
                    async createSnapshot(t = {}) {
                        var d;
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlobClient-createSnapshot", t);
                        t.conditions = t.conditions || {};
                        try {
                            return ensureCpkIfSpecified(t.customerProvidedKey, this.isHttps), await this.blobContext.createSnapshot(Object.assign({
                                abortSignal: t.abortSignal,
                                leaseAccessConditions: t.conditions,
                                metadata: t.metadata,
                                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), {
                                    ifTags: null === (d = t.conditions) || void 0 === d ? void 0 : d.tagConditions
                                }),
                                cpkInfo: t.customerProvidedKey,
                                encryptionScope: t.encryptionScope
                            }, convertTracingToRequestOptionsBase(y)))
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async beginCopyFromURL(t, d = {}) {
                        const h = new BlobBeginCopyFromUrlPoller({
                            blobClient: {
                                abortCopyFromURL: (...t) => this.abortCopyFromURL(...t),
                                getProperties: (...t) => this.getProperties(...t),
                                startCopyFromURL: (...t) => this.startCopyFromURL(...t)
                            },
                            copySource: t,
                            intervalInMs: d.intervalInMs,
                            onProgress: d.onProgress,
                            resumeFrom: d.resumeFrom,
                            startCopyFromURLOptions: d
                        });
                        return await h.poll(), h
                    }
                    async abortCopyFromURL(t, d = {}) {
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlobClient-abortCopyFromURL", d);
                        try {
                            return await this.blobContext.abortCopyFromURL(t, Object.assign({
                                abortSignal: d.abortSignal,
                                leaseAccessConditions: d.conditions
                            }, convertTracingToRequestOptionsBase(y)))
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async syncCopyFromURL(t, d = {}) {
                        var h, y, _;
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("BlobClient-syncCopyFromURL", d);
                        d.conditions = d.conditions || {}, d.sourceConditions = d.sourceConditions || {};
                        try {
                            return await this.blobContext.copyFromURL(t, Object.assign({
                                abortSignal: d.abortSignal,
                                metadata: d.metadata,
                                leaseAccessConditions: d.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                }),
                                sourceModifiedAccessConditions: {
                                    sourceIfMatch: d.sourceConditions.ifMatch,
                                    sourceIfModifiedSince: d.sourceConditions.ifModifiedSince,
                                    sourceIfNoneMatch: d.sourceConditions.ifNoneMatch,
                                    sourceIfUnmodifiedSince: d.sourceConditions.ifUnmodifiedSince
                                },
                                sourceContentMD5: d.sourceContentMD5,
                                copySourceAuthorization: httpAuthorizationToString(d.sourceAuthorization),
                                blobTagsString: toBlobTagsString(d.tags),
                                immutabilityPolicyExpiry: null === (y = d.immutabilityPolicy) || void 0 === y ? void 0 : y.expiriesOn,
                                immutabilityPolicyMode: null === (_ = d.immutabilityPolicy) || void 0 === _ ? void 0 : _.policyMode,
                                legalHold: d.legalHold
                            }, convertTracingToRequestOptionsBase(C)))
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                    async setAccessTier(t, d = {}) {
                        var h;
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("BlobClient-setAccessTier", d);
                        try {
                            return await this.blobContext.setTier(toAccessTier(t), Object.assign({
                                abortSignal: d.abortSignal,
                                leaseAccessConditions: d.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                }),
                                rehydratePriority: d.rehydratePriority
                            }, convertTracingToRequestOptionsBase(_)))
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async downloadToBuffer(t, d, h, y = {}) {
                        let _, x = 0,
                            C = 0,
                            E = y;
                        t instanceof Buffer ? (_ = t, x = d || 0, C = "number" == typeof h ? h : 0) : (x = "number" == typeof t ? t : 0, C = "number" == typeof d ? d : 0, E = h || {});
                        const {
                            span: O,
                            updatedOptions: k
                        } = Ol("BlobClient-downloadToBuffer", E);
                        try {
                            if (E.blockSize || (E.blockSize = 0), E.blockSize < 0) throw new RangeError("blockSize option must be >= 0");
                            if (0 === E.blockSize && (E.blockSize = ys), x < 0) throw new RangeError("offset option must be >= 0");
                            if (C && C <= 0) throw new RangeError("count option must be greater than 0");
                            if (E.conditions || (E.conditions = {}), !C) {
                                const t = await this.getProperties(Object.assign(Object.assign({}, E), {
                                    tracingOptions: Object.assign(Object.assign({}, E.tracingOptions), convertTracingToRequestOptionsBase(k))
                                }));
                                if (C = t.contentLength - x, C < 0) throw new RangeError(`offset ${x} shouldn't be larger than blob size ${t.contentLength}`)
                            }
                            if (!_) try {
                                _ = Buffer.alloc(C)
                            } catch (z) {
                                throw new Error(`Unable to allocate the buffer of size: ${C}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".\t ${z.message}`)
                            }
                            if (_.length < C) throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${C}`);
                            let t = 0;
                            const d = new Batch(E.concurrency);
                            for (let h = x; h < x + C; h += E.blockSize) d.addOperation((async () => {
                                let d = x + C;
                                h + E.blockSize < d && (d = h + E.blockSize);
                                (await this.download(h, d - h, {
                                    abortSignal: E.abortSignal,
                                    conditions: E.conditions,
                                    maxRetryRequests: E.maxRetryRequestsPerBlock,
                                    customerProvidedKey: E.customerProvidedKey,
                                    tracingOptions: Object.assign(Object.assign({}, E.tracingOptions), convertTracingToRequestOptionsBase(k))
                                })).readableStreamBody;
                                await void 0, t += d - h, E.onProgress && E.onProgress({
                                    loadedBytes: t
                                })
                            }));
                            return await d.do(), _
                        } catch (A) {
                            throw O.setStatus({
                                code: Ge.ERROR,
                                message: A.message
                            }), A
                        } finally {
                            O.end()
                        }
                    }
                    async downloadToFile(t, d = 0, h, y = {}) {
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("BlobClient-downloadToFile", y);
                        try {
                            const t = await this.download(d, h, Object.assign(Object.assign({}, y), {
                                tracingOptions: Object.assign(Object.assign({}, y.tracingOptions), convertTracingToRequestOptionsBase(x))
                            }));
                            return t.readableStreamBody && await void t.readableStreamBody, t.blobDownloadStream = void 0, t
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    getBlobAndContainerNamesFromUrl() {
                        let t, d;
                        try {
                            const h = url_URLBuilder.parse(this.url);
                            if ("blob" === h.getHost().split(".")[1]) {
                                const y = h.getPath().match("/([^/]*)(/(.*))?");
                                t = y[1], d = y[3]
                            } else if (isIpEndpointStyle(h)) {
                                const y = h.getPath().match("/([^/]*)/([^/]*)(/(.*))?");
                                t = y[2], d = y[4]
                            } else {
                                const y = h.getPath().match("/([^/]*)(/(.*))?");
                                t = y[1], d = y[3]
                            }
                            if (t = decodeURIComponent(t), d = decodeURIComponent(d), d = d.replace(/\\/g, "/"), !t) throw new Error("Provided containerName is invalid.");
                            return {
                                blobName: d,
                                containerName: t
                            }
                        } catch (h) {
                            throw new Error("Unable to extract blobName and containerName with provided information.")
                        }
                    }
                    async startCopyFromURL(t, d = {}) {
                        var h, y, _;
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("BlobClient-startCopyFromURL", d);
                        d.conditions = d.conditions || {}, d.sourceConditions = d.sourceConditions || {};
                        try {
                            return await this.blobContext.startCopyFromURL(t, Object.assign({
                                abortSignal: d.abortSignal,
                                leaseAccessConditions: d.conditions,
                                metadata: d.metadata,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                }),
                                sourceModifiedAccessConditions: {
                                    sourceIfMatch: d.sourceConditions.ifMatch,
                                    sourceIfModifiedSince: d.sourceConditions.ifModifiedSince,
                                    sourceIfNoneMatch: d.sourceConditions.ifNoneMatch,
                                    sourceIfUnmodifiedSince: d.sourceConditions.ifUnmodifiedSince,
                                    sourceIfTags: d.sourceConditions.tagConditions
                                },
                                immutabilityPolicyExpiry: null === (y = d.immutabilityPolicy) || void 0 === y ? void 0 : y.expiriesOn,
                                immutabilityPolicyMode: null === (_ = d.immutabilityPolicy) || void 0 === _ ? void 0 : _.policyMode,
                                legalHold: d.legalHold,
                                rehydratePriority: d.rehydratePriority,
                                tier: toAccessTier(d.tier),
                                blobTagsString: toBlobTagsString(d.tags),
                                sealBlob: d.sealBlob
                            }, convertTracingToRequestOptionsBase(C)))
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                    generateSasUrl(t) {
                        return new Promise((d => {
                            if (!(this.credential instanceof StorageSharedKeyCredential)) throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
                            const h = generateBlobSASQueryParameters(Object.assign({
                                containerName: this._containerName,
                                blobName: this._name,
                                snapshotTime: this._snapshot,
                                versionId: this._versionId
                            }, t), this.credential).toString();
                            d(function appendToURLQuery(t, d) {
                                const h = url_URLBuilder.parse(t);
                                let y = h.getQuery();
                                return y ? y += "&" + d : y = d, h.setQuery(y), h.toString()
                            }(this.url, h))
                        }))
                    }
                    async deleteImmutabilityPolicy(t) {
                        const {
                            span: d,
                            updatedOptions: h
                        } = Ol("BlobClient-deleteImmutabilityPolicy", t);
                        try {
                            return await this.blobContext.deleteImmutabilityPolicy(Object.assign({
                                abortSignal: null == t ? void 0 : t.abortSignal
                            }, convertTracingToRequestOptionsBase(h)))
                        } catch (y) {
                            throw d.setStatus({
                                code: Ge.ERROR,
                                message: y.message
                            }), y
                        } finally {
                            d.end()
                        }
                    }
                    async setImmutabilityPolicy(t, d) {
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlobClient-setImmutabilityPolicy", d);
                        try {
                            return await this.blobContext.setImmutabilityPolicy(Object.assign({
                                abortSignal: null == d ? void 0 : d.abortSignal,
                                immutabilityPolicyExpiry: t.expiriesOn,
                                immutabilityPolicyMode: t.policyMode,
                                modifiedAccessConditions: null == d ? void 0 : d.modifiedAccessCondition
                            }, convertTracingToRequestOptionsBase(y)))
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async setLegalHold(t, d) {
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlobClient-setLegalHold", d);
                        try {
                            return await this.blobContext.setLegalHold(t, Object.assign({
                                abortSignal: null == d ? void 0 : d.abortSignal
                            }, convertTracingToRequestOptionsBase(y)))
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                }
                class AppendBlobClient extends BlobClient {
                    constructor(t, d, h, y) {
                        let _, x;
                        if (y = y || {}, isPipelineLike(d)) x = t, _ = d;
                        else if (H && d instanceof StorageSharedKeyCredential || d instanceof AnonymousCredential || isTokenCredential(d)) x = t, _ = newPipeline(d, y = h);
                        else if (d || "string" == typeof d) {
                            if (!d || "string" != typeof d || !h || "string" != typeof h) throw new Error("Expecting non-empty strings for containerName and blobName parameters"); {
                                const C = d,
                                    E = h,
                                    O = extractConnectionStringParts(t);
                                if ("AccountConnString" === O.kind) {
                                    if (!H) throw new Error("Account connection string is only supported in Node.js environment"); {
                                        const t = new StorageSharedKeyCredential(O.accountName, O.accountKey);
                                        x = appendToURLPath(appendToURLPath(O.url, encodeURIComponent(C)), encodeURIComponent(E)), y.proxyOptions = void O.proxyUri, _ = newPipeline(t, y)
                                    }
                                } else {
                                    if ("SASConnString" !== O.kind) throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                                    x = appendToURLPath(appendToURLPath(O.url, encodeURIComponent(C)), encodeURIComponent(E)) + "?" + O.accountSas, _ = newPipeline(new AnonymousCredential, y)
                                }
                            }
                        } else x = t, _ = newPipeline(new AnonymousCredential, y);
                        super(x, _), this.appendBlobContext = new AppendBlob(this.storageClientContext)
                    }
                    withSnapshot(t) {
                        return new AppendBlobClient(setURLParameter(this.url, gs.SNAPSHOT, 0 === t.length ? void 0 : t), this.pipeline)
                    }
                    async create(t = {}) {
                        var d, h, y;
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("AppendBlobClient-create", t);
                        t.conditions = t.conditions || {};
                        try {
                            return ensureCpkIfSpecified(t.customerProvidedKey, this.isHttps), await this.appendBlobContext.create(0, Object.assign({
                                abortSignal: t.abortSignal,
                                blobHttpHeaders: t.blobHTTPHeaders,
                                leaseAccessConditions: t.conditions,
                                metadata: t.metadata,
                                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), {
                                    ifTags: null === (d = t.conditions) || void 0 === d ? void 0 : d.tagConditions
                                }),
                                cpkInfo: t.customerProvidedKey,
                                encryptionScope: t.encryptionScope,
                                immutabilityPolicyExpiry: null === (h = t.immutabilityPolicy) || void 0 === h ? void 0 : h.expiriesOn,
                                immutabilityPolicyMode: null === (y = t.immutabilityPolicy) || void 0 === y ? void 0 : y.policyMode,
                                legalHold: t.legalHold,
                                blobTagsString: toBlobTagsString(t.tags)
                            }, convertTracingToRequestOptionsBase(x)))
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    async createIfNotExists(t = {}) {
                        var d, h;
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("AppendBlobClient-createIfNotExists", t), x = {
                            ifNoneMatch: "*"
                        };
                        try {
                            const t = await this.create(Object.assign(Object.assign({}, _), {
                                conditions: x
                            }));
                            return Object.assign(Object.assign({
                                succeeded: !0
                            }, t), {
                                _response: t._response
                            })
                        } catch (C) {
                            if ("BlobAlreadyExists" === (null === (d = C.details) || void 0 === d ? void 0 : d.errorCode)) return y.setStatus({
                                code: Ge.ERROR,
                                message: "Expected exception when creating a blob only if it does not already exist."
                            }), Object.assign(Object.assign({
                                succeeded: !1
                            }, null === (h = C.response) || void 0 === h ? void 0 : h.parsedHeaders), {
                                _response: C.response
                            });
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            y.end()
                        }
                    }
                    async seal(t = {}) {
                        var d;
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("AppendBlobClient-seal", t);
                        t.conditions = t.conditions || {};
                        try {
                            return await this.appendBlobContext.seal(Object.assign({
                                abortSignal: t.abortSignal,
                                appendPositionAccessConditions: t.conditions,
                                leaseAccessConditions: t.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, t.conditions), {
                                    ifTags: null === (d = t.conditions) || void 0 === d ? void 0 : d.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(y)))
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async appendBlock(t, d, h = {}) {
                        var y;
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("AppendBlobClient-appendBlock", h);
                        h.conditions = h.conditions || {};
                        try {
                            return ensureCpkIfSpecified(h.customerProvidedKey, this.isHttps), await this.appendBlobContext.appendBlock(d, t, Object.assign({
                                abortSignal: h.abortSignal,
                                appendPositionAccessConditions: h.conditions,
                                leaseAccessConditions: h.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, h.conditions), {
                                    ifTags: null === (y = h.conditions) || void 0 === y ? void 0 : y.tagConditions
                                }),
                                requestOptions: {
                                    onUploadProgress: h.onProgress
                                },
                                transactionalContentMD5: h.transactionalContentMD5,
                                transactionalContentCrc64: h.transactionalContentCrc64,
                                cpkInfo: h.customerProvidedKey,
                                encryptionScope: h.encryptionScope
                            }, convertTracingToRequestOptionsBase(x)))
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    async appendBlockFromURL(t, d, h, y = {}) {
                        var _;
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("AppendBlobClient-appendBlockFromURL", y);
                        y.conditions = y.conditions || {}, y.sourceConditions = y.sourceConditions || {};
                        try {
                            return ensureCpkIfSpecified(y.customerProvidedKey, this.isHttps), await this.appendBlobContext.appendBlockFromUrl(t, 0, Object.assign({
                                abortSignal: y.abortSignal,
                                sourceRange: rangeToString({
                                    offset: d,
                                    count: h
                                }),
                                sourceContentMD5: y.sourceContentMD5,
                                sourceContentCrc64: y.sourceContentCrc64,
                                leaseAccessConditions: y.conditions,
                                appendPositionAccessConditions: y.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, y.conditions), {
                                    ifTags: null === (_ = y.conditions) || void 0 === _ ? void 0 : _.tagConditions
                                }),
                                sourceModifiedAccessConditions: {
                                    sourceIfMatch: y.sourceConditions.ifMatch,
                                    sourceIfModifiedSince: y.sourceConditions.ifModifiedSince,
                                    sourceIfNoneMatch: y.sourceConditions.ifNoneMatch,
                                    sourceIfUnmodifiedSince: y.sourceConditions.ifUnmodifiedSince
                                },
                                copySourceAuthorization: httpAuthorizationToString(y.sourceAuthorization),
                                cpkInfo: y.customerProvidedKey,
                                encryptionScope: y.encryptionScope
                            }, convertTracingToRequestOptionsBase(C)))
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                }
                class BlockBlobClient extends BlobClient {
                    constructor(t, d, h, y) {
                        let _, x;
                        if (y = y || {}, isPipelineLike(d)) x = t, _ = d;
                        else if (H && d instanceof StorageSharedKeyCredential || d instanceof AnonymousCredential || isTokenCredential(d)) x = t, _ = newPipeline(d, y = h);
                        else if (d || "string" == typeof d) {
                            if (!d || "string" != typeof d || !h || "string" != typeof h) throw new Error("Expecting non-empty strings for containerName and blobName parameters"); {
                                const C = d,
                                    E = h,
                                    O = extractConnectionStringParts(t);
                                if ("AccountConnString" === O.kind) {
                                    if (!H) throw new Error("Account connection string is only supported in Node.js environment"); {
                                        const t = new StorageSharedKeyCredential(O.accountName, O.accountKey);
                                        x = appendToURLPath(appendToURLPath(O.url, encodeURIComponent(C)), encodeURIComponent(E)), y.proxyOptions = void O.proxyUri, _ = newPipeline(t, y)
                                    }
                                } else {
                                    if ("SASConnString" !== O.kind) throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                                    x = appendToURLPath(appendToURLPath(O.url, encodeURIComponent(C)), encodeURIComponent(E)) + "?" + O.accountSas, _ = newPipeline(new AnonymousCredential, y)
                                }
                            }
                        } else x = t, _ = newPipeline(new AnonymousCredential, y);
                        super(x, _), this.blockBlobContext = new BlockBlob(this.storageClientContext), this._blobContext = new blob_Blob(this.storageClientContext)
                    }
                    withSnapshot(t) {
                        return new BlockBlobClient(setURLParameter(this.url, gs.SNAPSHOT, 0 === t.length ? void 0 : t), this.pipeline)
                    }
                    async query(t, d = {}) {
                        var h;
                        ensureCpkIfSpecified(d.customerProvidedKey, this.isHttps);
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("BlockBlobClient-query", d);
                        try {
                            if (!H) throw new Error("This operation currently is only supported in Node.js.");
                            const x = await this._blobContext.query(Object.assign({
                                abortSignal: d.abortSignal,
                                queryRequest: {
                                    queryType: "SQL",
                                    expression: t,
                                    inputSerialization: toQuerySerialization(d.inputTextConfiguration),
                                    outputSerialization: toQuerySerialization(d.outputTextConfiguration)
                                },
                                leaseAccessConditions: d.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(_)));
                            return new BlobQueryResponse(x, {
                                abortSignal: d.abortSignal,
                                onProgress: d.onProgress,
                                onError: d.onError
                            })
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async upload(t, d, h = {}) {
                        var y, _, x;
                        h.conditions = h.conditions || {};
                        const {
                            span: C,
                            updatedOptions: E
                        } = Ol("BlockBlobClient-upload", h);
                        try {
                            return ensureCpkIfSpecified(h.customerProvidedKey, this.isHttps), await this.blockBlobContext.upload(d, t, Object.assign({
                                abortSignal: h.abortSignal,
                                blobHttpHeaders: h.blobHTTPHeaders,
                                leaseAccessConditions: h.conditions,
                                metadata: h.metadata,
                                modifiedAccessConditions: Object.assign(Object.assign({}, h.conditions), {
                                    ifTags: null === (y = h.conditions) || void 0 === y ? void 0 : y.tagConditions
                                }),
                                requestOptions: {
                                    onUploadProgress: h.onProgress
                                },
                                cpkInfo: h.customerProvidedKey,
                                encryptionScope: h.encryptionScope,
                                immutabilityPolicyExpiry: null === (_ = h.immutabilityPolicy) || void 0 === _ ? void 0 : _.expiriesOn,
                                immutabilityPolicyMode: null === (x = h.immutabilityPolicy) || void 0 === x ? void 0 : x.policyMode,
                                legalHold: h.legalHold,
                                tier: toAccessTier(h.tier),
                                blobTagsString: toBlobTagsString(h.tags)
                            }, convertTracingToRequestOptionsBase(E)))
                        } catch (O) {
                            throw C.setStatus({
                                code: Ge.ERROR,
                                message: O.message
                            }), O
                        } finally {
                            C.end()
                        }
                    }
                    async syncUploadFromURL(t, d = {}) {
                        var h, y, _, x, C;
                        d.conditions = d.conditions || {};
                        const {
                            span: E,
                            updatedOptions: O
                        } = Ol("BlockBlobClient-syncUploadFromURL", d);
                        try {
                            return ensureCpkIfSpecified(d.customerProvidedKey, this.isHttps), await this.blockBlobContext.putBlobFromUrl(0, t, Object.assign(Object.assign(Object.assign({}, d), {
                                blobHttpHeaders: d.blobHTTPHeaders,
                                leaseAccessConditions: d.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: d.conditions.tagConditions
                                }),
                                sourceModifiedAccessConditions: {
                                    sourceIfMatch: null === (h = d.sourceConditions) || void 0 === h ? void 0 : h.ifMatch,
                                    sourceIfModifiedSince: null === (y = d.sourceConditions) || void 0 === y ? void 0 : y.ifModifiedSince,
                                    sourceIfNoneMatch: null === (_ = d.sourceConditions) || void 0 === _ ? void 0 : _.ifNoneMatch,
                                    sourceIfUnmodifiedSince: null === (x = d.sourceConditions) || void 0 === x ? void 0 : x.ifUnmodifiedSince,
                                    sourceIfTags: null === (C = d.sourceConditions) || void 0 === C ? void 0 : C.tagConditions
                                },
                                cpkInfo: d.customerProvidedKey,
                                copySourceAuthorization: httpAuthorizationToString(d.sourceAuthorization),
                                tier: toAccessTier(d.tier),
                                blobTagsString: toBlobTagsString(d.tags)
                            }), convertTracingToRequestOptionsBase(O)))
                        } catch (k) {
                            throw E.setStatus({
                                code: Ge.ERROR,
                                message: k.message
                            }), k
                        } finally {
                            E.end()
                        }
                    }
                    async stageBlock(t, d, h, y = {}) {
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("BlockBlobClient-stageBlock", y);
                        try {
                            return ensureCpkIfSpecified(y.customerProvidedKey, this.isHttps), await this.blockBlobContext.stageBlock(t, h, d, Object.assign({
                                abortSignal: y.abortSignal,
                                leaseAccessConditions: y.conditions,
                                requestOptions: {
                                    onUploadProgress: y.onProgress
                                },
                                transactionalContentMD5: y.transactionalContentMD5,
                                transactionalContentCrc64: y.transactionalContentCrc64,
                                cpkInfo: y.customerProvidedKey,
                                encryptionScope: y.encryptionScope
                            }, convertTracingToRequestOptionsBase(x)))
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    async stageBlockFromURL(t, d, h = 0, y, _ = {}) {
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("BlockBlobClient-stageBlockFromURL", _);
                        try {
                            return ensureCpkIfSpecified(_.customerProvidedKey, this.isHttps), await this.blockBlobContext.stageBlockFromURL(t, 0, d, Object.assign({
                                abortSignal: _.abortSignal,
                                leaseAccessConditions: _.conditions,
                                sourceContentMD5: _.sourceContentMD5,
                                sourceContentCrc64: _.sourceContentCrc64,
                                sourceRange: 0 !== h || y ? rangeToString({
                                    offset: h,
                                    count: y
                                }) : void 0,
                                cpkInfo: _.customerProvidedKey,
                                encryptionScope: _.encryptionScope,
                                copySourceAuthorization: httpAuthorizationToString(_.sourceAuthorization)
                            }, convertTracingToRequestOptionsBase(C)))
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                    async commitBlockList(t, d = {}) {
                        var h, y, _;
                        d.conditions = d.conditions || {};
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("BlockBlobClient-commitBlockList", d);
                        try {
                            return ensureCpkIfSpecified(d.customerProvidedKey, this.isHttps), await this.blockBlobContext.commitBlockList({
                                latest: t
                            }, Object.assign({
                                abortSignal: d.abortSignal,
                                blobHttpHeaders: d.blobHTTPHeaders,
                                leaseAccessConditions: d.conditions,
                                metadata: d.metadata,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                }),
                                cpkInfo: d.customerProvidedKey,
                                encryptionScope: d.encryptionScope,
                                immutabilityPolicyExpiry: null === (y = d.immutabilityPolicy) || void 0 === y ? void 0 : y.expiriesOn,
                                immutabilityPolicyMode: null === (_ = d.immutabilityPolicy) || void 0 === _ ? void 0 : _.policyMode,
                                legalHold: d.legalHold,
                                tier: toAccessTier(d.tier),
                                blobTagsString: toBlobTagsString(d.tags)
                            }, convertTracingToRequestOptionsBase(C)))
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                    async getBlockList(t, d = {}) {
                        var h;
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("BlockBlobClient-getBlockList", d);
                        try {
                            const x = await this.blockBlobContext.getBlockList(t, Object.assign({
                                abortSignal: d.abortSignal,
                                leaseAccessConditions: d.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(_)));
                            return x.committedBlocks || (x.committedBlocks = []), x.uncommittedBlocks || (x.uncommittedBlocks = []), x
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async uploadData(t, d = {}) {
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlockBlobClient-uploadData", d);
                        try {
                            if (H) {
                                let d;
                                return t instanceof Buffer ? d = t : t instanceof ArrayBuffer ? d = Buffer.from(t) : (t = t, d = Buffer.from(t.buffer, t.byteOffset, t.byteLength)), this.uploadSeekableInternal(((t, h) => d.slice(t, t + h)), d.byteLength, y)
                            } {
                                const d = new Blob([t]);
                                return this.uploadSeekableInternal(((t, h) => d.slice(t, t + h)), d.size, y)
                            }
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async uploadBrowserData(t, d = {}) {
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlockBlobClient-uploadBrowserData", d);
                        try {
                            const d = new Blob([t]);
                            return await this.uploadSeekableInternal(((t, h) => d.slice(t, t + h)), d.size, y)
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async uploadSeekableInternal(t, d, h = {}) {
                        if (h.blockSize || (h.blockSize = 0), h.blockSize < 0 || h.blockSize > fs) throw new RangeError("blockSize option must be >= 0 and <= 4194304000");
                        if (0 === h.maxSingleShotSize || h.maxSingleShotSize || (h.maxSingleShotSize = ms), h.maxSingleShotSize < 0 || h.maxSingleShotSize > ms) throw new RangeError("maxSingleShotSize option must be >= 0 and <= 268435456");
                        if (0 === h.blockSize) {
                            if (d > 2097152e8) throw new RangeError(`${d} is too larger to upload to a block blob.`);
                            d > h.maxSingleShotSize && (h.blockSize = Math.ceil(d / hs), h.blockSize < ys && (h.blockSize = ys))
                        }
                        h.blobHTTPHeaders || (h.blobHTTPHeaders = {}), h.conditions || (h.conditions = {});
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("BlockBlobClient-uploadSeekableInternal", h);
                        try {
                            if (d <= h.maxSingleShotSize) return await this.upload(t(0, d), d, _);
                            const x = Math.floor((d - 1) / h.blockSize) + 1;
                            if (x > hs) throw new RangeError("The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= 50000");
                            const C = [],
                                E = generateUuid();
                            let O = 0;
                            const k = new Batch(h.concurrency);
                            for (let y = 0; y < x; y++) k.addOperation((async () => {
                                const k = generateBlockID(E, y),
                                    z = h.blockSize * y,
                                    A = (y === x - 1 ? d : z + h.blockSize) - z;
                                C.push(k), await this.stageBlock(k, t(z, A), A, {
                                    abortSignal: h.abortSignal,
                                    conditions: h.conditions,
                                    encryptionScope: h.encryptionScope,
                                    tracingOptions: _.tracingOptions
                                }), O += A, h.onProgress && h.onProgress({
                                    loadedBytes: O
                                })
                            }));
                            return await k.do(), this.commitBlockList(C, _)
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async uploadFile(t, d = {}) {
                        const {
                            span: h,
                            updatedOptions: y
                        } = Ol("BlockBlobClient-uploadFile", d);
                        try {
                            const t = (await void 0).size;
                            return await this.uploadSeekableInternal(((t, d) => () => {}), t, Object.assign(Object.assign({}, d), {
                                tracingOptions: Object.assign(Object.assign({}, d.tracingOptions), convertTracingToRequestOptionsBase(y))
                            }))
                        } catch (_) {
                            throw h.setStatus({
                                code: Ge.ERROR,
                                message: _.message
                            }), _
                        } finally {
                            h.end()
                        }
                    }
                    async uploadStream(t, d = 8388608, h = 5, y = {}) {
                        y.blobHTTPHeaders || (y.blobHTTPHeaders = {}), y.conditions || (y.conditions = {});
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("BlockBlobClient-uploadStream", y);
                        try {
                            let C = 0;
                            const E = generateUuid();
                            let O = 0;
                            const k = [],
                                z = new BufferScheduler(t, d, h, (async (t, d) => {
                                    const h = generateBlockID(E, C);
                                    k.push(h), C++, await this.stageBlock(h, t, d, {
                                        conditions: y.conditions,
                                        encryptionScope: y.encryptionScope,
                                        tracingOptions: x.tracingOptions
                                    }), O += d, y.onProgress && y.onProgress({
                                        loadedBytes: O
                                    })
                                }), Math.ceil(h / 4 * 3));
                            return await z.do(), await this.commitBlockList(k, Object.assign(Object.assign({}, y), {
                                tracingOptions: Object.assign(Object.assign({}, y.tracingOptions), convertTracingToRequestOptionsBase(x))
                            }))
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                }
                class PageBlobClient extends BlobClient {
                    constructor(t, d, h, y) {
                        let _, x;
                        if (y = y || {}, isPipelineLike(d)) x = t, _ = d;
                        else if (H && d instanceof StorageSharedKeyCredential || d instanceof AnonymousCredential || isTokenCredential(d)) x = t, _ = newPipeline(d, y = h);
                        else if (d || "string" == typeof d) {
                            if (!d || "string" != typeof d || !h || "string" != typeof h) throw new Error("Expecting non-empty strings for containerName and blobName parameters"); {
                                const C = d,
                                    E = h,
                                    O = extractConnectionStringParts(t);
                                if ("AccountConnString" === O.kind) {
                                    if (!H) throw new Error("Account connection string is only supported in Node.js environment"); {
                                        const t = new StorageSharedKeyCredential(O.accountName, O.accountKey);
                                        x = appendToURLPath(appendToURLPath(O.url, encodeURIComponent(C)), encodeURIComponent(E)), y.proxyOptions = void O.proxyUri, _ = newPipeline(t, y)
                                    }
                                } else {
                                    if ("SASConnString" !== O.kind) throw new Error("Connection string must be either an Account connection string or a SAS connection string");
                                    x = appendToURLPath(appendToURLPath(O.url, encodeURIComponent(C)), encodeURIComponent(E)) + "?" + O.accountSas, _ = newPipeline(new AnonymousCredential, y)
                                }
                            }
                        } else x = t, _ = newPipeline(new AnonymousCredential, y);
                        super(x, _), this.pageBlobContext = new PageBlob(this.storageClientContext)
                    }
                    withSnapshot(t) {
                        return new PageBlobClient(setURLParameter(this.url, gs.SNAPSHOT, 0 === t.length ? void 0 : t), this.pipeline)
                    }
                    async create(t, d = {}) {
                        var h, y, _;
                        d.conditions = d.conditions || {};
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("PageBlobClient-create", d);
                        try {
                            return ensureCpkIfSpecified(d.customerProvidedKey, this.isHttps), await this.pageBlobContext.create(0, t, Object.assign({
                                abortSignal: d.abortSignal,
                                blobHttpHeaders: d.blobHTTPHeaders,
                                blobSequenceNumber: d.blobSequenceNumber,
                                leaseAccessConditions: d.conditions,
                                metadata: d.metadata,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                }),
                                cpkInfo: d.customerProvidedKey,
                                encryptionScope: d.encryptionScope,
                                immutabilityPolicyExpiry: null === (y = d.immutabilityPolicy) || void 0 === y ? void 0 : y.expiriesOn,
                                immutabilityPolicyMode: null === (_ = d.immutabilityPolicy) || void 0 === _ ? void 0 : _.policyMode,
                                legalHold: d.legalHold,
                                tier: toAccessTier(d.tier),
                                blobTagsString: toBlobTagsString(d.tags)
                            }, convertTracingToRequestOptionsBase(C)))
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                    async createIfNotExists(t, d = {}) {
                        var h, y;
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("PageBlobClient-createIfNotExists", d);
                        try {
                            const h = {
                                    ifNoneMatch: "*"
                                },
                                y = await this.create(t, Object.assign(Object.assign({}, d), {
                                    conditions: h,
                                    tracingOptions: x.tracingOptions
                                }));
                            return Object.assign(Object.assign({
                                succeeded: !0
                            }, y), {
                                _response: y._response
                            })
                        } catch (C) {
                            if ("BlobAlreadyExists" === (null === (h = C.details) || void 0 === h ? void 0 : h.errorCode)) return _.setStatus({
                                code: Ge.ERROR,
                                message: "Expected exception when creating a blob only if it does not already exist."
                            }), Object.assign(Object.assign({
                                succeeded: !1
                            }, null === (y = C.response) || void 0 === y ? void 0 : y.parsedHeaders), {
                                _response: C.response
                            });
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    async uploadPages(t, d, h, y = {}) {
                        var _;
                        y.conditions = y.conditions || {};
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("PageBlobClient-uploadPages", y);
                        try {
                            return ensureCpkIfSpecified(y.customerProvidedKey, this.isHttps), await this.pageBlobContext.uploadPages(h, t, Object.assign({
                                abortSignal: y.abortSignal,
                                leaseAccessConditions: y.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, y.conditions), {
                                    ifTags: null === (_ = y.conditions) || void 0 === _ ? void 0 : _.tagConditions
                                }),
                                requestOptions: {
                                    onUploadProgress: y.onProgress
                                },
                                range: rangeToString({
                                    offset: d,
                                    count: h
                                }),
                                sequenceNumberAccessConditions: y.conditions,
                                transactionalContentMD5: y.transactionalContentMD5,
                                transactionalContentCrc64: y.transactionalContentCrc64,
                                cpkInfo: y.customerProvidedKey,
                                encryptionScope: y.encryptionScope
                            }, convertTracingToRequestOptionsBase(C)))
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                    async uploadPagesFromURL(t, d, h, y, _ = {}) {
                        var x;
                        _.conditions = _.conditions || {}, _.sourceConditions = _.sourceConditions || {};
                        const {
                            span: C,
                            updatedOptions: E
                        } = Ol("PageBlobClient-uploadPagesFromURL", _);
                        try {
                            return ensureCpkIfSpecified(_.customerProvidedKey, this.isHttps), await this.pageBlobContext.uploadPagesFromURL(t, rangeToString({
                                offset: d,
                                count: y
                            }), 0, rangeToString({
                                offset: h,
                                count: y
                            }), Object.assign({
                                abortSignal: _.abortSignal,
                                sourceContentMD5: _.sourceContentMD5,
                                sourceContentCrc64: _.sourceContentCrc64,
                                leaseAccessConditions: _.conditions,
                                sequenceNumberAccessConditions: _.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, _.conditions), {
                                    ifTags: null === (x = _.conditions) || void 0 === x ? void 0 : x.tagConditions
                                }),
                                sourceModifiedAccessConditions: {
                                    sourceIfMatch: _.sourceConditions.ifMatch,
                                    sourceIfModifiedSince: _.sourceConditions.ifModifiedSince,
                                    sourceIfNoneMatch: _.sourceConditions.ifNoneMatch,
                                    sourceIfUnmodifiedSince: _.sourceConditions.ifUnmodifiedSince
                                },
                                cpkInfo: _.customerProvidedKey,
                                encryptionScope: _.encryptionScope,
                                copySourceAuthorization: httpAuthorizationToString(_.sourceAuthorization)
                            }, convertTracingToRequestOptionsBase(E)))
                        } catch (O) {
                            throw C.setStatus({
                                code: Ge.ERROR,
                                message: O.message
                            }), O
                        } finally {
                            C.end()
                        }
                    }
                    async clearPages(t = 0, d, h = {}) {
                        var y;
                        h.conditions = h.conditions || {};
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("PageBlobClient-clearPages", h);
                        try {
                            return await this.pageBlobContext.clearPages(0, Object.assign({
                                abortSignal: h.abortSignal,
                                leaseAccessConditions: h.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, h.conditions), {
                                    ifTags: null === (y = h.conditions) || void 0 === y ? void 0 : y.tagConditions
                                }),
                                range: rangeToString({
                                    offset: t,
                                    count: d
                                }),
                                sequenceNumberAccessConditions: h.conditions,
                                cpkInfo: h.customerProvidedKey,
                                encryptionScope: h.encryptionScope
                            }, convertTracingToRequestOptionsBase(x)))
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    async getPageRanges(t = 0, d, h = {}) {
                        var y;
                        h.conditions = h.conditions || {};
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("PageBlobClient-getPageRanges", h);
                        try {
                            return await this.pageBlobContext.getPageRanges(Object.assign({
                                abortSignal: h.abortSignal,
                                leaseAccessConditions: h.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, h.conditions), {
                                    ifTags: null === (y = h.conditions) || void 0 === y ? void 0 : y.tagConditions
                                }),
                                range: rangeToString({
                                    offset: t,
                                    count: d
                                })
                            }, convertTracingToRequestOptionsBase(x))).then(rangeResponseFromModel)
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    async getPageRangesDiff(t, d, h, y = {}) {
                        var _;
                        y.conditions = y.conditions || {};
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("PageBlobClient-getPageRangesDiff", y);
                        try {
                            return await this.pageBlobContext.getPageRangesDiff(Object.assign({
                                abortSignal: y.abortSignal,
                                leaseAccessConditions: y.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, y.conditions), {
                                    ifTags: null === (_ = y.conditions) || void 0 === _ ? void 0 : _.tagConditions
                                }),
                                prevsnapshot: h,
                                range: rangeToString({
                                    offset: t,
                                    count: d
                                })
                            }, convertTracingToRequestOptionsBase(C))).then(rangeResponseFromModel)
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                    async getPageRangesDiffForManagedDisks(t, d, h, y = {}) {
                        var _;
                        y.conditions = y.conditions || {};
                        const {
                            span: x,
                            updatedOptions: C
                        } = Ol("PageBlobClient-GetPageRangesDiffForManagedDisks", y);
                        try {
                            return await this.pageBlobContext.getPageRangesDiff(Object.assign({
                                abortSignal: y.abortSignal,
                                leaseAccessConditions: y.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, y.conditions), {
                                    ifTags: null === (_ = y.conditions) || void 0 === _ ? void 0 : _.tagConditions
                                }),
                                prevSnapshotUrl: h,
                                range: rangeToString({
                                    offset: t,
                                    count: d
                                })
                            }, convertTracingToRequestOptionsBase(C))).then(rangeResponseFromModel)
                        } catch (E) {
                            throw x.setStatus({
                                code: Ge.ERROR,
                                message: E.message
                            }), E
                        } finally {
                            x.end()
                        }
                    }
                    async resize(t, d = {}) {
                        var h;
                        d.conditions = d.conditions || {};
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("PageBlobClient-resize", d);
                        try {
                            return await this.pageBlobContext.resize(t, Object.assign({
                                abortSignal: d.abortSignal,
                                leaseAccessConditions: d.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                }),
                                encryptionScope: d.encryptionScope
                            }, convertTracingToRequestOptionsBase(_)))
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                    async updateSequenceNumber(t, d, h = {}) {
                        var y;
                        h.conditions = h.conditions || {};
                        const {
                            span: _,
                            updatedOptions: x
                        } = Ol("PageBlobClient-updateSequenceNumber", h);
                        try {
                            return await this.pageBlobContext.updateSequenceNumber(t, Object.assign({
                                abortSignal: h.abortSignal,
                                blobSequenceNumber: d,
                                leaseAccessConditions: h.conditions,
                                modifiedAccessConditions: Object.assign(Object.assign({}, h.conditions), {
                                    ifTags: null === (y = h.conditions) || void 0 === y ? void 0 : y.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(x)))
                        } catch (C) {
                            throw _.setStatus({
                                code: Ge.ERROR,
                                message: C.message
                            }), C
                        } finally {
                            _.end()
                        }
                    }
                    async startCopyIncremental(t, d = {}) {
                        var h;
                        const {
                            span: y,
                            updatedOptions: _
                        } = Ol("PageBlobClient-startCopyIncremental", d);
                        try {
                            return await this.pageBlobContext.copyIncremental(t, Object.assign({
                                abortSignal: d.abortSignal,
                                modifiedAccessConditions: Object.assign(Object.assign({}, d.conditions), {
                                    ifTags: null === (h = d.conditions) || void 0 === h ? void 0 : h.tagConditions
                                })
                            }, convertTracingToRequestOptionsBase(_)))
                        } catch (x) {
                            throw y.setStatus({
                                code: Ge.ERROR,
                                message: x.message
                            }), x
                        } finally {
                            y.end()
                        }
                    }
                }

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _asyncToGenerator(t) {
                    return function() {
                        var d = this,
                            h = arguments;
                        return new Promise((function(y, _) {
                            var x = t.apply(d, h);

                            function _next(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                            }

                            function _throw(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                            }
                            _next(void 0)
                        }))
                    }
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }
                var Wl = function() {
                    function BundleBlobAttachmentStore() {
                        var t, d, h = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                            _ = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "helphub-unknown";
                        _classCallCheck(this, BundleBlobAttachmentStore), this.enterpriseAccountId = void 0, this.ticketID = void 0, this.helphubRelease = void 0, this.csrf = void 0, this.enterpriseAccountId = h, this.ticketID = y, this.helphubRelease = _, this.csrf = null === (t = document) || void 0 === t || null === (d = t.querySelector('meta[name="csrf-token"]')) || void 0 === d ? void 0 : d.content
                    }
                    var t, d, h;
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(BundleBlobAttachmentStore, [{
                        key: "willAcceptAttachment",
                        value: function willAcceptAttachment(t) {
                            return this.enterpriseAccountId <= 0 ? {
                                willAccept: !1,
                                explanation: "invalid enterprise account"
                            } : {
                                willAccept: !0
                            }
                        }
                    }, {
                        key: "attach",
                        value: (h = _asyncToGenerator(x().mark((function _callee(t, d) {
                            var h, y;
                            return x().wrap((function _callee$(_) {
                                for (;;) switch (_.prev = _.next) {
                                    case 0:
                                        return _.next = 2, this.blobInfo();
                                    case 2:
                                        return h = _.sent, y = new BlockBlobClient(h.azBlobUrl), _.prev = 4, _.next = 7, y.uploadData(t, {
                                            blockSize: 10485760,
                                            blobHTTPHeaders: {
                                                blobContentType: t.type
                                            },
                                            metadata: {
                                                bundle_file: t.name,
                                                helphub_release: this.helphubRelease
                                            },
                                            onProgress: function onProgress(h) {
                                                d(Math.round(h.loadedBytes / t.size * 100))
                                            }
                                        });
                                    case 7:
                                        _.next = 13;
                                        break;
                                    case 9:
                                        if (_.prev = 9, _.t0 = _.catch(4), "AbortError" === _.t0.name) {
                                            _.next = 13;
                                            break
                                        }
                                        throw _.t0;
                                    case 13:
                                        return _.abrupt("return", {
                                            blobUuid: h.blobUuid,
                                            token: h.token
                                        });
                                    case 14:
                                    case "end":
                                        return _.stop()
                                }
                            }), _callee, this, [
                                [4, 9]
                            ])
                        }))), function attach(t, d) {
                            return h.apply(this, arguments)
                        })
                    }, {
                        key: "notify",
                        value: (d = _asyncToGenerator(x().mark((function _callee2(t, d) {
                            var h, y;
                            return x().wrap((function _callee2$(_) {
                                for (;;) switch (_.prev = _.next) {
                                    case 0:
                                        return h = {
                                            bundle: {
                                                name: t.name,
                                                blob_uuid: d.blobUuid,
                                                enterprise_account_id: this.enterpriseAccountId
                                            },
                                            token: d.token
                                        }, this.ticketID && Object.assign(h.bundle, {
                                            ticket_id: this.ticketID
                                        }), _.next = 4, window.fetch("/attachment/notify", {
                                            body: JSON.stringify(h),
                                            method: "post",
                                            headers: {
                                                Accept: "application/json",
                                                "Content-Type": "application/json",
                                                "X-Requested-With": "XMLHttpRequest",
                                                "X-CSRF-Token": this.csrf
                                            }
                                        });
                                    case 4:
                                        return y = _.sent, _.abrupt("return", y.json());
                                    case 6:
                                    case "end":
                                        return _.stop()
                                }
                            }), _callee2, this)
                        }))), function notify(t, h) {
                            return d.apply(this, arguments)
                        })
                    }, {
                        key: "blobInfo",
                        value: (t = _asyncToGenerator(x().mark((function _callee3() {
                            var t, d;
                            return x().wrap((function _callee3$(h) {
                                for (;;) switch (h.prev = h.next) {
                                    case 0:
                                        return t = "/attachment/token", this.ticketID && (t = "".concat(t, "?ticket=").concat(this.ticketID)), h.next = 4, window.fetch(t, {
                                            headers: {
                                                Accept: "application/json",
                                                "Content-Type": "application/json",
                                                "X-Requested-With": "XMLHttpRequest",
                                                "X-CSRF-Token": this.csrf
                                            }
                                        });
                                    case 4:
                                        return d = h.sent, h.abrupt("return", d.json());
                                    case 6:
                                    case "end":
                                        return h.stop()
                                }
                            }), _callee3, this)
                        }))), function blobInfo() {
                            return t.apply(this, arguments)
                        })
                    }]), BundleBlobAttachmentStore
                }()
            },
            5496: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E, O, k, z, A, B, I, q, D, j, H = h(7757),
                    $ = h.n(H),
                    G = h(8136),
                    ee = h(3939);

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }
                var te = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + te++ + "_" + t
                }

                function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }(0, G.controller)((B = _classPrivateFieldLooseKey("beforeUpload"), I = _classPrivateFieldLooseKey("afterUpload"), q = _classPrivateFieldLooseKey("preventPageUnload"), D = _classPrivateFieldLooseKey("dispatchBundleEvent"), j = _classPrivateFieldLooseKey("progress"), _ = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(BundleUploadElement, window.HTMLElement);
                    var d, h = _createSuper(BundleUploadElement);

                    function BundleUploadElement() {
                        var t;
                        _classCallCheck(this, BundleUploadElement);
                        for (var d = arguments.length, y = new Array(d), _ = 0; _ < d; _++) y[_] = arguments[_];
                        return t = h.call.apply(h, [this].concat(y)), Object.defineProperty(_assertThisInitialized(t), j, {
                            value: _progress2
                        }), Object.defineProperty(_assertThisInitialized(t), D, {
                            value: _dispatchBundleEvent2
                        }), Object.defineProperty(_assertThisInitialized(t), q, {
                            value: _preventPageUnload2
                        }), Object.defineProperty(_assertThisInitialized(t), I, {
                            value: _afterUpload2
                        }), Object.defineProperty(_assertThisInitialized(t), B, {
                            value: _beforeUpload2
                        }), _initializerDefineProperty(t, "button", x, _assertThisInitialized(t)), _initializerDefineProperty(t, "input", C, _assertThisInitialized(t)), _initializerDefineProperty(t, "progress", E, _assertThisInitialized(t)), _initializerDefineProperty(t, "progressBar", O, _assertThisInitialized(t)), _initializerDefineProperty(t, "progressText", k, _assertThisInitialized(t)), _initializerDefineProperty(t, "eaIdSelector", z, _assertThisInitialized(t)), _initializerDefineProperty(t, "ticketId", A, _assertThisInitialized(t)), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(BundleUploadElement, [{
                        key: "eaSelector",
                        get: function get() {
                            var t;
                            return null === (t = document) || void 0 === t ? void 0 : t.querySelector("#".concat(this.eaIdSelector))
                        }
                    }, {
                        key: "eaID",
                        get: function get() {
                            var t;
                            return Number(null === (t = this.eaSelector) || void 0 === t ? void 0 : t.value)
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            _classPrivateFieldLooseBase(this, I)[I]()
                        }
                    }, {
                        key: "selected",
                        value: function selected() {
                            _classPrivateFieldLooseBase(this, D)[D]("HideStatus"), this.input.files && this.input.files[0] && (this.button.disabled = !1)
                        }
                    }, {
                        key: "upload",
                        value: (d = function _asyncToGenerator(t) {
                            return function() {
                                var d = this,
                                    h = arguments;
                                return new Promise((function(y, _) {
                                    var x = t.apply(d, h);

                                    function _next(t) {
                                        asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                                    }

                                    function _throw(t) {
                                        asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                                    }
                                    _next(void 0)
                                }))
                            }
                        }($().mark((function _callee(t) {
                            var d, h, y, _;
                            return $().wrap((function _callee$(x) {
                                for (;;) switch (x.prev = x.next) {
                                    case 0:
                                        if (t.preventDefault(), this.input.files && this.input.files[0]) {
                                            x.next = 3;
                                            break
                                        }
                                        return x.abrupt("return", _classPrivateFieldLooseBase(this, D)[D]("Failed"));
                                    case 3:
                                        if (d = new ee.BundleBlobAttachmentStore(this.eaID, this.ticketId), h = this.input.files[0], d.willAcceptAttachment(h)) {
                                            x.next = 7;
                                            break
                                        }
                                        return x.abrupt("return", _classPrivateFieldLooseBase(this, D)[D]("Failed"));
                                    case 7:
                                        return _classPrivateFieldLooseBase(this, B)[B](), x.next = 10, d.attach(h, _classPrivateFieldLooseBase(this, j)[j].bind(this));
                                    case 10:
                                        return y = x.sent, x.next = 13, d.notify(h, y);
                                    case 13:
                                        _ = x.sent, _classPrivateFieldLooseBase(this, I)[I](), null != _ && _.id ? _classPrivateFieldLooseBase(this, D)[D]("Success") : _classPrivateFieldLooseBase(this, D)[D]("Failed");
                                    case 16:
                                    case "end":
                                        return x.stop()
                                }
                            }), _callee, this)
                        }))), function upload(t) {
                            return d.apply(this, arguments)
                        })
                    }]), BundleUploadElement
                }(), x = _applyDecoratedDescriptor(_.prototype, "button", [G.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), C = _applyDecoratedDescriptor(_.prototype, "input", [G.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), E = _applyDecoratedDescriptor(_.prototype, "progress", [G.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), O = _applyDecoratedDescriptor(_.prototype, "progressBar", [G.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), k = _applyDecoratedDescriptor(_.prototype, "progressText", [G.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), z = _applyDecoratedDescriptor(_.prototype, "eaIdSelector", [G.attr], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return ""
                    }
                }), A = _applyDecoratedDescriptor(_.prototype, "ticketId", [G.attr], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return ""
                    }
                }), y = _));

                function _beforeUpload2() {
                    var t = this;
                    window.onbeforeunload = function(d) {
                        _classPrivateFieldLooseBase(t, q)[q](d)
                    }, this.input.disabled = !0, this.button.disabled = !0, this.eaSelector && (this.eaSelector.disabled = !0), this.button.textContent = "Uploading...", this.progress.hidden = !1
                }

                function _afterUpload2() {
                    window.onbeforeunload = null, this.input.value = "", this.input.disabled = !1, this.button.disabled = !0, this.eaSelector && (this.eaSelector.disabled = !1), this.button.textContent = "Upload", this.progress.hidden = !0
                }

                function _preventPageUnload2(t) {
                    t.preventDefault(), t.returnValue = ""
                }

                function _dispatchBundleEvent2(t) {
                    document.dispatchEvent(new window.CustomEvent("bundleUpload".concat(t)))
                }

                function _progress2(t) {
                    this.progressBar.style.width = "".concat(t, "%"), this.progressText.textContent = "".concat(t, "%"), 100 === t && this.progress.classList.add("progress-bar-processing")
                }
            },
            1613: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E = h(8136);

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }(0, E.controller)((_ = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(BundleUploadStatusElement, window.HTMLElement);
                    var d = _createSuper(BundleUploadStatusElement);

                    function BundleUploadStatusElement() {
                        var t;
                        _classCallCheck(this, BundleUploadStatusElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return _initializerDefineProperty(t = d.call.apply(d, [this].concat(y)), "failed", x, _assertThisInitialized(t)), _initializerDefineProperty(t, "success", C, _assertThisInitialized(t)), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(BundleUploadStatusElement, [{
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            var t = this;
                            document.addEventListener("bundleUploadHideStatus", (function() {
                                t.failed.hidden = !0, t.success.hidden = !0
                            })), document.addEventListener("bundleUploadFailed", (function() {
                                t.failed.hidden = !1
                            })), document.addEventListener("bundleUploadSuccess", (function() {
                                t.success.hidden = !1
                            }))
                        }
                    }]), BundleUploadStatusElement
                }(), x = _applyDecoratedDescriptor(_.prototype, "failed", [E.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), C = _applyDecoratedDescriptor(_.prototype, "success", [E.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), y = _))
            },
            5002: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E, O, k, z, A = h(8136);

                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = function _unsupportedIterableToArray(t, d) {
                                if (!t) return;
                                if ("string" == typeof t) return _arrayLikeToArray(t, d);
                                var h = Object.prototype.toString.call(t).slice(8, -1);
                                "Object" === h && t.constructor && (h = t.constructor.name);
                                if ("Map" === h || "Set" === h) return Array.from(t);
                                if ("Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)) return _arrayLikeToArray(t, d)
                            }(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }
                var B = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + B++ + "_" + t
                }

                function _appear2() {
                    var t;
                    document && document.body.classList.add("prevent-bg-scroll");
                    var d = null !== (t = _classPrivateFieldLooseBase(this, C)[C]()) && void 0 !== t ? t : 0;
                    _classPrivateFieldLooseBase(this, O)[O](this.accounts[d])
                }

                function _disappear2() {
                    document && document.body.classList.remove("prevent-bg-scroll")
                }

                function _currentAccountIndex2() {
                    var t = this,
                        d = this.accounts.findIndex((function(d) {
                            return t.value === d.dataset.selectValue
                        }));
                    return d >= 0 ? d : null
                }

                function _keyboardSelect2(t) {
                    t && (t.focus(), _classPrivateFieldLooseBase(this, O)[O](t), _classPrivateFieldLooseBase(this, k)[k](t))
                }

                function _scrollToAccount2(t) {
                    var d, h, y = t;
                    null !== (d = t.previousElementSibling) && void 0 !== d && null !== (h = d.classList) && void 0 !== h && h.contains("SelectMenu-divider") && (y = t.previousElementSibling), y.scrollIntoView({
                        block: "nearest"
                    })
                }

                function _select2(t) {
                    var d, h = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    this.value = null == t || null === (d = t.dataset) || void 0 === d ? void 0 : d.selectValue, h && this.selection.dispatchEvent(new window.Event("change", {
                        bubbles: !0
                    }))
                }

                function _refreshUIState2() {
                    var t, d = _createForOfIteratorHelper(this.accounts);
                    try {
                        for (d.s(); !(t = d.n()).done;) {
                            var h = t.value;
                            h.setAttribute("aria-checked", h.dataset.selectValue === this.value), h.dataset.selectValue === this.value && (this.selector.textContent = h.dataset.selectName)
                        }
                    } catch (y) {
                        d.e(y)
                    } finally {
                        d.f()
                    }
                }(0, A.controller)((y = _classPrivateFieldLooseKey("keyboardNavigationActive"), _ = _classPrivateFieldLooseKey("appear"), x = _classPrivateFieldLooseKey("disappear"), C = _classPrivateFieldLooseKey("currentAccountIndex"), E = _classPrivateFieldLooseKey("keyboardSelect"), O = _classPrivateFieldLooseKey("scrollToAccount"), k = _classPrivateFieldLooseKey("select"), z = _classPrivateFieldLooseKey("refreshUIState"), function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(AccountSelectorElement, window.HTMLElement);
                    var d = _createSuper(AccountSelectorElement);

                    function AccountSelectorElement() {
                        var t;
                        _classCallCheck(this, AccountSelectorElement);
                        for (var h = arguments.length, A = new Array(h), B = 0; B < h; B++) A[B] = arguments[B];
                        return t = d.call.apply(d, [this].concat(A)), Object.defineProperty(_assertThisInitialized(t), z, {
                            value: _refreshUIState2
                        }), Object.defineProperty(_assertThisInitialized(t), k, {
                            value: _select2
                        }), Object.defineProperty(_assertThisInitialized(t), O, {
                            value: _scrollToAccount2
                        }), Object.defineProperty(_assertThisInitialized(t), E, {
                            value: _keyboardSelect2
                        }), Object.defineProperty(_assertThisInitialized(t), C, {
                            value: _currentAccountIndex2
                        }), Object.defineProperty(_assertThisInitialized(t), x, {
                            value: _disappear2
                        }), Object.defineProperty(_assertThisInitialized(t), _, {
                            value: _appear2
                        }), Object.defineProperty(_assertThisInitialized(t), y, {
                            writable: !0,
                            value: void 0
                        }), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(AccountSelectorElement, [{
                        key: "accounts",
                        get: function get() {
                            return (0, A.findTargets)(this, "accounts")
                        }
                    }, {
                        key: "details",
                        get: function get() {
                            return (0, A.findTarget)(this, "details")
                        }
                    }, {
                        key: "isOpen",
                        get: function get() {
                            return this.details.hasAttribute("open")
                        }
                    }, {
                        key: "selector",
                        get: function get() {
                            return (0, A.findTarget)(this, "selector")
                        }
                    }, {
                        key: "selection",
                        get: function get() {
                            return (0, A.findTarget)(this, "selection")
                        }
                    }, {
                        key: "value",
                        get: function get() {
                            return this.selection.value
                        },
                        set: function set(t) {
                            this.selection.value = t
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            var t = this.getAttribute("value");
                            if (t && !this.value) {
                                var d = this.accounts.find((function(d) {
                                    var h;
                                    return t === (null === (h = d.dataset) || void 0 === h ? void 0 : h.selectValue)
                                }));
                                _classPrivateFieldLooseBase(this, k)[k](d, !1)
                            }
                        }
                    }, {
                        key: "close",
                        value: function close() {
                            this.details.removeAttribute("open")
                        }
                    }, {
                        key: "open",
                        value: function open() {
                            this.details.setAttribute("open", "true")
                        }
                    }, {
                        key: "keyboardEvent",
                        value: function keyboardEvent(t) {
                            _classPrivateFieldLooseBase(this, y)[y] = !0;
                            var d = _classPrivateFieldLooseBase(this, C)[C]();
                            switch (t.key) {
                                case "Enter":
                                case " ":
                                    this.isOpen ? this.close() : this.open();
                                    break;
                                case "Escape":
                                    this.close();
                                    break;
                                case "j":
                                case "ArrowDown":
                                    this.open();
                                    var h = null === d ? this.accounts[0] : this.accounts[d + 1];
                                    _classPrivateFieldLooseBase(this, E)[E](h);
                                    break;
                                case "k":
                                case "ArrowUp":
                                    this.open();
                                    var _ = null === d ? this.accounts[0] : this.accounts[d - 1];
                                    _classPrivateFieldLooseBase(this, E)[E](_)
                            }
                            t.preventDefault(), _classPrivateFieldLooseBase(this, y)[y] = !1
                        }
                    }, {
                        key: "selected",
                        value: function selected(t) {
                            t.target !== this.selection ? _classPrivateFieldLooseBase(this, k)[k](t.currentTarget) : (_classPrivateFieldLooseBase(this, z)[z](), _classPrivateFieldLooseBase(this, y)[y] || this.close())
                        }
                    }, {
                        key: "viewChanged",
                        value: function viewChanged(t) {
                            this.details.open ? _classPrivateFieldLooseBase(this, _)[_]() : _classPrivateFieldLooseBase(this, x)[x]()
                        }
                    }]), AccountSelectorElement
                }()))
            },
            1897: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _ = h(8136);

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }(0, _.controller)(y = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(DetailsSelectElement, window.HTMLElement);
                    var d = _createSuper(DetailsSelectElement);

                    function DetailsSelectElement() {
                        return _classCallCheck(this, DetailsSelectElement), d.apply(this, arguments)
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(DetailsSelectElement, [{
                        key: "octiconCheck",
                        get: function get() {
                            return (0, _.findTarget)(this, "octicon-check")
                        }
                    }, {
                        key: "detailElements",
                        get: function get() {
                            return (0, _.findTargets)(this, "details")
                        }
                    }, {
                        key: "selectField",
                        get: function get() {
                            return (0, _.findTarget)(this, "select-field")
                        }
                    }, {
                        key: "detailsToggled",
                        value: function detailsToggled(t) {
                            var d = t.currentTarget;
                            0 === this.detailElements.filter((function(t) {
                                return null !== t.getAttribute("open")
                            })).length && (this.selectField.value = this.dataset.selectFieldDefault), null === d.getAttribute("open") ? (this.toggleFormElementsDisabled(d, !0), this.removeOcticonCheck(d)) : (this.toggleFormElementsDisabled(d, !1), this.selectField.value = d.dataset.selectFieldValue, this.addOcticonCheck(d)), this.detailElements.filter((function(t) {
                                return t.dataset.selectFieldValue !== d.dataset.selectFieldValue
                            })).filter((function(t) {
                                return null !== d.getAttribute("open")
                            })).forEach((function(t) {
                                return t.removeAttribute("open")
                            })), this.dispatchEvent(new CustomEvent("details-select-toggled", {
                                bubbles: !0
                            }))
                        }
                    }, {
                        key: "toggleFormElementsDisabled",
                        value: function toggleFormElementsDisabled(t, d) {
                            ["input", "select", "textarea"].forEach((function(h) {
                                t.querySelectorAll(h).forEach((function(t) {
                                    t.disabled = d
                                }))
                            }))
                        }
                    }, {
                        key: "removeOcticonCheck",
                        value: function removeOcticonCheck(t) {
                            var d = t.querySelector("summary");
                            d.innerHTML = d.innerHTML.replace(this.octiconCheck.innerHTML, ""), d.classList.add("Box-row--hover-blue"), d.classList.remove("navigation-focus"), d.classList.remove("Box-row--focus-blue"), d.classList.remove("text-bold")
                        }
                    }, {
                        key: "addOcticonCheck",
                        value: function addOcticonCheck(t) {
                            var d = t.querySelector("summary");
                            t.dataset.selectNoOcticon || (d.innerHTML = this.octiconCheck.innerHTML + d.innerHTML), d.classList.remove("Box-row--hover-blue"), d.classList.add("navigation-focus"), d.classList.add("Box-row--focus-blue"), d.classList.add("text-bold")
                        }
                    }]), DetailsSelectElement
                }())
            },
            5777: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E = h(8136);

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _wrapNativeSuper(t) {
                    var d = "function" == typeof Map ? new Map : void 0;
                    return _wrapNativeSuper = function _wrapNativeSuper(t) {
                        if (null === t || ! function _isNativeFunction(t) {
                                return -1 !== Function.toString.call(t).indexOf("[native code]")
                            }(t)) return t;
                        if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== d) {
                            if (d.has(t)) return d.get(t);
                            d.set(t, Wrapper)
                        }

                        function Wrapper() {
                            return _construct(t, arguments, _getPrototypeOf(this).constructor)
                        }
                        return Wrapper.prototype = Object.create(t.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), _setPrototypeOf(Wrapper, t)
                    }, _wrapNativeSuper(t)
                }

                function _construct(t, d, h) {
                    return _construct = _isNativeReflectConstruct() ? Reflect.construct : function _construct(t, d, h) {
                        var y = [null];
                        y.push.apply(y, d);
                        var _ = new(Function.bind.apply(t, y));
                        return h && _setPrototypeOf(_, h.prototype), _
                    }, _construct.apply(null, arguments)
                }

                function _isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }(0, E.controller)((_ = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(ArticleContentElement, t);
                    var d = function _createSuper(t) {
                        var d = _isNativeReflectConstruct();
                        return function _createSuperInternal() {
                            var h, y = _getPrototypeOf(t);
                            if (d) {
                                var _ = _getPrototypeOf(this).constructor;
                                h = Reflect.construct(y, arguments, _)
                            } else h = y.apply(this, arguments);
                            return _possibleConstructorReturn(this, h)
                        }
                    }(ArticleContentElement);

                    function ArticleContentElement() {
                        var t;
                        _classCallCheck(this, ArticleContentElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return _initializerDefineProperty(t = d.call.apply(d, [this].concat(y)), "thanks", x, _assertThisInitialized(t)), _initializerDefineProperty(t, "feedbackOptions", C, _assertThisInitialized(t)), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ArticleContentElement, [{
                        key: "done",
                        value: function done() {
                            var t;
                            null === (t = this.feedbackOptions) || void 0 === t || t.forEach((function(t) {
                                return t.hidden = !0
                            })), this.thanks && (this.thanks.hidden = !1)
                        }
                    }, {
                        key: "helpful",
                        value: function helpful() {
                            this.done()
                        }
                    }, {
                        key: "notHelpful",
                        value: function notHelpful() {
                            this.done()
                        }
                    }]), ArticleContentElement
                }(_wrapNativeSuper(HTMLElement)), x = _applyDecoratedDescriptor(_.prototype, "thanks", [E.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), C = _applyDecoratedDescriptor(_.prototype, "feedbackOptions", [E.targets], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), y = _))
            },
            4056: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    ArticleListElement: () => O
                });
                var y, _, x, C, E = h(8136);

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _wrapNativeSuper(t) {
                    var d = "function" == typeof Map ? new Map : void 0;
                    return _wrapNativeSuper = function _wrapNativeSuper(t) {
                        if (null === t || ! function _isNativeFunction(t) {
                                return -1 !== Function.toString.call(t).indexOf("[native code]")
                            }(t)) return t;
                        if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== d) {
                            if (d.has(t)) return d.get(t);
                            d.set(t, Wrapper)
                        }

                        function Wrapper() {
                            return _construct(t, arguments, _getPrototypeOf(this).constructor)
                        }
                        return Wrapper.prototype = Object.create(t.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), _setPrototypeOf(Wrapper, t)
                    }, _wrapNativeSuper(t)
                }

                function _construct(t, d, h) {
                    return _construct = _isNativeReflectConstruct() ? Reflect.construct : function _construct(t, d, h) {
                        var y = [null];
                        y.push.apply(y, d);
                        var _ = new(Function.bind.apply(t, y));
                        return h && _setPrototypeOf(_, h.prototype), _
                    }, _construct.apply(null, arguments)
                }

                function _isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }
                var O = (0, E.controller)((_ = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(ArticleListElement, t);
                    var d = function _createSuper(t) {
                        var d = _isNativeReflectConstruct();
                        return function _createSuperInternal() {
                            var h, y = _getPrototypeOf(t);
                            if (d) {
                                var _ = _getPrototypeOf(this).constructor;
                                h = Reflect.construct(y, arguments, _)
                            } else h = y.apply(this, arguments);
                            return _possibleConstructorReturn(this, h)
                        }
                    }(ArticleListElement);

                    function ArticleListElement() {
                        var t;
                        _classCallCheck(this, ArticleListElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return _initializerDefineProperty(t = d.call.apply(d, [this].concat(y)), "empty", x, _assertThisInitialized(t)), _initializerDefineProperty(t, "items", C, _assertThisInitialized(t)), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ArticleListElement, [{
                        key: "category",
                        get: function get() {
                            return this.getAttribute("category")
                        }
                    }, {
                        key: "search",
                        value: function search() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                d = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            if (!this.items || !this.items.length) return 0;
                            t && (t = t.toLowerCase().trim());
                            var h = 0;
                            return this.items.forEach((function(y) {
                                var _;
                                y.link && (y.hidden = t && !(null !== (_ = y.link.textContent) && void 0 !== _ && _.toLowerCase().includes(t)), !y.hidden && d && (y.hidden = !y.itemLabels().includes(d)), y.hidden || h++)
                            })), 0 === h ? this.showEmptyState() : this.hideEmptyState(), h
                        }
                    }, {
                        key: "showEmptyState",
                        value: function showEmptyState() {
                            this.empty && (this.empty.hidden = !1)
                        }
                    }, {
                        key: "hideEmptyState",
                        value: function hideEmptyState() {
                            this.empty && (this.empty.hidden = !0)
                        }
                    }]), ArticleListElement
                }(_wrapNativeSuper(HTMLElement)), x = _applyDecoratedDescriptor(_.prototype, "empty", [E.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), C = _applyDecoratedDescriptor(_.prototype, "items", [E.targets], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), y = _)) || y
            },
            1891: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E, O, k = h(8136);

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _wrapNativeSuper(t) {
                    var d = "function" == typeof Map ? new Map : void 0;
                    return _wrapNativeSuper = function _wrapNativeSuper(t) {
                        if (null === t || ! function _isNativeFunction(t) {
                                return -1 !== Function.toString.call(t).indexOf("[native code]")
                            }(t)) return t;
                        if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== d) {
                            if (d.has(t)) return d.get(t);
                            d.set(t, Wrapper)
                        }

                        function Wrapper() {
                            return _construct(t, arguments, _getPrototypeOf(this).constructor)
                        }
                        return Wrapper.prototype = Object.create(t.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), _setPrototypeOf(Wrapper, t)
                    }, _wrapNativeSuper(t)
                }

                function _construct(t, d, h) {
                    return _construct = _isNativeReflectConstruct() ? Reflect.construct : function _construct(t, d, h) {
                        var y = [null];
                        y.push.apply(y, d);
                        var _ = new(Function.bind.apply(t, y));
                        return h && _setPrototypeOf(_, h.prototype), _
                    }, _construct.apply(null, arguments)
                }

                function _isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }(0, k.controller)((_ = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(ArticleListContainerElement, t);
                    var d = function _createSuper(t) {
                        var d = _isNativeReflectConstruct();
                        return function _createSuperInternal() {
                            var h, y = _getPrototypeOf(t);
                            if (d) {
                                var _ = _getPrototypeOf(this).constructor;
                                h = Reflect.construct(y, arguments, _)
                            } else h = y.apply(this, arguments);
                            return _possibleConstructorReturn(this, h)
                        }
                    }(ArticleListContainerElement);

                    function ArticleListContainerElement() {
                        var t;
                        _classCallCheck(this, ArticleListContainerElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return _initializerDefineProperty(t = d.call.apply(d, [this].concat(y)), "tabNav", x, _assertThisInitialized(t)), _initializerDefineProperty(t, "filterInput", C, _assertThisInitialized(t)), _initializerDefineProperty(t, "searchInput", E, _assertThisInitialized(t)), _initializerDefineProperty(t, "list", O, _assertThisInitialized(t)), t.searchString = null, t.filterString = null, t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ArticleListContainerElement, [{
                        key: "updateCounter",
                        value: function updateCounter(t, d) {
                            if (this.tabNav) {
                                var h = this.tabNav.firstElementChild;
                                h && Array.from(h.children).forEach((function(h) {
                                    var y, _ = h.firstElementChild,
                                        x = h.lastElementChild;
                                    _ && (null === (y = _.textContent) || void 0 === y ? void 0 : y.trim()) === t && x && (x.textContent = d)
                                }))
                            }
                        }
                    }, {
                        key: "updateQueryParameters",
                        value: function updateQueryParameters() {
                            if (window.history.pushState) {
                                var t = new URLSearchParams(window.location.search);
                                this.searchString ? t.set("q", this.searchString) : t.delete("q"), this.filterString ? t.set("label", this.filterString) : t.delete("label");
                                var d = t.toString(),
                                    h = window.location.protocol + "//" + window.location.host + window.location.pathname;
                                d.length && (h += "?" + d), window.history.pushState({
                                    path: h
                                }, "", h)
                            }
                        }
                    }, {
                        key: "filter",
                        value: function filter(t) {
                            var d = t.currentTarget,
                                h = d.options[d.selectedIndex];
                            this.filterString = h.value || null, this.searchAndFilterArticles()
                        }
                    }, {
                        key: "search",
                        value: function search(t) {
                            this.searchString = t.currentTarget.value || null, this.searchAndFilterArticles()
                        }
                    }, {
                        key: "searchAndFilterArticles",
                        value: function searchAndFilterArticles() {
                            var t = this;
                            this.updateQueryParameters(), this.list && this.list.forEach((function(d) {
                                var h = d.search(t.searchString, t.filterString);
                                t.updateCounter(d.category, h.toString())
                            }))
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            var t = this;
                            document.addEventListener("DOMContentLoaded", (function(d) {
                                var h, y, _, x;
                                t.searchString = (null === (h = t.searchInput) || void 0 === h ? void 0 : h.value) || null, t.filterString = (null === (y = t.filterInput) || void 0 === y || null === (_ = y.options[null === (x = t.filterInput) || void 0 === x ? void 0 : x.selectedIndex]) || void 0 === _ ? void 0 : _.value) || null, t.searchAndFilterArticles()
                            }))
                        }
                    }]), ArticleListContainerElement
                }(_wrapNativeSuper(HTMLElement)), x = _applyDecoratedDescriptor(_.prototype, "tabNav", [k.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), C = _applyDecoratedDescriptor(_.prototype, "filterInput", [k.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), E = _applyDecoratedDescriptor(_.prototype, "searchInput", [k.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), O = _applyDecoratedDescriptor(_.prototype, "list", [k.targets], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), y = _))
            },
            7414: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    ArticleListItemElement: () => O
                });
                var y, _, x, C, E = h(8136);

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }
                var O = (0, E.controller)((_ = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(ArticleListItemElement, window.HTMLElement);
                    var d = _createSuper(ArticleListItemElement);

                    function ArticleListItemElement() {
                        var t;
                        _classCallCheck(this, ArticleListItemElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return _initializerDefineProperty(t = d.call.apply(d, [this].concat(y)), "labels", x, _assertThisInitialized(t)), _initializerDefineProperty(t, "link", C, _assertThisInitialized(t)), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ArticleListItemElement, [{
                        key: "category",
                        get: function get() {
                            return this.getAttribute("category")
                        }
                    }, {
                        key: "itemLabels",
                        value: function itemLabels() {
                            return this.labels ? Array.from(this.labels.children).map((function(t) {
                                return (t.textContent || "").toLowerCase().trim()
                            })) : []
                        }
                    }]), ArticleListItemElement
                }(), x = _applyDecoratedDescriptor(_.prototype, "labels", [E.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), C = _applyDecoratedDescriptor(_.prototype, "link", [E.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), y = _)) || y
            },
            4928: (t, d, h) => {
                "use strict";
                h.r(d);
                var y = h(8136),
                    _ = h(7113);

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }
                var x = "dismissed_prompts";

                function dismissedPrompts() {
                    try {
                        return ((0, _.rV)(x) || "").split(",")
                    } catch (t) {
                        return []
                    }
                }(0, y.controller)(function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(BannerPromptElement, window.HTMLElement);
                    var d = _createSuper(BannerPromptElement);

                    function BannerPromptElement() {
                        return _classCallCheck(this, BannerPromptElement), d.apply(this, arguments)
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(BannerPromptElement, [{
                        key: "promptType",
                        get: function get() {
                            return this.getAttribute("data-prompt") || ""
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            this.hidden = dismissedPrompts().includes(this.promptType)
                        }
                    }, {
                        key: "dismiss",
                        value: function dismiss() {
                            try {
                                var t = dismissedPrompts().concat(this.promptType || []);
                                (0, _.LS)(x, t.join(","))
                            } catch (d) {} finally {
                                this.hidden = !0
                            }
                        }
                    }]), BannerPromptElement
                }())
            },
            6663: (t, d, h) => {
                "use strict";
                h.r(d), (0, h(9243).on)("click", "[data-event-click]", (function(t) {
                    var d, h = t.currentTarget,
                        y = {
                            click: h.getAttribute("data-event-click"),
                            hmac: null !== (d = h.getAttribute("data-event-hmac")) && void 0 !== d ? d : ""
                        };
                    y.click && function sendBeacon(t) {
                        "sendBeacon" in navigator && t.hmac && navigator.sendBeacon("/_event", new Blob([JSON.stringify(t)], {
                            type: "application/json"
                        }))
                    }(y)
                }))
            },
            3596: (t, d, h) => {
                "use strict";

                function enableButton(t) {
                    t.dataset.enableWith && (t.innerText = t.dataset.enableWith), t.disabled = !1
                }

                function disableButton(t) {
                    t.dataset.disableWith && (t.innerText = t.dataset.disableWith), t.disabled = !0
                }
                h.r(d), h.d(d, {
                    enableButton: () => enableButton,
                    disableButton: () => disableButton
                }), (0, h(9243).on)("submit", "form", (function(t) {
                    t.currentTarget.querySelectorAll("button.js-button-disable").forEach(disableButton)
                }), {
                    capture: !0
                })
            },
            8434: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    AccountFormRequestTypeElement: () => x
                });
                var y, _ = h(8136);

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }
                var x = (0, _.controller)(y = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(AccountFormRequestTypeElement, window.HTMLElement);
                    var d = _createSuper(AccountFormRequestTypeElement);

                    function AccountFormRequestTypeElement() {
                        var t;
                        _classCallCheck(this, AccountFormRequestTypeElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return (t = d.call.apply(d, [this].concat(y))).disabled = !1, t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(AccountFormRequestTypeElement, [{
                        key: "type",
                        get: function get() {
                            return (0, _.findTarget)(this, "type")
                        }
                    }, {
                        key: "dormantModal",
                        get: function get() {
                            return (0, _.findTarget)(this, "dormantModal")
                        }
                    }, {
                        key: "changeType",
                        value: function changeType(t) {
                            var d, h;
                            this.type && "dormant_username" == this.type.value ? (this.disabled = !0, null === (h = this.dormantModal) || void 0 === h || h.setAttribute("open", "true")) : this.disabled = !1;
                            null === (d = this.closest("contact-form")) || void 0 === d || d.disableForm(this.disabled)
                        }
                    }]), AccountFormRequestTypeElement
                }()) || y
            },
            2585: (t, d, h) => {
                "use strict";
                h.r(d);
                var y = h(8136);

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function user_account_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function user_account_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function user_account_setPrototypeOf(t, d) {
                    return user_account_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, user_account_setPrototypeOf(t, d)
                }

                function user_account_createSuper(t) {
                    var d = function user_account_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = user_account_getPrototypeOf(t);
                        if (d) {
                            var _ = user_account_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return user_account_possibleConstructorReturn(this, h)
                    }
                }

                function user_account_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function user_account_assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function user_account_getPrototypeOf(t) {
                    return user_account_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, user_account_getPrototypeOf(t)
                }

                function contact_form_container_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function contact_form_container_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function contact_form_container_setPrototypeOf(t, d) {
                    return contact_form_container_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, contact_form_container_setPrototypeOf(t, d)
                }

                function contact_form_container_createSuper(t) {
                    var d = function contact_form_container_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = contact_form_container_getPrototypeOf(t);
                        if (d) {
                            var _ = contact_form_container_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return contact_form_container_possibleConstructorReturn(this, h)
                    }
                }

                function contact_form_container_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function contact_form_container_assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function contact_form_container_getPrototypeOf(t) {
                    return contact_form_container_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, contact_form_container_getPrototypeOf(t)
                }(0, y.controller)(function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(VerifiedEmailElement, window.HTMLElement);
                    var d = _createSuper(VerifiedEmailElement);

                    function VerifiedEmailElement() {
                        return _classCallCheck(this, VerifiedEmailElement), d.apply(this, arguments)
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(VerifiedEmailElement)
                }()), (0, y.controller)(function(t) {
                    ! function user_account_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && user_account_setPrototypeOf(t, d)
                    }(UserAccountElement, window.HTMLElement);
                    var d = user_account_createSuper(UserAccountElement);

                    function UserAccountElement() {
                        return user_account_classCallCheck(this, UserAccountElement), d.apply(this, arguments)
                    }
                    return function user_account_createClass(t, d, h) {
                        return d && user_account_defineProperties(t.prototype, d), h && user_account_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(UserAccountElement, [{
                        key: "value",
                        get: function get() {
                            return this.getAttribute("value")
                        }
                    }, {
                        key: "disclaimEaVisibility",
                        get: function get() {
                            return "true" === this.getAttribute("disclaim-ea-visibility")
                        }
                    }, {
                        key: "disclaimOrgVisibility",
                        get: function get() {
                            return "true" === this.getAttribute("disclaim-org-visibility")
                        }
                    }, {
                        key: "products",
                        get: function get() {
                            return (0, y.findTargets)(this, "products")
                        }
                    }, {
                        key: "enterpriseAccount",
                        get: function get() {
                            return this.getAttribute("enterprise-account")
                        }
                    }, {
                        key: "verifiedEmails",
                        get: function get() {
                            var t;
                            return null === (t = (0, y.findTargets)(this, "verified-email")) || void 0 === t ? void 0 : t.map((function(t) {
                                return t.dataset.email
                            }))
                        }
                    }, {
                        key: "preferredEmail",
                        get: function get() {
                            var t;
                            return null === (t = this.verifiedEmails) || void 0 === t ? void 0 : t[0]
                        }
                    }, {
                        key: "hasProducts",
                        value: function hasProducts() {
                            return this.products.length > 0
                        }
                    }, {
                        key: "isEnterpriseAccount",
                        value: function isEnterpriseAccount() {
                            return /true/.test(this.enterpriseAccount)
                        }
                    }]), UserAccountElement
                }());
                var _, x, C = function(t) {
                    ! function contact_form_container_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && contact_form_container_setPrototypeOf(t, d)
                    }(ContactFormContainerElement, window.HTMLElement);
                    var d = contact_form_container_createSuper(ContactFormContainerElement);

                    function ContactFormContainerElement() {
                        return contact_form_container_classCallCheck(this, ContactFormContainerElement), d.apply(this, arguments)
                    }
                    return function contact_form_container_createClass(t, d, h) {
                        return d && contact_form_container_defineProperties(t.prototype, d), h && contact_form_container_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ContactFormContainerElement, [{
                        key: "name",
                        get: function get() {
                            return this.getAttribute("name")
                        }
                    }, {
                        key: "value",
                        get: function get() {
                            return this.getAttribute("value")
                        }
                    }]), ContactFormContainerElement
                }();

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function supported_product_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function supported_product_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function supported_product_setPrototypeOf(t, d) {
                    return supported_product_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, supported_product_setPrototypeOf(t, d)
                }

                function supported_product_createSuper(t) {
                    var d = function supported_product_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = supported_product_getPrototypeOf(t);
                        if (d) {
                            var _ = supported_product_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return supported_product_possibleConstructorReturn(this, h)
                    }
                }

                function supported_product_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return supported_product_assertThisInitialized(t)
                }

                function supported_product_assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function supported_product_getPrototypeOf(t) {
                    return supported_product_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, supported_product_getPrototypeOf(t)
                }

                function server_installation_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function server_installation_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function server_installation_setPrototypeOf(t, d) {
                    return server_installation_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, server_installation_setPrototypeOf(t, d)
                }

                function server_installation_createSuper(t) {
                    var d = function server_installation_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = server_installation_getPrototypeOf(t);
                        if (d) {
                            var _ = server_installation_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return server_installation_possibleConstructorReturn(this, h)
                    }
                }

                function server_installation_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function server_installation_assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function server_installation_getPrototypeOf(t) {
                    return server_installation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, server_installation_getPrototypeOf(t)
                }

                function priority_level_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function priority_level_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function priority_level_setPrototypeOf(t, d) {
                    return priority_level_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, priority_level_setPrototypeOf(t, d)
                }

                function priority_level_createSuper(t) {
                    var d = function priority_level_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = priority_level_getPrototypeOf(t);
                        if (d) {
                            var _ = priority_level_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return priority_level_possibleConstructorReturn(this, h)
                    }
                }

                function priority_level_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function priority_level_assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function priority_level_getPrototypeOf(t) {
                    return priority_level_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, priority_level_getPrototypeOf(t)
                }

                function product_release_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function product_release_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function product_release_setPrototypeOf(t, d) {
                    return product_release_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, product_release_setPrototypeOf(t, d)
                }

                function product_release_createSuper(t) {
                    var d = function product_release_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = product_release_getPrototypeOf(t);
                        if (d) {
                            var _ = product_release_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return product_release_possibleConstructorReturn(this, h)
                    }
                }

                function product_release_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function product_release_assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function product_release_getPrototypeOf(t) {
                    return product_release_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, product_release_getPrototypeOf(t)
                }(0, y.controller)((x = function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }((_ = function(t) {
                    ! function supported_product_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && supported_product_setPrototypeOf(t, d)
                    }(SupportedProductElement, t);
                    var d = supported_product_createSuper(SupportedProductElement);

                    function SupportedProductElement() {
                        var t;
                        supported_product_classCallCheck(this, SupportedProductElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return _initializerDefineProperty(t = d.call.apply(d, [this].concat(y)), "supportedReleases", x, supported_product_assertThisInitialized(t)), t
                    }
                    return function supported_product_createClass(t, d, h) {
                        return d && supported_product_defineProperties(t.prototype, d), h && supported_product_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(SupportedProductElement, [{
                        key: "name",
                        get: function get() {
                            return this.getAttribute("name")
                        }
                    }, {
                        key: "value",
                        get: function get() {
                            return this.getAttribute("value")
                        }
                    }, {
                        key: "installations",
                        get: function get() {
                            return (0, y.findTargets)(this, "installations")
                        }
                    }, {
                        key: "priorityLevels",
                        get: function get() {
                            return (0, y.findTargets)(this, "priorityLevels")
                        }
                    }, {
                        key: "releases",
                        get: function get() {
                            return (0, y.findTargets)(this, "releases")
                        }
                    }, {
                        key: "hasInstallations",
                        value: function hasInstallations() {
                            return this.installations.length > 0
                        }
                    }, {
                        key: "hasPriorityLevels",
                        value: function hasPriorityLevels() {
                            return this.priorityLevels.length > 0
                        }
                    }, {
                        key: "hasReleases",
                        value: function hasReleases() {
                            return this.releases.length > 0
                        }
                    }]), SupportedProductElement
                }(C)).prototype, "supportedReleases", [y.attr], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return ""
                    }
                }), _)), (0, y.controller)(function(t) {
                    ! function server_installation_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && server_installation_setPrototypeOf(t, d)
                    }(ServerInstallationElement, t);
                    var d = server_installation_createSuper(ServerInstallationElement);

                    function ServerInstallationElement() {
                        return server_installation_classCallCheck(this, ServerInstallationElement), d.apply(this, arguments)
                    }
                    return function server_installation_createClass(t, d, h) {
                        return d && server_installation_defineProperties(t.prototype, d), h && server_installation_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ServerInstallationElement)
                }(C)), (0, y.controller)(function(t) {
                    ! function priority_level_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && priority_level_setPrototypeOf(t, d)
                    }(PriorityLevelElement, t);
                    var d = priority_level_createSuper(PriorityLevelElement);

                    function PriorityLevelElement() {
                        return priority_level_classCallCheck(this, PriorityLevelElement), d.apply(this, arguments)
                    }
                    return function priority_level_createClass(t, d, h) {
                        return d && priority_level_defineProperties(t.prototype, d), h && priority_level_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(PriorityLevelElement)
                }(C)), (0, y.controller)(function(t) {
                    ! function product_release_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && product_release_setPrototypeOf(t, d)
                    }(ProductReleaseElement, t);
                    var d = product_release_createSuper(ProductReleaseElement);

                    function ProductReleaseElement() {
                        return product_release_classCallCheck(this, ProductReleaseElement), d.apply(this, arguments)
                    }
                    return function product_release_createClass(t, d, h) {
                        return d && product_release_defineProperties(t.prototype, d), h && product_release_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ProductReleaseElement)
                }(C));
                var E, O, k, z, A, B, I, q, D, j, H, $, G, ee, te;
                h(2925), h(1061);

                function _toConsumableArray(t) {
                    return function _arrayWithoutHoles(t) {
                        if (Array.isArray(t)) return _arrayLikeToArray(t)
                    }(t) || function _iterableToArray(t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                    }(t) || _unsupportedIterableToArray(t) || function _nonIterableSpread() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = _unsupportedIterableToArray(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _unsupportedIterableToArray(t, d) {
                    if (t) {
                        if ("string" == typeof t) return _arrayLikeToArray(t, d);
                        var h = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === h && t.constructor && (h = t.constructor.name), "Map" === h || "Set" === h ? Array.from(t) : "Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h) ? _arrayLikeToArray(t, d) : void 0
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function contact_form_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function contact_form_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function contact_form_setPrototypeOf(t, d) {
                    return contact_form_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, contact_form_setPrototypeOf(t, d)
                }

                function contact_form_createSuper(t) {
                    var d = function contact_form_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = contact_form_getPrototypeOf(t);
                        if (d) {
                            var _ = contact_form_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return contact_form_possibleConstructorReturn(this, h)
                    }
                }

                function contact_form_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return contact_form_assertThisInitialized(t)
                }

                function contact_form_assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function contact_form_getPrototypeOf(t) {
                    return contact_form_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, contact_form_getPrototypeOf(t)
                }

                function _classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }
                var re = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + re++ + "_" + t
                }

                function _updateMenu2(t) {
                    for (var d, h, y, _ = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], x = null === (d = t.selectedOptions[0]) || void 0 === d ? void 0 : d.value, C = t.options[0] || new Option("Select a ".concat((null === (h = t.labels[0]) || void 0 === h || null === (y = h.textContent) || void 0 === y ? void 0 : y.toLowerCase()) || "response"), ""); t.length > 0;) t.remove(0);
                    t.add(C);
                    var E, O = _createForOfIteratorHelper(_);
                    try {
                        for (O.s(); !(E = O.n()).done;) {
                            var k = E.value;
                            t.add(new Option(k.name, k.value, !1, k.value === x))
                        }
                    } catch (z) {
                        O.e(z)
                    } finally {
                        O.f()
                    }
                }

                function _urgentPriority2() {
                    return "urgent" === this.priorityMenu.value
                }

                function _highPriority2() {
                    return "high" === this.priorityMenu.value
                }

                function _isGHES2() {
                    var t, d, h;
                    return (null === (t = _classPrivateFieldLooseBase(this, E)[E]) || void 0 === t ? void 0 : t.hasProducts()) && (null === (d = _classPrivateFieldLooseBase(this, O)[O]) || void 0 === d || null === (h = d.value) || void 0 === h ? void 0 : h.includes("ghes"))
                }

                function _toggleCallbackOption2() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    this.callbackOption && (this.callbackOption.hidden = !t, t && this.callbackCheckbox.checked ? (this.callbackForm.hidden = !1, this.countryCodeSelect.required = !0, this.phoneNumber.required = !0) : (this.callbackCheckbox.checked = !1, this.callbackForm.hidden = !0, this.countryCodeSelect.required = !1, this.phoneNumber.required = !1))
                }

                function _toggleDiagnosticFileUpload2() {
                    if (this.diagnosticFileUpload) {
                        if (_classPrivateFieldLooseBase(this, B)[B]()) return _classPrivateFieldLooseBase(this, $)[$](this.diagnosticFileUpload, !1);
                        _classPrivateFieldLooseBase(this, $)[$](this.diagnosticFileUpload, !0), this.diagnosticFileUpload.destroyFile()
                    }
                }

                function _showUrgentLanguageWarning2() {
                    if ("ja" === this.language.value) {
                        if (!this.urgentLanguageWarningJapanese) return;
                        this.urgentLanguageWarningJapanese.hidden = !1
                    } else this.urgentLanguageWarning.hidden = !1
                }

                function _hideLanguageWarning2() {
                    this.nonSupportedLanguageWarning && this.urgentLanguageWarning && (this.nonSupportedLanguageWarning.hidden = !0, this.urgentLanguageWarning.hidden = !0, this.urgentLanguageWarningJapanese.hidden = !0)
                }

                function _toggleUpgradeWarning2(t) {
                    var d, h, y, _ = (null === (d = _classPrivateFieldLooseBase(this, O)[O]) || void 0 === d || null === (h = d.supportedReleases) || void 0 === h ? void 0 : h.split(",")) || [],
                        x = _[_.length - 1],
                        C = null === (y = this.upgradeLink) || void 0 === y ? void 0 : y.getAttribute("data-link-template");
                    this.upgradeWarning && C && x && (t && "unknown" !== t && !_.includes(t) ? (this.upgradeLink.href = "".concat(C, "?from=").concat(t, "&to=").concat(x), _classPrivateFieldLooseBase(this, te)[te](this.upgradeWarning)) : _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeWarning))
                }

                function _toggleFormGroup2(t, d) {
                    t && (t.disabled = d, t.closest("dl").hidden = d)
                }

                function _toggleVisibilityDisclaimer2() {
                    this.eaVisibilityDisclaimer && this.orgVisibilityDisclaimer && (this.eaVisibilityDisclaimer.hidden = !_classPrivateFieldLooseBase(this, E)[E] || !_classPrivateFieldLooseBase(this, E)[E].disclaimEaVisibility, this.orgVisibilityDisclaimer.hidden = !_classPrivateFieldLooseBase(this, E)[E] || !_classPrivateFieldLooseBase(this, E)[E].disclaimOrgVisibility)
                }

                function _hideElement2(t) {
                    t && (t.hidden = !0)
                }

                function _showElement2(t) {
                    t && (t.hidden = !1)
                }(0, y.controller)((E = _classPrivateFieldLooseKey("currentAccount"), O = _classPrivateFieldLooseKey("currentProduct"), k = _classPrivateFieldLooseKey("updateMenu"), z = _classPrivateFieldLooseKey("urgentPriority"), A = _classPrivateFieldLooseKey("highPriority"), B = _classPrivateFieldLooseKey("isGHES"), I = _classPrivateFieldLooseKey("toggleCallbackOption"), q = _classPrivateFieldLooseKey("toggleDiagnosticFileUpload"), D = _classPrivateFieldLooseKey("showUrgentLanguageWarning"), j = _classPrivateFieldLooseKey("hideLanguageWarning"), H = _classPrivateFieldLooseKey("toggleUpgradeWarning"), $ = _classPrivateFieldLooseKey("toggleFormGroup"), G = _classPrivateFieldLooseKey("toggleVisibilityDisclaimer"), ee = _classPrivateFieldLooseKey("hideElement"), te = _classPrivateFieldLooseKey("showElement"), function(t) {
                    ! function contact_form_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && contact_form_setPrototypeOf(t, d)
                    }(ContactFormElement, window.HTMLElement);
                    var d = contact_form_createSuper(ContactFormElement);

                    function ContactFormElement() {
                        var t;
                        contact_form_classCallCheck(this, ContactFormElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return t = d.call.apply(d, [this].concat(y)), Object.defineProperty(contact_form_assertThisInitialized(t), te, {
                            value: _showElement2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), ee, {
                            value: _hideElement2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), G, {
                            value: _toggleVisibilityDisclaimer2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), $, {
                            value: _toggleFormGroup2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), H, {
                            value: _toggleUpgradeWarning2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), j, {
                            value: _hideLanguageWarning2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), D, {
                            value: _showUrgentLanguageWarning2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), q, {
                            value: _toggleDiagnosticFileUpload2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), I, {
                            value: _toggleCallbackOption2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), B, {
                            value: _isGHES2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), A, {
                            value: _highPriority2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), z, {
                            value: _urgentPriority2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), k, {
                            value: _updateMenu2
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), E, {
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(contact_form_assertThisInitialized(t), O, {
                            writable: !0,
                            value: void 0
                        }), t
                    }
                    return function contact_form_createClass(t, d, h) {
                        return d && contact_form_defineProperties(t.prototype, d), h && contact_form_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ContactFormElement, [{
                        key: "accounts",
                        get: function get() {
                            return (0, y.findTargets)(this, "accounts")
                        }
                    }, {
                        key: "accountSelector",
                        get: function get() {
                            return (0, y.findTarget)(this, "accountSelector")
                        }
                    }, {
                        key: "eaVisibilityDisclaimer",
                        get: function get() {
                            return (0, y.findTarget)(this, "eaVisibilityDisclaimer")
                        }
                    }, {
                        key: "form",
                        get: function get() {
                            return (0, y.findTarget)(this, "form")
                        }
                    }, {
                        key: "from",
                        get: function get() {
                            return (0, y.findTarget)(this, "from")
                        }
                    }, {
                        key: "fromTooltipTemplate",
                        get: function get() {
                            return (0, y.findTarget)(this, "verified-email-tooltip-template")
                        }
                    }, {
                        key: "fromTooltip",
                        get: function get() {
                            return (0, y.findTarget)(this, "verified-email-tooltip")
                        }
                    }, {
                        key: "installationMenu",
                        get: function get() {
                            return (0, y.findTarget)(this, "installationMenu")
                        }
                    }, {
                        key: "language",
                        get: function get() {
                            return (0, y.findTarget)(this, "language")
                        }
                    }, {
                        key: "nonSupportedLanguageWarning",
                        get: function get() {
                            return (0, y.findTarget)(this, "non-supported-language-warning")
                        }
                    }, {
                        key: "urgentLanguageWarning",
                        get: function get() {
                            return (0, y.findTarget)(this, "urgentLanguageWarning")
                        }
                    }, {
                        key: "urgentLanguageWarningJapanese",
                        get: function get() {
                            return (0, y.findTarget)(this, "urgentLanguageWarningJapanese")
                        }
                    }, {
                        key: "upgradeWarning",
                        get: function get() {
                            return (0, y.findTarget)(this, "upgradeWarning")
                        }
                    }, {
                        key: "upgradeLink",
                        get: function get() {
                            return (0, y.findTarget)(this, "upgradeLink")
                        }
                    }, {
                        key: "targetedReleaseNotice",
                        get: function get() {
                            return (0, y.findTarget)(this, "targetedReleaseNotice")
                        }
                    }, {
                        key: "targetedReleaseNoticeLog4j",
                        get: function get() {
                            return (0, y.findTarget)(this, "targetedReleaseNoticeLog4j")
                        }
                    }, {
                        key: "targetedReleaseNotice4895",
                        get: function get() {
                            return (0, y.findTarget)(this, "targetedReleaseNotice4895")
                        }
                    }, {
                        key: "diagnosticFileUpload",
                        get: function get() {
                            return (0, y.findTarget)(this, "diagnostic-file-upload")
                        }
                    }, {
                        key: "orgVisibilityDisclaimer",
                        get: function get() {
                            return (0, y.findTarget)(this, "orgVisibilityDisclaimer")
                        }
                    }, {
                        key: "callbackOption",
                        get: function get() {
                            return (0, y.findTarget)(this, "callbackOption")
                        }
                    }, {
                        key: "callbackCheckbox",
                        get: function get() {
                            return (0, y.findTarget)(this, "callbackCheckbox")
                        }
                    }, {
                        key: "callbackForm",
                        get: function get() {
                            return (0, y.findTarget)(this, "callbackForm")
                        }
                    }, {
                        key: "phoneNumber",
                        get: function get() {
                            return (0, y.findTarget)(this, "phoneNumber")
                        }
                    }, {
                        key: "countryCodeSelect",
                        get: function get() {
                            return (0, y.findTarget)(this, "countryCodeSelect")
                        }
                    }, {
                        key: "priorityMenu",
                        get: function get() {
                            return (0, y.findTarget)(this, "priorityMenu")
                        }
                    }, {
                        key: "productMenu",
                        get: function get() {
                            return (0, y.findTarget)(this, "productMenu")
                        }
                    }, {
                        key: "productUnevidencedDisclaimer",
                        get: function get() {
                            return (0, y.findTarget)(this, "productUnevidencedDisclaimer")
                        }
                    }, {
                        key: "releaseMenu",
                        get: function get() {
                            return (0, y.findTarget)(this, "releaseMenu")
                        }
                    }, {
                        key: "tags",
                        get: function get() {
                            return (0, y.findTarget)(this, "tags")
                        }
                    }, {
                        key: "upgradeVersionDisclaimer",
                        get: function get() {
                            return (0, y.findTarget)(this, "upgradeVersionDisclaimer")
                        }
                    }, {
                        key: "findVersion",
                        get: function get() {
                            return (0, y.findTarget)(this, "findVersion")
                        }
                    }, {
                        key: "subject",
                        get: function get() {
                            return (0, y.findTarget)(this, "subject")
                        }
                    }, {
                        key: "commentsTextarea",
                        get: function get() {
                            var t;
                            return null === (t = (0, y.findTarget)(this, "comments")) || void 0 === t ? void 0 : t.querySelector("textarea")
                        }
                    }, {
                        key: "virtualAgentContainer",
                        get: function get() {
                            return (0, y.findTarget)(this, "virtual-agent-container")
                        }
                    }, {
                        key: "disableForm",
                        value: function disableForm(t) {
                            this.subject && (this.subject.input.disabled = t), this.commentsTextarea && (this.commentsTextarea.disabled = t);
                            var d = this.form.querySelector("#contact_submit");
                            d.disabled = t, d.innerText = t ? "Cannot open ticket for this request" : "Send request"
                        }
                    }, {
                        key: "exportTranscript",
                        value: function exportTranscript(t) {
                            this.commentsTextarea.value += t.detail
                        }
                    }, {
                        key: "setFlow",
                        value: function setFlow(t) {
                            var d, h;
                            t.srcElement.hasAttribute("virtual-agent-element") || null === (d = this.virtualAgentContainer) || void 0 === d || d.dispatchEvent(new window.CustomEvent("inferflow", {
                                detail: null === (h = this.subject.input) || void 0 === h ? void 0 : h.value
                            }))
                        }
                    }, {
                        key: "accountSelected",
                        value: function accountSelected(t) {
                            var d, h = null === (d = this.accountSelector) || void 0 === d ? void 0 : d.value;
                            _classPrivateFieldLooseBase(this, E)[E] = h ? this.accounts.find((function(t) {
                                return t.value === h
                            })) : null, _classPrivateFieldLooseBase(this, G)[G](), _classPrivateFieldLooseBase(this, E)[E] && _classPrivateFieldLooseBase(this, E)[E].hasProducts() ? (_classPrivateFieldLooseBase(this, k)[k](this.productMenu, _classPrivateFieldLooseBase(this, E)[E].products), _classPrivateFieldLooseBase(this, $)[$](this.productMenu, !1), this.productSelected()) : (_classPrivateFieldLooseBase(this, $)[$](this.productMenu, !0), _classPrivateFieldLooseBase(this, $)[$](this.installationMenu, !0), _classPrivateFieldLooseBase(this, $)[$](this.releaseMenu, !0), _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeVersionDisclaimer), _classPrivateFieldLooseBase(this, ee)[ee](this.findVersion), _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeWarning), _classPrivateFieldLooseBase(this, ee)[ee](this.targetedReleaseNotice), _classPrivateFieldLooseBase(this, ee)[ee](this.productUnevidencedDisclaimer), _classPrivateFieldLooseBase(this, $)[$](this.priorityMenu, !0), _classPrivateFieldLooseBase(this, $)[$](this.diagnosticFileUpload, !0), _classPrivateFieldLooseBase(this, I)[I](), _classPrivateFieldLooseBase(this, q)[q]())
                        }
                    }, {
                        key: "productSelected",
                        value: function productSelected() {
                            var t, d, h = null === (t = this.productMenu.selectedOptions) || void 0 === t || null === (d = t[0]) || void 0 === d ? void 0 : d.value;
                            return h ? (_classPrivateFieldLooseBase(this, O)[O] = _classPrivateFieldLooseBase(this, E)[E].products.find((function(t) {
                                return t.value === h
                            })), _classPrivateFieldLooseBase(this, O)[O] ? (_classPrivateFieldLooseBase(this, q)[q](), _classPrivateFieldLooseBase(this, O)[O].hasPriorityLevels() ? (_classPrivateFieldLooseBase(this, k)[k](this.priorityMenu, _classPrivateFieldLooseBase(this, O)[O].priorityLevels), _classPrivateFieldLooseBase(this, $)[$](this.priorityMenu, !1), _classPrivateFieldLooseBase(this, I)[I](_classPrivateFieldLooseBase(this, A)[A]() || _classPrivateFieldLooseBase(this, z)[z]())) : _classPrivateFieldLooseBase(this, $)[$](this.priorityMenu, !0), _classPrivateFieldLooseBase(this, O)[O].hasInstallations() ? (_classPrivateFieldLooseBase(this, k)[k](this.installationMenu, _classPrivateFieldLooseBase(this, O)[O].installations), _classPrivateFieldLooseBase(this, $)[$](this.installationMenu, !1)) : _classPrivateFieldLooseBase(this, $)[$](this.installationMenu, !0), _classPrivateFieldLooseBase(this, O)[O].hasReleases() && this.releaseMenu ? (_classPrivateFieldLooseBase(this, k)[k](this.releaseMenu, _classPrivateFieldLooseBase(this, O)[O].releases), _classPrivateFieldLooseBase(this, $)[$](this.releaseMenu, !1), _classPrivateFieldLooseBase(this, te)[te](this.upgradeVersionDisclaimer), this.ghesReleaseSelected()) : (_classPrivateFieldLooseBase(this, $)[$](this.releaseMenu, !0), _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeVersionDisclaimer), _classPrivateFieldLooseBase(this, ee)[ee](this.findVersion), _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeWarning), _classPrivateFieldLooseBase(this, ee)[ee](this.targetedReleaseNotice)), void(_classPrivateFieldLooseBase(this, O)[O].value.includes("ghes_unevidenced") ? _classPrivateFieldLooseBase(this, te)[te](this.productUnevidencedDisclaimer) : _classPrivateFieldLooseBase(this, ee)[ee](this.productUnevidencedDisclaimer))) : (_classPrivateFieldLooseBase(this, $)[$](this.installationMenu, !0), _classPrivateFieldLooseBase(this, $)[$](this.releaseMenu, !0), _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeVersionDisclaimer), _classPrivateFieldLooseBase(this, ee)[ee](this.findVersion), _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeWarning), _classPrivateFieldLooseBase(this, ee)[ee](this.targetedReleaseNotice), _classPrivateFieldLooseBase(this, $)[$](this.diagnosticFileUpload, !0), _classPrivateFieldLooseBase(this, $)[$](this.priorityMenu, !0), void _classPrivateFieldLooseBase(this, I)[I]())) : (_classPrivateFieldLooseBase(this, $)[$](this.releaseMenu, !0), _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeVersionDisclaimer), _classPrivateFieldLooseBase(this, ee)[ee](this.findVersion), _classPrivateFieldLooseBase(this, ee)[ee](this.upgradeWarning), _classPrivateFieldLooseBase(this, ee)[ee](this.targetedReleaseNotice), _classPrivateFieldLooseBase(this, ee)[ee](this.productUnevidencedDisclaimer), _classPrivateFieldLooseBase(this, $)[$](this.installationMenu, !0), _classPrivateFieldLooseBase(this, $)[$](this.priorityMenu, !0), _classPrivateFieldLooseBase(this, $)[$](this.diagnosticFileUpload, !0), void _classPrivateFieldLooseBase(this, I)[I]())
                        }
                    }, {
                        key: "ghesReleaseSelected",
                        value: function ghesReleaseSelected() {
                            var t, d, h = null === (t = this.releaseMenu.selectedOptions) || void 0 === t || null === (d = t[0]) || void 0 === d ? void 0 : d.value;
                            "unknown" === h ? _classPrivateFieldLooseBase(this, te)[te](this.findVersion) : _classPrivateFieldLooseBase(this, ee)[ee](this.findVersion), _classPrivateFieldLooseBase(this, H)[H](h), this.toggleTargetedReleaseNotice()
                        }
                    }, {
                        key: "prioritySelected",
                        value: function prioritySelected() {
                            _classPrivateFieldLooseBase(this, z)[z]() ? this.checkLanguage() : _classPrivateFieldLooseBase(this, j)[j](), _classPrivateFieldLooseBase(this, I)[I](_classPrivateFieldLooseBase(this, A)[A]() || _classPrivateFieldLooseBase(this, z)[z]())
                        }
                    }, {
                        key: "callbackSelected",
                        value: function callbackSelected(t) {
                            this.phoneNumber.value = "", this.callbackForm.hidden = !t.target.checked
                        }
                    }, {
                        key: "emailBadge",
                        value: function emailBadge() {
                            var t, d;
                            if (!this.fromTooltip) {
                                var h, y, _ = this.fromTooltipTemplate.cloneNode(!0);
                                _.dataset.target = "contact-form.verified-email-tooltip";
                                var x = null === (h = this.from) || void 0 === h || null === (y = h.closest(".form-group")) || void 0 === y ? void 0 : y.querySelector("dt");
                                x && x.appendChild(_)
                            }
                            this.fromTooltip.hidden = !(null !== (t = _classPrivateFieldLooseBase(this, E)[E]) && void 0 !== t && null !== (d = t.verifiedEmails) && void 0 !== d && d.includes(this.from.value))
                        }
                    }, {
                        key: "setPreferredEmail",
                        value: function setPreferredEmail() {
                            var t, d;
                            if (this.from) {
                                var h = null === (t = _classPrivateFieldLooseBase(this, E)[E]) || void 0 === t ? void 0 : t.verifiedEmails;
                                if (h && h.includes(this.from.value)) this.emailBadge();
                                else {
                                    if (null !== (d = _classPrivateFieldLooseBase(this, E)[E]) && void 0 !== d && d.preferredEmail) {
                                        var y, _ = _createForOfIteratorHelper(this.from.options);
                                        try {
                                            for (_.s(); !(y = _.n()).done;) {
                                                y.value.value === _classPrivateFieldLooseBase(this, E)[E].preferredEmail && (this.from.value = _classPrivateFieldLooseBase(this, E)[E].preferredEmail)
                                            }
                                        } catch (x) {
                                            _.e(x)
                                        } finally {
                                            _.f()
                                        }
                                    }
                                    this.emailBadge()
                                }
                            }
                        }
                    }, {
                        key: "checkLanguage",
                        value: function checkLanguage(t) {
                            var d, h, y = this;
                            if (this.nonSupportedLanguageWarning && this.urgentLanguageWarning) {
                                this.csrf || (this.csrf = document.querySelector('meta[name="csrf-token"]').content);
                                var _, x, C, E, O = (null == t || null === (d = t.target) || void 0 === d ? void 0 : d.value) || (null === (h = this.commentsTextarea) || void 0 === h ? void 0 : h.value);
                                if (!O || O.length < 50) return this.urgentLanguageWarning.hidden = !0, this.nonSupportedLanguageWarning.hidden = !0, void(this.language.value = null);
                                (_ = function(t) {
                                    var d = y.identifyLanguage(t, y.csrf);
                                    d && [].push(setTimeout((function() {
                                        return d.abort()
                                    }), 5e3))
                                }, x = 1e3, C = !1, E = null, function() {
                                    var t = _,
                                        d = arguments,
                                        h = this;
                                    C ? (E && (clearTimeout(E), E = null), E = setTimeout((function() {
                                        t.apply(h, d), C = !1
                                    }), x)) : (t.apply(h, d), C = !0)
                                })(O)
                            }
                        }
                    }, {
                        key: "identifyLanguage",
                        value: function identifyLanguage(t, d) {
                            var h, y, _ = this,
                                x = (new AbortController).signal,
                                C = {
                                    text: t,
                                    product: null === (h = _classPrivateFieldLooseBase(this, O)[O]) || void 0 === h ? void 0 : h.value,
                                    account: null === (y = _classPrivateFieldLooseBase(this, E)[E]) || void 0 === y ? void 0 : y.value
                                };
                            this.priorityMenu && "" !== this.priorityMenu.value && (C.priority = this.priorityMenu.value), window.fetch(new URL("/analyze/language/detect", document.location.href), {
                                body: JSON.stringify(C),
                                headers: {
                                    Accept: "application/json",
                                    "Content-Type": "application/json",
                                    "X-CSRF-Token": d
                                },
                                method: "POST",
                                signal: x
                            }).then((function(t) {
                                return t.json()
                            })).then((function(t) {
                                _.language.value = t.language, _classPrivateFieldLooseBase(_, j)[j](), t.non_supported_message && (_.nonSupportedLanguageWarning.hidden = !1), t.urgent_priority_message && _classPrivateFieldLooseBase(_, D)[D]()
                            })).catch((function(t) {
                                console.error(t)
                            }))
                        }
                    }, {
                        key: "toggleTargetedReleaseNotice",
                        value: function toggleTargetedReleaseNotice() {
                            var t, d, h, y, _, x, C, E, O;
                            this.targetedReleaseNotice && ("3.3" === (null === (t = this.releaseMenu) || void 0 === t || null === (d = t.selectedOptions) || void 0 === d || null === (h = d[0]) || void 0 === h ? void 0 : h.value) && /actions/i.test(null === (y = this.subject) || void 0 === y || null === (_ = y.input) || void 0 === _ ? void 0 : _.value) ? (_classPrivateFieldLooseBase(this, te)[te](this.targetedReleaseNotice), this.addTag("notice-actions-3-3")) : (_classPrivateFieldLooseBase(this, ee)[ee](this.targetedReleaseNotice), this.removeTag("notice-actions-3-3")), /log4j|CVE-2021-44228/i.test(null === (x = this.subject) || void 0 === x || null === (C = x.input) || void 0 === C ? void 0 : C.value) ? (_classPrivateFieldLooseBase(this, te)[te](this.targetedReleaseNoticeLog4j), this.addTag("notice-log4j")) : (_classPrivateFieldLooseBase(this, ee)[ee](this.targetedReleaseNoticeLog4j), this.removeTag("notice-log4j")), /heroku|npm|travis|oauth|token/i.test(null === (E = this.subject) || void 0 === E || null === (O = E.input) || void 0 === O ? void 0 : O.value) ? (_classPrivateFieldLooseBase(this, te)[te](this.targetedReleaseNotice4895), this.addTag("notice-4895")) : (_classPrivateFieldLooseBase(this, ee)[ee](this.targetedReleaseNotice4895), this.removeTag("notice-4895")))
                        }
                    }, {
                        key: "removeTag",
                        value: function removeTag(t) {
                            this.tags && (this.tags.value = this.tags.value.split(",").filter((function(d) {
                                return !d.includes(t)
                            })))
                        }
                    }, {
                        key: "addTag",
                        value: function addTag(t) {
                            this.tags && !this.tags.value.includes(t) && (this.tags.value = [].concat(_toConsumableArray(this.tags.value.split(",")), [t]).filter((function(t) {
                                return t
                            })))
                        }
                    }]), ContactFormElement
                }()))
            },
            1061: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E, O, k, z, A, B, I, q, D, j, H, $, G = h(7757),
                    ee = h.n(G),
                    te = h(6470),
                    re = h.n(te),
                    ne = h(8136);

                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = function _unsupportedIterableToArray(t, d) {
                                if (!t) return;
                                if ("string" == typeof t) return _arrayLikeToArray(t, d);
                                var h = Object.prototype.toString.call(t).slice(8, -1);
                                "Object" === h && t.constructor && (h = t.constructor.name);
                                if ("Map" === h || "Set" === h) return Array.from(t);
                                if ("Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)) return _arrayLikeToArray(t, d)
                            }(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }
                var ie = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + ie++ + "_" + t
                }

                function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }(0, ne.controller)((I = _classPrivateFieldLooseKey("loadFile"), q = _classPrivateFieldLooseKey("selectRelease"), D = _classPrivateFieldLooseKey("showError"), j = _classPrivateFieldLooseKey("toggleButton"), H = _classPrivateFieldLooseKey("toggleSubmit"), $ = _classPrivateFieldLooseKey("validFileType"), _ = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(DiagnosticFileUploadElement, window.HTMLElement);
                    var d, h = _createSuper(DiagnosticFileUploadElement);

                    function DiagnosticFileUploadElement() {
                        var t;
                        _classCallCheck(this, DiagnosticFileUploadElement);
                        for (var d = arguments.length, y = new Array(d), _ = 0; _ < d; _++) y[_] = arguments[_];
                        return t = h.call.apply(h, [this].concat(y)), Object.defineProperty(_assertThisInitialized(t), $, {
                            value: _validFileType2
                        }), Object.defineProperty(_assertThisInitialized(t), H, {
                            value: _toggleSubmit2
                        }), Object.defineProperty(_assertThisInitialized(t), j, {
                            value: _toggleButton2
                        }), Object.defineProperty(_assertThisInitialized(t), D, {
                            value: _showError2
                        }), Object.defineProperty(_assertThisInitialized(t), q, {
                            value: _selectRelease2
                        }), Object.defineProperty(_assertThisInitialized(t), I, {
                            value: _loadFile2
                        }), _initializerDefineProperty(t, "buttonContainer", x, _assertThisInitialized(t)), _initializerDefineProperty(t, "button", C, _assertThisInitialized(t)), _initializerDefineProperty(t, "input", E, _assertThisInitialized(t)), _initializerDefineProperty(t, "faq", O, _assertThisInitialized(t)), _initializerDefineProperty(t, "error", k, _assertThisInitialized(t)), _initializerDefineProperty(t, "loader", z, _assertThisInitialized(t)), _initializerDefineProperty(t, "diagnosticFile", A, _assertThisInitialized(t)), _initializerDefineProperty(t, "uploadUrl", B, _assertThisInitialized(t)), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(DiagnosticFileUploadElement, [{
                        key: "contactForm",
                        get: function get() {
                            var t;
                            return null === (t = document) || void 0 === t ? void 0 : t.querySelector("contact-form")
                        }
                    }, {
                        key: "fileSelected",
                        value: function fileSelected() {
                            if (this.input.files && this.input.files[0]) {
                                var t = this.input.files[0],
                                    d = new FileReader;
                                if (!_classPrivateFieldLooseBase(this, $)[$](t)) return _classPrivateFieldLooseBase(this, D)[D]();
                                d.addEventListener("load", _classPrivateFieldLooseBase(this, I)[I].bind(this, d, t)), d.addEventListener("error", _classPrivateFieldLooseBase(this, D)[D].bind(this)), d.readAsText(t)
                            }
                        }
                    }, {
                        key: "upload",
                        value: (d = function _asyncToGenerator(t) {
                            return function() {
                                var d = this,
                                    h = arguments;
                                return new Promise((function(y, _) {
                                    var x = t.apply(d, h);

                                    function _next(t) {
                                        asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                                    }

                                    function _throw(t) {
                                        asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                                    }
                                    _next(void 0)
                                }))
                            }
                        }(ee().mark((function _callee(t) {
                            var d, h, y, _;
                            return ee().wrap((function _callee$(x) {
                                for (;;) switch (x.prev = x.next) {
                                    case 0:
                                        return x.prev = 0, x.next = 3, window.fetch("".concat(this.uploadUrl, "/api/v2/uploads.json?filename=").concat(t.name), {
                                            body: t,
                                            method: "post"
                                        });
                                    case 3:
                                        return h = x.sent, x.next = 6, h.json();
                                    case 6:
                                        if (y = x.sent, _ = null == y || null === (d = y.upload) || void 0 === d ? void 0 : d.token, 201 === h.status && _) {
                                            x.next = 10;
                                            break
                                        }
                                        return x.abrupt("return", _classPrivateFieldLooseBase(this, D)[D]());
                                    case 10:
                                        this.diagnosticFile.token.value = _, this.diagnosticFile.show(t.name), _classPrivateFieldLooseBase(this, H)[H](), _classPrivateFieldLooseBase(this, j)[j](!1, !1), _classPrivateFieldLooseBase(this, q)[q](), this.contactForm.addTag("contact-diag-upload"), x.next = 21;
                                        break;
                                    case 18:
                                        x.prev = 18, x.t0 = x.catch(0), _classPrivateFieldLooseBase(this, D)[D]();
                                    case 21:
                                    case "end":
                                        return x.stop()
                                }
                            }), _callee, this, [
                                [0, 18]
                            ])
                        }))), function upload(t) {
                            return d.apply(this, arguments)
                        })
                    }, {
                        key: "destroyFile",
                        value: function destroyFile() {
                            this.diagnosticFile.destroy(), _classPrivateFieldLooseBase(this, j)[j](), this.contactForm.removeTag("contact-diag-upload")
                        }
                    }]), DiagnosticFileUploadElement
                }(), x = _applyDecoratedDescriptor(_.prototype, "buttonContainer", [ne.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), C = _applyDecoratedDescriptor(_.prototype, "button", [ne.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), E = _applyDecoratedDescriptor(_.prototype, "input", [ne.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), O = _applyDecoratedDescriptor(_.prototype, "faq", [ne.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), k = _applyDecoratedDescriptor(_.prototype, "error", [ne.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), z = _applyDecoratedDescriptor(_.prototype, "loader", [ne.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), A = _applyDecoratedDescriptor(_.prototype, "diagnosticFile", [ne.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), B = _applyDecoratedDescriptor(_.prototype, "uploadUrl", [ne.attr], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return ""
                    }
                }), y = _));

                function _loadFile2(t, d) {
                    var h = t.result;
                    if (!h || !this.diagnosticFile.valid(h)) return _classPrivateFieldLooseBase(this, D)[D]();
                    _classPrivateFieldLooseBase(this, j)[j](!1), _classPrivateFieldLooseBase(this, H)[H](!1), this.upload(d)
                }

                function _selectRelease2() {
                    this.contactForm.releaseMenu && (this.contactForm.releaseMenu.value = this.diagnosticFile.series, this.contactForm.releaseMenu.value !== this.diagnosticFile.series && (this.contactForm.releaseMenu.value = "older"), this.contactForm.releaseMenu.dispatchEvent(new Event("change")))
                }

                function _showError2() {
                    var t = this;
                    _classPrivateFieldLooseBase(this, j)[j](), _classPrivateFieldLooseBase(this, H)[H](), this.faq.style.opacity = "0", this.error.hidden = !1, setTimeout((function() {
                        t.error.hidden = !0, t.faq.style.removeProperty("opacity")
                    }), 4e3)
                }

                function _toggleButton2() {
                    var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                        d = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    this.input.disabled = !t, this.button.setAttribute("aria-disabled", (!t).toString()), this.loader.hidden = t, this.buttonContainer.hidden = !d, this.faq.hidden = !d
                }

                function _toggleSubmit2() {
                    var t, d = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                        h = null === (t = document) || void 0 === t ? void 0 : t.querySelectorAll(".button.js-button-disable");
                    if (h) {
                        var y, _ = _createForOfIteratorHelper(h);
                        try {
                            for (_.s(); !(y = _.n()).done;) {
                                var x = y.value;
                                x.disabled = !d
                            }
                        } catch (C) {
                            _.e(C)
                        } finally {
                            _.f()
                        }
                    }
                }

                function _validFileType2(t) {
                    return this.input.accept.split(",").includes(re().extname(t.name).toLowerCase())
                }
            },
            2925: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    DiagnosticFileElement: () => j
                });
                var y, _, x, C, E, O, k, z, A = h(8136),
                    B = h(3959),
                    I = h.n(B),
                    q = h(6397),
                    D = h.n(q);

                function _initializerDefineProperty(t, d, h, y) {
                    h && Object.defineProperty(t, d, {
                        enumerable: h.enumerable,
                        configurable: h.configurable,
                        writable: h.writable,
                        value: h.initializer ? h.initializer.call(y) : void 0
                    })
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _applyDecoratedDescriptor(t, d, h, y, _) {
                    var x = {};
                    return Object.keys(y).forEach((function(t) {
                        x[t] = y[t]
                    })), x.enumerable = !!x.enumerable, x.configurable = !!x.configurable, ("value" in x || x.initializer) && (x.writable = !0), x = h.slice().reverse().reduce((function(h, y) {
                        return y(t, d, h) || h
                    }), x), _ && void 0 !== x.initializer && (x.value = x.initializer ? x.initializer.call(_) : void 0, x.initializer = void 0), void 0 === x.initializer && (Object.defineProperty(t, d, x), x = null), x
                }
                var j = (0, A.controller)((_ = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(DiagnosticFileElement, window.HTMLElement);
                    var d = _createSuper(DiagnosticFileElement);

                    function DiagnosticFileElement() {
                        var t;
                        _classCallCheck(this, DiagnosticFileElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return (t = d.call.apply(d, [this].concat(y))).VERSION_REGEX = /RELEASE_VERSION="(.*)"/, t.PLATFORM_REGEX = /RELEASE_PLATFORM="(.*)"/, _initializerDefineProperty(t, "name", x, _assertThisInitialized(t)), _initializerDefineProperty(t, "token", C, _assertThisInitialized(t)), _initializerDefineProperty(t, "version", E, _assertThisInitialized(t)), _initializerDefineProperty(t, "series", O, _assertThisInitialized(t)), _initializerDefineProperty(t, "platform", k, _assertThisInitialized(t)), _initializerDefineProperty(t, "validPlatforms", z, _assertThisInitialized(t)), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(DiagnosticFileElement, [{
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            this.token.removeAttribute("value")
                        }
                    }, {
                        key: "valid",
                        value: function valid(t) {
                            var d = (t.match(this.VERSION_REGEX) || [])[1],
                                h = (t.match(this.PLATFORM_REGEX) || [])[1],
                                y = this.validPlatforms.split(",") || [];
                            return !(!D()(d) || !y.includes(h)) && (this.series = this.versionToSeries(d), this.version = d, this.platform = h, !0)
                        }
                    }, {
                        key: "show",
                        value: function show(t) {
                            this.name.textContent = t, this.hidden = !1
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            this.hidden = !0, this.token.removeAttribute("value"), this.name.textContent = ""
                        }
                    }, {
                        key: "versionToSeries",
                        value: function versionToSeries(t) {
                            var d = I()(t);
                            return "".concat(d.major, ".").concat(d.minor)
                        }
                    }]), DiagnosticFileElement
                }(), x = _applyDecoratedDescriptor(_.prototype, "name", [A.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), C = _applyDecoratedDescriptor(_.prototype, "token", [A.target], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), E = _applyDecoratedDescriptor(_.prototype, "version", [A.attr], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return ""
                    }
                }), O = _applyDecoratedDescriptor(_.prototype, "series", [A.attr], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return ""
                    }
                }), k = _applyDecoratedDescriptor(_.prototype, "platform", [A.attr], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return ""
                    }
                }), z = _applyDecoratedDescriptor(_.prototype, "validPlatforms", [A.attr], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function initializer() {
                        return ""
                    }
                }), y = _)) || y
            },
            958: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    EducationFormElement: () => x
                });
                var y, _ = h(8136);

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }
                var x = (0, _.controller)(y = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(EducationFormElement, window.HTMLElement);
                    var d = _createSuper(EducationFormElement);

                    function EducationFormElement() {
                        var t;
                        _classCallCheck(this, EducationFormElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return (t = d.call.apply(d, [this].concat(y))).FLOW_MAPPINGS = {
                            stu: "student",
                            campexp: "campus expert"
                        }, t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(EducationFormElement, [{
                        key: "statusLink",
                        get: function get() {
                            return (0, _.findTarget)(this, "status-link")
                        }
                    }, {
                        key: "category",
                        get: function get() {
                            return (0, _.findTarget)(this, "category")
                        }
                    }, {
                        key: "virtualAgentContainer",
                        get: function get() {
                            return (0, _.findTarget)(this, "virtual-agent-container")
                        }
                    }, {
                        key: "showStatusLink",
                        value: function showStatusLink() {
                            this.statusLink.hidden = !this.category.selectedOptions[0].value.includes("hh-edu-app-stat-stu")
                        }
                    }, {
                        key: "setFlow",
                        value: function setFlow() {
                            var t, d, h = (null === (t = this.category.selectedOptions[0]) || void 0 === t ? void 0 : t.value) || "",
                                y = h ? Object.keys(this.FLOW_MAPPINGS).find((function(t) {
                                    return h.includes(t)
                                })) : null;
                            null === (d = this.virtualAgentContainer) || void 0 === d || d.dispatchEvent(new window.CustomEvent("inferflow", {
                                detail: y ? this.FLOW_MAPPINGS[y] : ""
                            }))
                        }
                    }]), EducationFormElement
                }()) || y
            },
            6729: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _ = h(8136);

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }(0, _.controller)(y = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(ReportAbuseElement, window.HTMLElement);
                    var d = _createSuper(ReportAbuseElement);

                    function ReportAbuseElement() {
                        return _classCallCheck(this, ReportAbuseElement), d.apply(this, arguments)
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ReportAbuseElement, [{
                        key: "reportContentUrl",
                        get: function get() {
                            return (0, _.findTarget)(this, "report_content_url").value
                        }
                    }, {
                        key: "reportID",
                        get: function get() {
                            return (0, _.findTarget)(this, "report_id").value
                        }
                    }, {
                        key: "reportType",
                        get: function get() {
                            return (0, _.findTarget)(this, "report_type").value
                        }
                    }, {
                        key: "commentsDiv",
                        get: function get() {
                            return (0, _.findTarget)(this, "comments")
                        }
                    }, {
                        key: "submitButton",
                        get: function get() {
                            return (0, _.findTarget)(this, "submit").querySelector("button")
                        }
                    }, {
                        key: "tagSelection",
                        get: function get() {
                            return (0, _.findTarget)(this, "tag-selection")
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            window.requestIdleCallback ? window.requestIdleCallback(this.loadAbuseContent.bind(this)) : setTimeout(this.loadAbuseContent.bind(this), 0), this.submitButton.disabled = !0, this.addEventListener("details-select-toggled", this.toggleComments)
                        }
                    }, {
                        key: "loadAbuseContent",
                        value: function loadAbuseContent() {
                            var t = this.getAttribute("url"),
                                d = this.getAttribute("csrf-token");
                            this.reportID && t && d && window.fetch(t, {
                                body: JSON.stringify({
                                    report_content_url: this.reportContentUrl,
                                    report_id: this.reportID,
                                    report_type: this.reportType
                                }),
                                method: "post",
                                headers: {
                                    Accept: "application/json",
                                    "X-CSRF-Token": d,
                                    "Content-Type": "application/json",
                                    "X-Requested-With": "XMLHttpRequest"
                                }
                            })
                        }
                    }, {
                        key: "toggleComments",
                        value: function toggleComments() {
                            var t = this.tagSelection.querySelectorAll("select:not(:disabled)");
                            Array.from(t).map((function(t) {
                                return t.value
                            })).filter((function(t) {
                                return t.startsWith("cat_ts_")
                            })).length > 0 ? (this.commentsDiv.hidden = !1, this.submitButton.disabled = !1) : (this.commentsDiv.hidden = !0, this.submitButton.disabled = !0)
                        }
                    }]), ReportAbuseElement
                }())
            },
            4282: (t, d, h) => {
                "use strict";
                h.r(d);
                var y = h(8136);

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }(0, y.controller)(function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(SensitiveDataElement, window.HTMLElement);
                    var d = _createSuper(SensitiveDataElement);

                    function SensitiveDataElement() {
                        return _classCallCheck(this, SensitiveDataElement), d.apply(this, arguments)
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(SensitiveDataElement, [{
                        key: "contentOwnedMenu",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentOwnedMenu")
                        }
                    }, {
                        key: "contentOwnedMessage",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentOwnedMessage")
                        }
                    }, {
                        key: "detailsAfterContentOwned",
                        get: function get() {
                            return (0, y.findTarget)(this, "detailsAfterContentOwned")
                        }
                    }, {
                        key: "contentTypePasswordCheckbox",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentTypePasswordCheckbox")
                        }
                    }, {
                        key: "contentTypeTokenCheckbox",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentTypeTokenCheckbox")
                        }
                    }, {
                        key: "contentTypeOtherCheckbox",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentTypeOtherCheckbox")
                        }
                    }, {
                        key: "contentTypeIndividualCheckbox",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentTypeIndividualCheckbox")
                        }
                    }, {
                        key: "contentTypeNoneCheckbox",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentTypeNoneCheckbox")
                        }
                    }, {
                        key: "contentTypeMessage",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentTypeMessage")
                        }
                    }, {
                        key: "detailsAfterContentType",
                        get: function get() {
                            return (0, y.findTarget)(this, "detailsAfterContentType")
                        }
                    }, {
                        key: "contentDetailsTextArea",
                        get: function get() {
                            return this.querySelector("#content_detail")
                        }
                    }, {
                        key: "contentFullMenu",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentFullMenu")
                        }
                    }, {
                        key: "contentFullRepoMessage",
                        get: function get() {
                            return (0, y.findTarget)(this, "contentFullRepoMessage")
                        }
                    }, {
                        key: "timeSensitiveMenu",
                        get: function get() {
                            return (0, y.findTarget)(this, "timeSensitiveMenu")
                        }
                    }, {
                        key: "timeDetailText",
                        get: function get() {
                            return (0, y.findTarget)(this, "timeDetailText")
                        }
                    }, {
                        key: "thirdPartyMenu",
                        get: function get() {
                            return (0, y.findTarget)(this, "thirdPartyMenu")
                        }
                    }, {
                        key: "thirdPartyDetail",
                        get: function get() {
                            return (0, y.findTarget)(this, "thirdPartyDetail")
                        }
                    }, {
                        key: "confirmReadLabel",
                        get: function get() {
                            return (0, y.findTarget)(this, "confirmReadLabel")
                        }
                    }, {
                        key: "submitButton",
                        get: function get() {
                            var t;
                            return null === (t = (0, y.findTarget)(this, "submit")) || void 0 === t ? void 0 : t.querySelector("button")
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            var t, d, h, y = null === (t = this.confirmReadLabel) || void 0 === t ? void 0 : t.querySelector("label");
                            y && (y.innerHTML = null === (d = this.confirmReadLabel) || void 0 === d || null === (h = d.dataset) || void 0 === h ? void 0 : h.policyhtml)
                        }
                    }, {
                        key: "contentOwnedSelected",
                        value: function contentOwnedSelected() {
                            var t, d, h, y = null === (t = this.contentOwnedMenu) || void 0 === t || null === (d = t.selectedOptions) || void 0 === d || null === (h = d[0]) || void 0 === h ? void 0 : h.value;
                            this.contentOwnedMessage.hidden = !/^yes/.test(y), this.detailsAfterContentOwned.hidden = !/^no/.test(y), this.submitButton.disabled = !/^no/.test(y)
                        }
                    }, {
                        key: "contentFullSelected",
                        value: function contentFullSelected() {
                            var t, d, h, y = null === (t = this.contentFullMenu) || void 0 === t || null === (d = t.selectedOptions) || void 0 === d || null === (h = d[0]) || void 0 === h ? void 0 : h.value;
                            this.contentFullRepoMessage.hidden = /^files/.test(y) || /^$/.test(y)
                        }
                    }, {
                        key: "contentTypeSelected",
                        value: function contentTypeSelected() {
                            var t = this.contentTypePasswordCheckbox.checked,
                                d = this.contentTypeTokenCheckbox.checked,
                                h = this.contentTypeOtherCheckbox.checked,
                                y = this.contentTypeIndividualCheckbox.checked,
                                _ = this.contentTypeNoneCheckbox.checked;
                            if (this.contentTypeMessage.hidden = !_, this.detailsAfterContentType.hidden = _ || !(t || d || h || y), this.submitButton.disabled = _ || !(t || d || h || y), "" === this.contentDetailsTextArea.value.replace(/\n/g, "").replace(/\*\s*/g, "").replace(this.contentTypePasswordCheckbox.dataset.heading, "").replace(this.contentTypeTokenCheckbox.dataset.heading, "").replace(this.contentTypeOtherCheckbox.dataset.heading, "").replace(this.contentTypeIndividualCheckbox.dataset.heading, "").replace(/\s/g, "")) {
                                var x = "";
                                t && (x += "".concat(this.contentTypePasswordCheckbox.dataset.heading, "\n* \n\n")), d && (x += "".concat(this.contentTypeTokenCheckbox.dataset.heading, "\n* \n\n")), h && (x += "".concat(this.contentTypeOtherCheckbox.dataset.heading, "\n* \n\n")), y && (x += "".concat(this.contentTypeIndividualCheckbox.dataset.heading, "\n* \n\n")), this.contentDetailsTextArea.value = x
                            }
                        }
                    }, {
                        key: "timeSensitiveSelected",
                        value: function timeSensitiveSelected() {
                            var t, d, h, y = null === (t = this.timeSensitiveMenu) || void 0 === t || null === (d = t.selectedOptions) || void 0 === d || null === (h = d[0]) || void 0 === h ? void 0 : h.value;
                            this.timeDetailText.hidden = /^no/.test(y) || /^$/.test(y), this.timeDetailText.querySelector("textarea").disabled = !/^yes/.test(y)
                        }
                    }, {
                        key: "thirdPartySelected",
                        value: function thirdPartySelected() {
                            var t, d, h, y = null === (t = this.thirdPartyMenu) || void 0 === t || null === (d = t.selectedOptions) || void 0 === d || null === (h = d[0]) || void 0 === h ? void 0 : h.value;
                            this.thirdPartyDetail.hidden = /^no/.test(y) || /^$/.test(y), this.thirdPartyDetail.querySelector("textarea").disabled = !/^yes/.test(y)
                        }
                    }]), SensitiveDataElement
                }())
            },
            4125: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E, O = h(8136);

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }
                var k = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + k++ + "_" + t
                }

                function _toggletrademarkHolderMessage2() {
                    this.trademarkHolderMessage.hidden = /^yes/.test(_classPrivateFieldLooseBase(this, y)[y]), this.trademarkDetails.hidden = !/^yes/.test(_classPrivateFieldLooseBase(this, y)[y]), this.submitButton.disabled = /^no/.test(_classPrivateFieldLooseBase(this, y)[y])
                }

                function _toggletrademarkRegisteredDetails2() {
                    this.trademarkRegisteredDetails.hidden = !/^yes/.test(_classPrivateFieldLooseBase(this, _)[_]), _classPrivateFieldLooseBase(this, E)[E](this.trademarkRegisteredDetails, this.trademarkRegisteredDetails.hidden), this.trademarkNotRegisteredDetails.hidden = !/^no/.test(_classPrivateFieldLooseBase(this, _)[_]), _classPrivateFieldLooseBase(this, E)[E](this.trademarkNotRegisteredDetails, this.trademarkNotRegisteredDetails.hidden)
                }

                function _toggleFormElementsDisabled2(t, d) {
                    null == t || t.querySelectorAll(".form-control").forEach((function(t) {
                        t.disabled = d
                    }))
                }(0, O.controller)((y = _classPrivateFieldLooseKey("trademarkHolder"), _ = _classPrivateFieldLooseKey("trademarkRegistered"), x = _classPrivateFieldLooseKey("toggletrademarkHolderMessage"), C = _classPrivateFieldLooseKey("toggletrademarkRegisteredDetails"), E = _classPrivateFieldLooseKey("toggleFormElementsDisabled"), function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(TrademarkPolicyElement, window.HTMLElement);
                    var d = _createSuper(TrademarkPolicyElement);

                    function TrademarkPolicyElement() {
                        var t;
                        _classCallCheck(this, TrademarkPolicyElement);
                        for (var h = arguments.length, O = new Array(h), k = 0; k < h; k++) O[k] = arguments[k];
                        return t = d.call.apply(d, [this].concat(O)), Object.defineProperty(_assertThisInitialized(t), E, {
                            value: _toggleFormElementsDisabled2
                        }), Object.defineProperty(_assertThisInitialized(t), C, {
                            value: _toggletrademarkRegisteredDetails2
                        }), Object.defineProperty(_assertThisInitialized(t), x, {
                            value: _toggletrademarkHolderMessage2
                        }), Object.defineProperty(_assertThisInitialized(t), y, {
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(_assertThisInitialized(t), _, {
                            writable: !0,
                            value: void 0
                        }), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(TrademarkPolicyElement, [{
                        key: "trademarkHolderMenu",
                        get: function get() {
                            return (0, O.findTarget)(this, "trademarkHolderMenu")
                        }
                    }, {
                        key: "trademarkHolderMessage",
                        get: function get() {
                            return (0, O.findTarget)(this, "trademarkHolderMessage")
                        }
                    }, {
                        key: "trademarkDetails",
                        get: function get() {
                            return (0, O.findTarget)(this, "details")
                        }
                    }, {
                        key: "trademarkRegisteredMenu",
                        get: function get() {
                            return (0, O.findTarget)(this, "trademarkRegisteredMenu")
                        }
                    }, {
                        key: "trademarkRegisteredDetails",
                        get: function get() {
                            return (0, O.findTarget)(this, "registeredDetails")
                        }
                    }, {
                        key: "trademarkNotRegisteredDetails",
                        get: function get() {
                            return (0, O.findTarget)(this, "notRegisteredDetails")
                        }
                    }, {
                        key: "submitButton",
                        get: function get() {
                            var t;
                            return null === (t = (0, O.findTarget)(this, "submit")) || void 0 === t ? void 0 : t.querySelector("button")
                        }
                    }, {
                        key: "trademarkHolderSelected",
                        value: function trademarkHolderSelected() {
                            var t, d, h;
                            _classPrivateFieldLooseBase(this, y)[y] = null === (t = this.trademarkHolderMenu) || void 0 === t || null === (d = t.selectedOptions) || void 0 === d || null === (h = d[0]) || void 0 === h ? void 0 : h.value, _classPrivateFieldLooseBase(this, x)[x]()
                        }
                    }, {
                        key: "trademarkRegisteredSelected",
                        value: function trademarkRegisteredSelected() {
                            var t, d, h;
                            _classPrivateFieldLooseBase(this, _)[_] = null === (t = this.trademarkRegisteredMenu) || void 0 === t || null === (d = t.selectedOptions) || void 0 === d || null === (h = d[0]) || void 0 === h ? void 0 : h.value, _classPrivateFieldLooseBase(this, C)[C]()
                        }
                    }]), TrademarkPolicyElement
                }()))
            },
            13: (t, d, h) => {
                "use strict";
                h.r(d);
                var y = h(6031),
                    _ = h.n(y),
                    x = h(9243);
                document.addEventListener("DOMContentLoaded", (function() {
                    var t = "js-ticket-email-ccs",
                        d = document.getElementById(t);
                    if (d) {
                        var h = JSON.parse(d.dataset.taggleCcs).ccs;
                        new(_())(t, {
                            saveOnBlur: !0,
                            hiddenInputName: d.dataset.taggleHiddenInputName,
                            placeholder: "",
                            submitKeys: [188, 32, 9],
                            focusInputOnContainerClick: !0,
                            delimeter: [" "],
                            maxTags: 20,
                            onBeforeTagAdd: function onBeforeTagAdd(t, d) {
                                if (!d.split("@")[1]) return !1
                            }
                        }).add(h), document.querySelector(".taggle_input").placeholder = d.dataset.taggleAddPlaceholder || "email"
                    }
                })), (0, x.on)("click", ".js-add-ccs-link", (function(t) {
                    var d = document.querySelector(".js-ccs-section"),
                        h = document.querySelector(".js-ccs-update-button"),
                        y = document.querySelector(".taggle_input");
                    t.target.classList.remove("email_show_cc_button"), y.placeholder = "email", d.hidden = !1, h && (h.hidden = !1), y.focus()
                }))
            },
            987: (t, d, h) => {
                "use strict";
                h.r(d);
                var y = h(7757),
                    _ = h.n(y),
                    x = "<unknown>";

                function parse(t) {
                    return t.split("\n").reduce((function(t, d) {
                        var h = function parseChrome(t) {
                            var d = C.exec(t);
                            if (!d) return null;
                            var h = d[2] && 0 === d[2].indexOf("native"),
                                y = d[2] && 0 === d[2].indexOf("eval"),
                                _ = E.exec(d[2]);
                            y && null != _ && (d[2] = _[1], d[3] = _[2], d[4] = _[3]);
                            return {
                                file: h ? null : d[2],
                                methodName: d[1] || x,
                                arguments: h ? [d[2]] : [],
                                lineNumber: d[3] ? +d[3] : null,
                                column: d[4] ? +d[4] : null
                            }
                        }(d) || function parseWinjs(t) {
                            var d = O.exec(t);
                            if (!d) return null;
                            return {
                                file: d[2],
                                methodName: d[1] || x,
                                arguments: [],
                                lineNumber: +d[3],
                                column: d[4] ? +d[4] : null
                            }
                        }(d) || function parseGecko(t) {
                            var d = k.exec(t);
                            if (!d) return null;
                            var h = d[3] && d[3].indexOf(" > eval") > -1,
                                y = z.exec(d[3]);
                            h && null != y && (d[3] = y[1], d[4] = y[2], d[5] = null);
                            return {
                                file: d[3],
                                methodName: d[1] || x,
                                arguments: d[2] ? d[2].split(",") : [],
                                lineNumber: d[4] ? +d[4] : null,
                                column: d[5] ? +d[5] : null
                            }
                        }(d) || function parseNode(t) {
                            var d = B.exec(t);
                            if (!d) return null;
                            return {
                                file: d[2],
                                methodName: d[1] || x,
                                arguments: [],
                                lineNumber: +d[3],
                                column: d[4] ? +d[4] : null
                            }
                        }(d) || function parseJSC(t) {
                            var d = A.exec(t);
                            if (!d) return null;
                            return {
                                file: d[3],
                                methodName: d[1] || x,
                                arguments: [],
                                lineNumber: +d[4],
                                column: d[5] ? +d[5] : null
                            }
                        }(d);
                        return h && t.push(h), t
                    }), [])
                }
                var C = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
                    E = /\((\S*)(?::(\d+))(?::(\d+))\)/;
                var O = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
                var k = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,
                    z = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
                var A = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
                var B = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _asyncToGenerator(t) {
                    return function() {
                        var d = this,
                            h = arguments;
                        return new Promise((function(y, _) {
                            var x = t.apply(d, h);

                            function _next(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                            }

                            function _throw(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                            }
                            _next(void 0)
                        }))
                    }
                }
                var I = 0,
                    q = !1,
                    D = Date.now();

                function _reportPromiseRejectionEvent() {
                    return (_reportPromiseRejectionEvent = _asyncToGenerator(_().mark((function _callee(t) {
                        return _().wrap((function _callee$(d) {
                            for (;;) switch (d.prev = d.next) {
                                case 0:
                                    if (t.promise) {
                                        d.next = 2;
                                        break
                                    }
                                    return d.abrupt("return");
                                case 2:
                                    return d.prev = 2, d.next = 5, t.promise;
                                case 5:
                                    d.next = 10;
                                    break;
                                case 7:
                                    d.prev = 7, d.t0 = d.catch(2), d.t0 && "AbortError" !== d.t0.name && report(errorContext(formatError(d.t0)));
                                case 10:
                                case "end":
                                    return d.stop()
                            }
                        }), _callee, null, [
                            [2, 7]
                        ])
                    })))).apply(this, arguments)
                }

                function report(t) {
                    return _report.apply(this, arguments)
                }

                function _report() {
                    return (_report = _asyncToGenerator(_().mark((function _callee2(t) {
                        return _().wrap((function _callee2$(d) {
                            for (;;) switch (d.prev = d.next) {
                                case 0:
                                    if (reportable(t)) {
                                        d.next = 2;
                                        break
                                    }
                                    return d.abrupt("return");
                                case 2:
                                    I++;
                                    try {
                                        navigator.sendBeacon("/_error", new Blob([JSON.stringify(t)], {
                                            type: "application/json"
                                        }))
                                    } catch (h) {}
                                case 4:
                                case "end":
                                    return d.stop()
                            }
                        }), _callee2)
                    })))).apply(this, arguments)
                }

                function errorContext(t, d) {
                    var h, y = null === (h = document.querySelector('meta[name="csrf-token"]')) || void 0 === h ? void 0 : h.content;
                    return Object.assign({
                        error: t,
                        sanitized_url: "".concat(window.location.protocol, "//").concat(window.location.host).concat(window.location.pathname),
                        referrer: document.referrer,
                        time_since_load: Math.round(Date.now() - D),
                        user: pageUser() || void 0,
                        csrf: y
                    }, d)
                }

                function pageUser() {
                    var t, d, h = null === (t = document.head) || void 0 === t || null === (d = t.querySelector('meta[name="user-login"]')) || void 0 === d ? void 0 : d.content;
                    if (h) return h;
                    var y = ("; " + document.cookie).split("; _octo=").pop().split(";").shift();
                    return y ? "anonymous-".concat(y) : null
                }

                function formatError(t) {
                    return {
                        type: t.name,
                        value: t.message,
                        stacktrace: stacktrace(t)
                    }
                }

                function stacktrace(t) {
                    var d, h = parse(t.stack || "").map((function(t) {
                            return {
                                filename: t.file || "",
                                function: String(t.methodName),
                                lineno: (t.lineNumber || 0).toString(),
                                colno: (t.column || 0).toString()
                            }
                        })),
                        y = null !== (d = t.framesToPop) && void 0 !== d ? d : 0;
                    return 0 === y ? h : h.slice(y)
                }

                function reportable(t) {
                    return !q && t.csrf && t.error.stacktrace && ! function isExtensionError(t) {
                        var d = /(chrome|moz|safari)-extension:\/\//;
                        return t.some((function(t) {
                            return d.test(t.filename) || d.test(t.function)
                        }))
                    }(t.error.stacktrace) && I < 10 && function capableBrowser() {
                        return "function" == typeof Blob && "undefined" != typeof Intl && "undefined" != typeof MutationObserver && "undefined" != typeof URLSearchParams && "undefined" != typeof WebSocket && "undefined" != typeof IntersectionObserver && "undefined" != typeof AbortController && "undefined" != typeof customElements && "undefined" != typeof HTMLDetailsElement && "entries" in window.FormData.prototype && "toggleAttribute" in window.Element.prototype && "flatMap" in Array.prototype && "sendBeacon" in navigator
                    }() && ! function detectProxySite(t) {
                        var d, h, y = null === (d = t.head) || void 0 === d || null === (h = d.querySelector('meta[name="expected-hostname"]')) || void 0 === h ? void 0 : h.content;
                        if (!y) return !1;
                        var _ = y.replace(/\.$/, "").split(".").slice(-2).join("."),
                            x = t.location.hostname.replace(/\.$/, "").split(".").slice(-2).join(".");
                        return _ !== x
                    }(document)
                }
                window.addEventListener("pageshow", (function() {
                    return q = !1
                })), window.addEventListener("pagehide", (function() {
                    return q = !0
                })), window.addEventListener("error", (function reportEvent(t) {
                    t.error && report(errorContext(formatError(t.error)))
                })), window.addEventListener("unhandledrejection", (function reportPromiseRejectionEvent(t) {
                    return _reportPromiseRejectionEvent.apply(this, arguments)
                })), "#b00m" === window.location.hash && setTimeout((function() {
                    throw new Error("b00m")
                }))
            },
            9644: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _ = h(7757),
                    x = h.n(_),
                    C = h(8136),
                    E = h(9243);

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }(0, C.controller)(y = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(HealthCheckElement, window.HTMLElement);
                    var d, h = _createSuper(HealthCheckElement);

                    function HealthCheckElement() {
                        return _classCallCheck(this, HealthCheckElement), h.apply(this, arguments)
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(HealthCheckElement, [{
                        key: "closeButton",
                        get: function get() {
                            return (0, C.findTarget)(this, "closeButton")
                        }
                    }, {
                        key: "closeXButton",
                        get: function get() {
                            return (0, C.findTarget)(this, "closeXButton")
                        }
                    }, {
                        key: "eaSelect",
                        get: function get() {
                            return (0, C.findTarget)(this, "eaSelect")
                        }
                    }, {
                        key: "form",
                        get: function get() {
                            return (0, C.findTarget)(this, "form")
                        }
                    }, {
                        key: "requestButton",
                        get: function get() {
                            return (0, C.findTarget)(this, "requestButton")
                        }
                    }, {
                        key: "requestComplete",
                        get: function get() {
                            return (0, C.findTarget)(this, "requestComplete")
                        }
                    }, {
                        key: "uploadFile",
                        get: function get() {
                            return (0, C.findTarget)(this, "uploadFile")
                        }
                    }, {
                        key: "uploadFailed",
                        get: function get() {
                            return (0, C.findTarget)(this, "uploadFailed")
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            var t = this;
                            this.form.addEventListener("upload:true", (function(d) {
                                t.requestHealthCheck(d.detail.bundle_id, parseInt(t.eaSelect.value))
                            })), this.form.addEventListener("upload:false", (function() {
                                t.requestFailed()
                            })), this.uploadFile.value && this.uploadSelected()
                        }
                    }, {
                        key: "close",
                        value: function close() {
                            window.location.reload()
                        }
                    }, {
                        key: "uploadSelected",
                        value: function uploadSelected() {
                            this.requestButton.disabled = !1
                        }
                    }, {
                        key: "request",
                        value: function request() {
                            document.addEventListener("details-dialog-close", (function(t) {
                                t.preventDefault()
                            })), this.requestButton.disabled = !0, this.requestButton.textContent = "Uploading...", (0, E.f)(this.form, "submit")
                        }
                    }, {
                        key: "requestHealthCheck",
                        value: (d = function _asyncToGenerator(t) {
                            return function() {
                                var d = this,
                                    h = arguments;
                                return new Promise((function(y, _) {
                                    var x = t.apply(d, h);

                                    function _next(t) {
                                        asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                                    }

                                    function _throw(t) {
                                        asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                                    }
                                    _next(void 0)
                                }))
                            }
                        }(x().mark((function _callee(t, d) {
                            var h, y, _;
                            return x().wrap((function _callee$(x) {
                                for (;;) switch (x.prev = x.next) {
                                    case 0:
                                        return h = this.getAttribute("url"), y = this.getAttribute("csrf"), x.prev = 2, x.next = 5, window.fetch(h, {
                                            body: JSON.stringify({
                                                bundle_id: t,
                                                enterprise_id: d
                                            }),
                                            method: "post",
                                            headers: {
                                                Accept: "application/json",
                                                "X-CSRF-Token": y,
                                                "Content-Type": "application/json",
                                                "X-Requested-With": "XMLHttpRequest"
                                            }
                                        });
                                    case 5:
                                        return _ = x.sent, x.next = 8, _.status;
                                    case 8:
                                        200 === x.sent ? this.requestSuccess() : this.requestFailed(), x.next = 15;
                                        break;
                                    case 12:
                                        x.prev = 12, x.t0 = x.catch(2), this.requestFailed();
                                    case 15:
                                        return x.prev = 15, this.requestClosable(), x.finish(15);
                                    case 18:
                                    case "end":
                                        return x.stop()
                                }
                            }), _callee, this, [
                                [2, 12, 15, 18]
                            ])
                        }))), function requestHealthCheck(t, h) {
                            return d.apply(this, arguments)
                        })
                    }, {
                        key: "requestClosable",
                        value: function requestClosable() {
                            this.closeXButton.hidden = !0, this.requestButton.hidden = !0, this.closeButton.hidden = !1
                        }
                    }, {
                        key: "requestFailed",
                        value: function requestFailed() {
                            this.uploadFailed.hidden = !1
                        }
                    }, {
                        key: "requestSuccess",
                        value: function requestSuccess() {
                            this.form.hidden = !0, this.requestComplete.hidden = !1
                        }
                    }]), HealthCheckElement
                }())
            },
            7113: (t, d, h) => {
                "use strict";

                function setItem(t, d) {
                    var h;
                    null === (h = window.localStorage) || void 0 === h || h.setItem(t, d)
                }

                function getItem(t) {
                    var d;
                    return null === (d = window.localStorage) || void 0 === d ? void 0 : d.getItem(t)
                }

                function removeItem(t) {
                    var d;
                    null === (d = window.localStorage) || void 0 === d || d.removeItem(t)
                }
                h.d(d, {
                    LS: () => setItem,
                    rV: () => getItem,
                    cl: () => removeItem
                })
            },
            6635: (t, d, h) => {
                "use strict";
                h.r(d);
                var y = h(7757),
                    _ = h.n(y);
                class QueryError extends Error {
                    constructor(t) {
                        super(t), this.name = "QueryError", this.framesToPop = 1
                    }
                }

                function closest(t, d, h) {
                    const y = h || HTMLElement,
                        _ = t.closest(d);
                    if (_ instanceof y) return _;
                    throw new QueryError(`Element not found: <${y.name}> ${d}`)
                }

                function query(t, d, h) {
                    const y = h || HTMLElement,
                        _ = t.querySelector(d);
                    if (_ instanceof y) return _;
                    throw new QueryError(`Element not found: <${y.name}> ${d}`)
                }
                var x = h(9243),
                    C = h(773),
                    E = h.n(C);

                function _defineProperty(t, d, h) {
                    return d in t ? Object.defineProperty(t, d, {
                        value: h,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[d] = h, t
                }
                const O = ["[data-md-button]", "md-header", "md-bold", "md-italic", "md-quote", "md-code", "md-link", "md-image", "md-unordered-list", "md-ordered-list", "md-task-list", "md-mention", "md-ref"];

                function getButtons(t) {
                    const d = [];
                    for (const h of t.querySelectorAll(O.join(", "))) h.hidden || h.offsetWidth <= 0 && h.offsetHeight <= 0 || h.closest("markdown-toolbar") === t && d.push(h);
                    return d
                }
                const k = new WeakMap;
                class MarkdownButtonElement extends HTMLElement {
                    constructor() {
                        super();
                        const apply = () => {
                            const t = k.get(this);
                            t && applyStyle(this, t)
                        };
                        this.addEventListener("keydown", function keydown(t) {
                            return function(d) {
                                " " !== d.key && "Enter" !== d.key || (d.preventDefault(), t(d))
                            }
                        }(apply)), this.addEventListener("click", apply)
                    }
                    connectedCallback() {
                        this.hasAttribute("role") || this.setAttribute("role", "button")
                    }
                    click() {
                        const t = k.get(this);
                        t && applyStyle(this, t)
                    }
                }
                class MarkdownHeaderButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super();
                        const t = parseInt(this.getAttribute("level") || 3, 10);
                        if (t < 1 || t > 6) return;
                        const d = "".concat("#".repeat(t), " ");
                        k.set(this, {
                            prefix: d
                        })
                    }
                }
                window.customElements.get("md-header") || (window.MarkdownHeaderButtonElement = MarkdownHeaderButtonElement, window.customElements.define("md-header", MarkdownHeaderButtonElement));
                class MarkdownBoldButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "**",
                            suffix: "**",
                            trimFirst: !0
                        })
                    }
                    connectedCallback() {
                        super.connectedCallback(), this.setAttribute("hotkey", "b")
                    }
                }
                window.customElements.get("md-bold") || (window.MarkdownBoldButtonElement = MarkdownBoldButtonElement, window.customElements.define("md-bold", MarkdownBoldButtonElement));
                class MarkdownItalicButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "_",
                            suffix: "_",
                            trimFirst: !0
                        })
                    }
                    connectedCallback() {
                        super.connectedCallback(), this.setAttribute("hotkey", "i")
                    }
                }
                window.customElements.get("md-italic") || (window.MarkdownItalicButtonElement = MarkdownItalicButtonElement, window.customElements.define("md-italic", MarkdownItalicButtonElement));
                class MarkdownQuoteButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "> ",
                            multiline: !0,
                            surroundWithNewlines: !0
                        })
                    }
                }
                window.customElements.get("md-quote") || (window.MarkdownQuoteButtonElement = MarkdownQuoteButtonElement, window.customElements.define("md-quote", MarkdownQuoteButtonElement));
                class MarkdownCodeButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "`",
                            suffix: "`",
                            blockPrefix: "```",
                            blockSuffix: "```"
                        })
                    }
                }
                window.customElements.get("md-code") || (window.MarkdownCodeButtonElement = MarkdownCodeButtonElement, window.customElements.define("md-code", MarkdownCodeButtonElement));
                class MarkdownLinkButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "[",
                            suffix: "](url)",
                            replaceNext: "url",
                            scanFor: "https?://"
                        })
                    }
                    connectedCallback() {
                        super.connectedCallback(), this.setAttribute("hotkey", "k")
                    }
                }
                window.customElements.get("md-link") || (window.MarkdownLinkButtonElement = MarkdownLinkButtonElement, window.customElements.define("md-link", MarkdownLinkButtonElement));
                class MarkdownImageButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "![",
                            suffix: "](url)",
                            replaceNext: "url",
                            scanFor: "https?://"
                        })
                    }
                }
                window.customElements.get("md-image") || (window.MarkdownImageButtonElement = MarkdownImageButtonElement, window.customElements.define("md-image", MarkdownImageButtonElement));
                class MarkdownUnorderedListButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "- ",
                            multiline: !0,
                            surroundWithNewlines: !0
                        })
                    }
                }
                window.customElements.get("md-unordered-list") || (window.MarkdownUnorderedListButtonElement = MarkdownUnorderedListButtonElement, window.customElements.define("md-unordered-list", MarkdownUnorderedListButtonElement));
                class MarkdownOrderedListButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "1. ",
                            multiline: !0,
                            orderedList: !0
                        })
                    }
                }
                window.customElements.get("md-ordered-list") || (window.MarkdownOrderedListButtonElement = MarkdownOrderedListButtonElement, window.customElements.define("md-ordered-list", MarkdownOrderedListButtonElement));
                class MarkdownTaskListButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "- [ ] ",
                            multiline: !0,
                            surroundWithNewlines: !0
                        })
                    }
                    connectedCallback() {
                        super.connectedCallback(), this.setAttribute("hotkey", "L")
                    }
                }
                window.customElements.get("md-task-list") || (window.MarkdownTaskListButtonElement = MarkdownTaskListButtonElement, window.customElements.define("md-task-list", MarkdownTaskListButtonElement));
                class MarkdownMentionButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "@",
                            prefixSpace: !0
                        })
                    }
                }
                window.customElements.get("md-mention") || (window.MarkdownMentionButtonElement = MarkdownMentionButtonElement, window.customElements.define("md-mention", MarkdownMentionButtonElement));
                class MarkdownRefButtonElement extends MarkdownButtonElement {
                    constructor() {
                        super(), k.set(this, {
                            prefix: "#",
                            prefixSpace: !0
                        })
                    }
                }
                window.customElements.get("md-ref") || (window.MarkdownRefButtonElement = MarkdownRefButtonElement, window.customElements.define("md-ref", MarkdownRefButtonElement));
                const z = navigator.userAgent.match(/Macintosh/) ? "Meta" : "Control";
                class MarkdownToolbarElement extends HTMLElement {
                    constructor() {
                        super()
                    }
                    connectedCallback() {
                        this.hasAttribute("role") || this.setAttribute("role", "toolbar"), this.addEventListener("keydown", focusKeydown);
                        const t = shortcut.bind(null, this);
                        this.field && (this.field.addEventListener("keydown", t), A.set(this, t)), this.setAttribute("tabindex", "0"), this.addEventListener("focus", onToolbarFocus, {
                            once: !0
                        })
                    }
                    disconnectedCallback() {
                        const t = A.get(this);
                        t && this.field && (this.field.removeEventListener("keydown", t), A.delete(this)), this.removeEventListener("keydown", focusKeydown)
                    }
                    get field() {
                        const t = this.getAttribute("for");
                        if (!t) return;
                        const d = document.getElementById(t);
                        return d instanceof HTMLTextAreaElement ? d : null
                    }
                }

                function onToolbarFocus(t) {
                    let {
                        target: d
                    } = t;
                    if (!(d instanceof Element)) return;
                    d.removeAttribute("tabindex");
                    let h = "0";
                    for (const y of getButtons(d)) y.setAttribute("tabindex", h), "0" === h && (y.focus(), h = "-1")
                }

                function focusKeydown(t) {
                    const d = t.key;
                    if ("ArrowRight" !== d && "ArrowLeft" !== d && "Home" !== d && "End" !== d) return;
                    const h = t.currentTarget;
                    if (!(h instanceof HTMLElement)) return;
                    const y = getButtons(h),
                        _ = y.indexOf(t.target),
                        x = y.length;
                    if (-1 === _) return;
                    let C = 0;
                    "ArrowLeft" === d && (C = _ - 1), "ArrowRight" === d && (C = _ + 1), "End" === d && (C = x - 1), C < 0 && (C = x - 1), C > x - 1 && (C = 0);
                    for (let E = 0; E < x; E += 1) y[E].setAttribute("tabindex", E === C ? "0" : "-1");
                    t.preventDefault(), y[C].focus()
                }
                const A = new WeakMap;

                function shortcut(t, d) {
                    if (d.metaKey && "Meta" === z || d.ctrlKey && "Control" === z) {
                        const h = t.querySelector('[hotkey="'.concat(d.key, '"]'));
                        h && (h.click(), d.preventDefault())
                    }
                }

                function isMultipleLines(t) {
                    return t.trim().split("\n").length > 1
                }

                function repeat(t, d) {
                    return Array(d + 1).join(t)
                }

                function wordSelectionStart(t, d) {
                    let h = d;
                    for (; t[h] && null != t[h - 1] && !t[h - 1].match(/\s/);) h--;
                    return h
                }

                function wordSelectionEnd(t, d, h) {
                    let y = d;
                    const _ = h ? /\n/ : /\s/;
                    for (; t[y] && !t[y].match(_);) y++;
                    return y
                }
                window.customElements.get("markdown-toolbar") || (window.MarkdownToolbarElement = MarkdownToolbarElement, window.customElements.define("markdown-toolbar", MarkdownToolbarElement));
                let B = null;

                function styleSelectedText(t, d) {
                    const h = t.value.slice(t.selectionStart, t.selectionEnd);
                    let y;
                    y = d.orderedList ? function orderedList(t) {
                            const d = /^\d+\.\s+/,
                                h = t.selectionStart === t.selectionEnd;
                            let y, _, x, C, E = t.value.slice(t.selectionStart, t.selectionEnd),
                                O = E,
                                k = E.split("\n");
                            if (h) {
                                const d = t.value.slice(0, t.selectionStart).split(/\n/);
                                x = t.selectionStart - d[d.length - 1].length, C = wordSelectionEnd(t.value, t.selectionStart, !0), O = t.value.slice(x, C)
                            }
                            const z = O.split("\n");
                            if (z.every((t => d.test(t)))) {
                                if (k = z.map((t => t.replace(d, ""))), E = k.join("\n"), h && x && C) {
                                    const d = z[0].length - k[0].length;
                                    _ = y = t.selectionStart - d, t.selectionStart = x, t.selectionEnd = C
                                }
                            } else {
                                k = function() {
                                    let t, d, h;
                                    const y = [];
                                    for (h = t = 0, d = k.length; t < d; h = ++t) {
                                        const t = k[h];
                                        y.push("".concat(h + 1, ". ").concat(t))
                                    }
                                    return y
                                }(), E = k.join("\n");
                                const {
                                    newlinesToAppend: d,
                                    newlinesToPrepend: x
                                } = newlinesToSurroundSelectedText(t);
                                _ = t.selectionStart + d.length, y = _ + E.length, h && (_ = y), E = d + E + x
                            }
                            return {
                                text: E,
                                selectionStart: _,
                                selectionEnd: y
                            }
                        }(t) : d.multiline && isMultipleLines(h) ? function multilineStyle(t, d) {
                            const {
                                prefix: h,
                                suffix: y,
                                surroundWithNewlines: _
                            } = d;
                            let x = t.value.slice(t.selectionStart, t.selectionEnd),
                                C = t.selectionStart,
                                E = t.selectionEnd;
                            const O = x.split("\n");
                            if (O.every((t => t.startsWith(h) && t.endsWith(y)))) x = O.map((t => t.slice(h.length, t.length - y.length))).join("\n"), E = C + x.length;
                            else if (x = O.map((t => h + t + y)).join("\n"), _) {
                                const {
                                    newlinesToAppend: d,
                                    newlinesToPrepend: h
                                } = newlinesToSurroundSelectedText(t);
                                C += d.length, E = C + x.length, x = d + x + h
                            }
                            return {
                                text: x,
                                selectionStart: C,
                                selectionEnd: E
                            }
                        }(t, d) : function blockStyle(t, d) {
                            let h, y;
                            const {
                                prefix: _,
                                suffix: x,
                                blockPrefix: C,
                                blockSuffix: E,
                                replaceNext: O,
                                prefixSpace: k,
                                scanFor: z,
                                surroundWithNewlines: A
                            } = d, B = t.selectionStart, I = t.selectionEnd;
                            let q = t.value.slice(t.selectionStart, t.selectionEnd),
                                D = isMultipleLines(q) && C.length > 0 ? "".concat(C, "\n") : _,
                                j = isMultipleLines(q) && E.length > 0 ? "\n".concat(E) : x;
                            if (k) {
                                const d = t.value[t.selectionStart - 1];
                                0 === t.selectionStart || null == d || d.match(/\s/) || (D = " ".concat(D))
                            }
                            q = function expandSelectedText(t, d, h) {
                                let y = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                                if (t.selectionStart === t.selectionEnd) t.selectionStart = wordSelectionStart(t.value, t.selectionStart), t.selectionEnd = wordSelectionEnd(t.value, t.selectionEnd, y);
                                else {
                                    const y = t.selectionStart - d.length,
                                        _ = t.selectionEnd + h.length,
                                        x = t.value.slice(y, t.selectionStart) === d,
                                        C = t.value.slice(t.selectionEnd, _) === h;
                                    x && C && (t.selectionStart = y, t.selectionEnd = _)
                                }
                                return t.value.slice(t.selectionStart, t.selectionEnd)
                            }(t, D, j, d.multiline);
                            let H = t.selectionStart,
                                $ = t.selectionEnd;
                            const G = O.length > 0 && j.indexOf(O) > -1 && q.length > 0;
                            if (A) {
                                const d = newlinesToSurroundSelectedText(t);
                                h = d.newlinesToAppend, y = d.newlinesToPrepend, D = h + _, j += y
                            }
                            if (q.startsWith(D) && q.endsWith(j)) {
                                const t = q.slice(D.length, q.length - j.length);
                                if (B === I) {
                                    let d = B - D.length;
                                    d = Math.max(d, H), d = Math.min(d, H + t.length), H = $ = d
                                } else $ = H + t.length;
                                return {
                                    text: t,
                                    selectionStart: H,
                                    selectionEnd: $
                                }
                            }
                            if (G) {
                                if (z.length > 0 && q.match(z)) {
                                    j = j.replace(O, q);
                                    const t = D + j;
                                    return H = $ = H + D.length, {
                                        text: t,
                                        selectionStart: H,
                                        selectionEnd: $
                                    }
                                } {
                                    const t = D + q + j;
                                    return H = H + D.length + q.length + j.indexOf(O), $ = H + O.length, {
                                        text: t,
                                        selectionStart: H,
                                        selectionEnd: $
                                    }
                                }
                            } {
                                let t = D + q + j;
                                H = B + D.length, $ = I + D.length;
                                const h = q.match(/^\s*|\s*$/g);
                                if (d.trimFirst && h) {
                                    const d = h[0] || "",
                                        y = h[1] || "";
                                    t = d + D + q.trim() + j + y, H += d.length, $ -= y.length
                                }
                                return {
                                    text: t,
                                    selectionStart: H,
                                    selectionEnd: $
                                }
                            }
                        }(t, d),
                        function insertText(t, d) {
                            let {
                                text: h,
                                selectionStart: y,
                                selectionEnd: _
                            } = d;
                            const x = t.selectionStart,
                                C = t.value.slice(0, x),
                                E = t.value.slice(t.selectionEnd);
                            if (null === B || !0 === B) {
                                t.contentEditable = "true";
                                try {
                                    B = document.execCommand("insertText", !1, h)
                                } catch (O) {
                                    B = !1
                                }
                                t.contentEditable = "false"
                            }
                            if (B && !t.value.slice(0, t.selectionStart).endsWith(h) && (B = !1), !B) {
                                try {
                                    document.execCommand("ms-beginUndoUnit")
                                } catch (k) {}
                                t.value = C + h + E;
                                try {
                                    document.execCommand("ms-endUndoUnit")
                                } catch (k) {}
                                t.dispatchEvent(new CustomEvent("input", {
                                    bubbles: !0,
                                    cancelable: !0
                                }))
                            }
                            null != y && null != _ ? t.setSelectionRange(y, _) : t.setSelectionRange(x, t.selectionEnd)
                        }(t, y)
                }

                function newlinesToSurroundSelectedText(t) {
                    const d = t.value.slice(0, t.selectionStart),
                        h = t.value.slice(t.selectionEnd),
                        y = d.match(/\n*$/),
                        _ = h.match(/^\n*/),
                        x = y ? y[0].length : 0,
                        C = _ ? _[0].length : 0;
                    let E, O;
                    return d.match(/\S/) && x < 2 && (E = repeat("\n", 2 - x)), h.match(/\S/) && C < 2 && (O = repeat("\n", 2 - C)), null == E && (E = ""), null == O && (O = ""), {
                        newlinesToAppend: E,
                        newlinesToPrepend: O
                    }
                }

                function applyStyle(t, d) {
                    const h = t.closest("markdown-toolbar");
                    if (!(h instanceof MarkdownToolbarElement)) return;
                    const y = function _objectSpread(t) {
                            for (var d = 1; d < arguments.length; d++) {
                                var h = null != arguments[d] ? arguments[d] : {},
                                    y = Object.keys(h);
                                "function" == typeof Object.getOwnPropertySymbols && (y = y.concat(Object.getOwnPropertySymbols(h).filter((function(t) {
                                    return Object.getOwnPropertyDescriptor(h, t).enumerable
                                })))), y.forEach((function(d) {
                                    _defineProperty(t, d, h[d])
                                }))
                            }
                            return t
                        }({}, {
                            prefix: "",
                            suffix: "",
                            blockPrefix: "",
                            blockSuffix: "",
                            multiline: !1,
                            replaceNext: "",
                            prefixSpace: !1,
                            scanFor: "",
                            surroundWithNewlines: !1,
                            orderedList: !1,
                            trimFirst: !1
                        }, d),
                        _ = h.field;
                    _ && (_.focus(), styleSelectedText(_, y))
                }

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _asyncToGenerator(t) {
                    return function() {
                        var d = this,
                            h = arguments;
                        return new Promise((function(y, _) {
                            var x = t.apply(d, h);

                            function _next(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                            }

                            function _throw(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                            }
                            _next(void 0)
                        }))
                    }
                }

                function activateTab(t) {
                    var d = closest(t, ".js-previewable-comment-form"),
                        h = t.classList.contains("js-preview-tab");
                    if (h) {
                        var y = query(d, ".js-comment-content"),
                            _ = query(d, ".js-preview-body"),
                            x = query(d, "#file-uploader");
                        _.style.minHeight = "".concat(y.clientHeight + x.clientHeight, "px")
                    }
                    d.classList.toggle("preview-selected", h), d.classList.toggle("write-selected", !h);
                    var C = query(d, '.tabnav-tab.selected, .tabnav-tab[aria-selected="true"]');
                    return C.setAttribute("aria-selected", "false"), C.classList.remove("selected"), t.classList.add("selected"), t.setAttribute("aria-selected", "true"), d
                }

                function csrfToken(t) {
                    var d = t.querySelector(".js-md-preview-csrf");
                    if (d) return d.value
                }

                function fetchPreview(t, d) {
                    return _fetchPreview.apply(this, arguments)
                }

                function _fetchPreview() {
                    return (_fetchPreview = _asyncToGenerator(_().mark((function _callee(t, d) {
                        var h;
                        return _().wrap((function _callee$(y) {
                            for (;;) switch (y.prev = y.next) {
                                case 0:
                                    return y.next = 2, window.fetch("/comment/markdown", {
                                        method: "post",
                                        body: JSON.stringify({
                                            text: t
                                        }),
                                        headers: {
                                            Accept: "text/plain",
                                            "Content-Type": "application/json",
                                            "X-CSRF-Token": d,
                                            "X-Requested-With": "XMLHttpRequest"
                                        },
                                        credentials: "same-origin",
                                        redirect: "error"
                                    }).catch((function(t) {
                                        throw new Error("Error rendering markdown, error: ".concat(t))
                                    }));
                                case 2:
                                    if (200 !== (h = y.sent).status) {
                                        y.next = 7;
                                        break
                                    }
                                    return y.abrupt("return", h.text());
                                case 7:
                                    throw new Error("Error rendering markdown, status: ".concat(h.status));
                                case 8:
                                case "end":
                                    return y.stop()
                            }
                        }), _callee)
                    })))).apply(this, arguments)
                }(0, x.on)("click", ".js-write-tab", (function(t) {
                    var d = t.currentTarget,
                        h = closest(d, ".js-previewable-comment-form"),
                        y = activateTab(d);
                    setTimeout((function() {
                        query(y, ".js-comment-field").focus()
                    }));
                    var _ = h.querySelector("markdown-toolbar"),
                        x = h.querySelector("#file-uploader");
                    _ && (_.hidden = !1), x && (x.hidden = !1)
                })), (0, x.on)("click", ".js-preview-tab", (function(t) {
                    var d = t.currentTarget,
                        h = closest(d, ".js-previewable-comment-form");
                    if (!h.classList.contains("preview-selected")) {
                        var y = activateTab(d);
                        setTimeout((function() {
                            ! function renderPreview(t) {
                                return _renderPreview.apply(this, arguments)
                            }(y)
                        }));
                        var _ = h.querySelector("markdown-toolbar"),
                            x = h.querySelector("#file-uploader");
                        _ && (_.hidden = !0), x && (x.hidden = !0), t.stopPropagation(), t.preventDefault()
                    }
                }));
                var I = E()((function uncachedFetch(t, d) {
                    return _uncachedFetch.apply(this, arguments)
                }));

                function _uncachedFetch() {
                    return (_uncachedFetch = _asyncToGenerator(_().mark((function _callee2(t, d) {
                        return _().wrap((function _callee2$(h) {
                            for (;;) switch (h.prev = h.next) {
                                case 0:
                                    return h.abrupt("return", fetchPreview(t, d));
                                case 1:
                                case "end":
                                    return h.stop()
                            }
                        }), _callee2)
                    })))).apply(this, arguments)
                }

                function _renderPreview() {
                    return (_renderPreview = _asyncToGenerator(_().mark((function _callee3(t) {
                        var d, h, y, x;
                        return _().wrap((function _callee3$(_) {
                            for (;;) switch (_.prev = _.next) {
                                case 0:
                                    if (d = csrfToken(t), h = query(t, ".comment-body"), (y = query(t, ".js-comment-field")).value) {
                                        _.next = 5;
                                        break
                                    }
                                    return _.abrupt("return");
                                case 5:
                                    return h.innerHTML = "<p>Loading preview&hellip;</p>", _.prev = 6, _.next = 9, I(y.value, d);
                                case 9:
                                    x = _.sent, h.innerHTML = x || "<p>Nothing to preview</p>", _.next = 17;
                                    break;
                                case 13:
                                    _.prev = 13, _.t0 = _.catch(6), h.innerHTML = "<p>Error rendering preview</p>", console.error(_.t0);
                                case 17:
                                case "end":
                                    return _.stop()
                            }
                        }), _callee3, null, [
                            [6, 13]
                        ])
                    })))).apply(this, arguments)
                }
            },
            7964: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _ = h(7757),
                    x = h.n(_),
                    C = h(8136);

                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = function _unsupportedIterableToArray(t, d) {
                                if (!t) return;
                                if ("string" == typeof t) return _arrayLikeToArray(t, d);
                                var h = Object.prototype.toString.call(t).slice(8, -1);
                                "Object" === h && t.constructor && (h = t.constructor.name);
                                if ("Map" === h || "Set" === h) return Array.from(t);
                                if ("Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)) return _arrayLikeToArray(t, d)
                            }(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }(0, C.controller)(y = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(NavigationMenuElement, window.HTMLElement);
                    var d, h = _createSuper(NavigationMenuElement);

                    function NavigationMenuElement() {
                        return _classCallCheck(this, NavigationMenuElement), h.apply(this, arguments)
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(NavigationMenuElement, [{
                        key: "notificationDot",
                        get: function get() {
                            return (0, C.findTarget)(this, "notificationDot")
                        }
                    }, {
                        key: "premiumLink",
                        get: function get() {
                            return (0, C.findTarget)(this, "premiumLink")
                        }
                    }, {
                        key: "links",
                        get: function get() {
                            return (0, C.findTarget)(this, "links")
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            var t = this;
                            document.addEventListener("premiumbuttonloaded", (function() {
                                t.loadNotifications()
                            })), this.premiumLink && !this.premiumLink.hidden && this.loadNotifications()
                        }
                    }, {
                        key: "loadNotifications",
                        value: (d = function _asyncToGenerator(t) {
                            return function() {
                                var d = this,
                                    h = arguments;
                                return new Promise((function(y, _) {
                                    var x = t.apply(d, h);

                                    function _next(t) {
                                        asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                                    }

                                    function _throw(t) {
                                        asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                                    }
                                    _next(void 0)
                                }))
                            }
                        }(x().mark((function _callee() {
                            var t, d, h, y, _, C;
                            return x().wrap((function _callee$(x) {
                                for (;;) switch (x.prev = x.next) {
                                    case 0:
                                        return t = this.getAttribute("premium-notifications-url"), x.next = 3, window.fetch(t, {
                                            method: "get",
                                            headers: {
                                                "Content-Type": "application/json",
                                                "X-Requested-With": "XMLHttpRequest"
                                            }
                                        });
                                    case 3:
                                        return d = x.sent, x.next = 6, d.json();
                                    case 6:
                                        (h = x.sent).length && this.showNotificationDot(), y = _createForOfIteratorHelper(h), x.prev = 9, y.s();
                                    case 11:
                                        if ((_ = y.n()).done) {
                                            x.next = 20;
                                            break
                                        }
                                        C = _.value, x.t0 = C, x.next = "health_check" === x.t0 ? 16 : 18;
                                        break;
                                    case 16:
                                        return this.showHealthCheckTooltip(), x.abrupt("break", 18);
                                    case 18:
                                        x.next = 11;
                                        break;
                                    case 20:
                                        x.next = 25;
                                        break;
                                    case 22:
                                        x.prev = 22, x.t1 = x.catch(9), y.e(x.t1);
                                    case 25:
                                        return x.prev = 25, y.f(), x.finish(25);
                                    case 28:
                                    case "end":
                                        return x.stop()
                                }
                            }), _callee, this, [
                                [9, 22, 25, 28]
                            ])
                        }))), function loadNotifications() {
                            return d.apply(this, arguments)
                        })
                    }, {
                        key: "showNotificationDot",
                        value: function showNotificationDot() {
                            this.notificationDot.hidden = !1
                        }
                    }, {
                        key: "showHealthCheckTooltip",
                        value: function showHealthCheckTooltip() {
                            this.premiumLink.classList.add("tooltipped", "tooltipped-sw"), this.premiumLink.setAttribute("aria-label", "You have a completed Health Check.")
                        }
                    }, {
                        key: "openMenu",
                        value: function openMenu() {
                            this.links.classList.toggle("hide-md"), this.links.classList.toggle("hide-sm")
                        }
                    }]), NavigationMenuElement
                }())
            },
            4690: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E = h(8136);

                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = function _unsupportedIterableToArray(t, d) {
                                if (!t) return;
                                if ("string" == typeof t) return _arrayLikeToArray(t, d);
                                var h = Object.prototype.toString.call(t).slice(8, -1);
                                "Object" === h && t.constructor && (h = t.constructor.name);
                                if ("Map" === h || "Set" === h) return Array.from(t);
                                if ("Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)) return _arrayLikeToArray(t, d)
                            }(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }
                var O = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + O++ + "_" + t
                }

                function _get_shouldClearValues() {
                    return null !== this.getAttribute("clear-all")
                }

                function _isCheckbox2(t) {
                    return "checkbox" === t.getAttribute("type")
                }

                function _key2(t) {
                    var d, h, y = "restorable:".concat(null !== (d = null === (h = this.form) || void 0 === h ? void 0 : h.id) && void 0 !== d ? d : this.formID);
                    return t && (y += ":".concat(t.id)), y
                }(0, E.controller)((y = _classPrivateFieldLooseKey("shouldClearValues"), _ = _classPrivateFieldLooseKey("isRestoring"), x = _classPrivateFieldLooseKey("isCheckbox"), C = _classPrivateFieldLooseKey("key"), function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(RestorableFormElement, window.HTMLElement);
                    var d = _createSuper(RestorableFormElement);

                    function RestorableFormElement() {
                        var t;
                        _classCallCheck(this, RestorableFormElement);
                        for (var h = arguments.length, E = new Array(h), O = 0; O < h; O++) E[O] = arguments[O];
                        return t = d.call.apply(d, [this].concat(E)), Object.defineProperty(_assertThisInitialized(t), C, {
                            value: _key2
                        }), Object.defineProperty(_assertThisInitialized(t), x, {
                            value: _isCheckbox2
                        }), Object.defineProperty(_assertThisInitialized(t), y, {
                            get: _get_shouldClearValues,
                            set: void 0
                        }), Object.defineProperty(_assertThisInitialized(t), _, {
                            writable: !0,
                            value: !1
                        }), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(RestorableFormElement, [{
                        key: "formElements",
                        get: function get() {
                            var t, d, h = null !== (t = null === (d = this.form) || void 0 === d ? void 0 : d.elements) && void 0 !== t ? t : [];
                            return Array.from(h).filter((function(t) {
                                return t.id && !t.dataset.skipRestore
                            }))
                        }
                    }, {
                        key: "form",
                        get: function get() {
                            return (0, E.findTarget)(this, "form")
                        }
                    }, {
                        key: "formID",
                        get: function get() {
                            return this.getAttribute("form-id")
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            this.form ? window.addEventListener("load", this.restoreValues.bind(this)) : _classPrivateFieldLooseBase(this, y)[y] && (this.form || this.formID) && this.clearAllValues()
                        }
                    }, {
                        key: "clearValue",
                        value: function clearValue(t) {
                            window.sessionStorage.removeItem(_classPrivateFieldLooseBase(this, C)[C](t))
                        }
                    }, {
                        key: "clearAllValues",
                        value: function clearAllValues() {
                            for (var t, d = 0; t = window.sessionStorage.key(d);) t.startsWith(_classPrivateFieldLooseBase(this, C)[C]()) ? window.sessionStorage.removeItem(t) : d++
                        }
                    }, {
                        key: "restoreValues",
                        value: function restoreValues() {
                            var t;
                            _classPrivateFieldLooseBase(this, _)[_] = !0;
                            var d, h = _createForOfIteratorHelper(this.formElements);
                            try {
                                for (h.s(); !(d = h.n()).done;) {
                                    var y = d.value;
                                    (t = window.sessionStorage.getItem(_classPrivateFieldLooseBase(this, C)[C](y))) && (_classPrivateFieldLooseBase(this, x)[x](y) ? y.checked = !0 : y.value = t, y.dispatchEvent(new window.Event("change", {
                                        bubbles: !0
                                    })), y.dispatchEvent(new window.CustomEvent("restoredValues", {
                                        bubbles: !0
                                    })))
                                }
                            } catch (E) {
                                h.e(E)
                            } finally {
                                h.f()
                            }
                            _classPrivateFieldLooseBase(this, _)[_] = !1
                        }
                    }, {
                        key: "saveValue",
                        value: function saveValue(t) {
                            _classPrivateFieldLooseBase(this, _)[_] || !t.target.id || t.target.dataset.skipRestore || (_classPrivateFieldLooseBase(this, x)[x](t.target) && !t.target.checked ? window.sessionStorage.removeItem("".concat(_classPrivateFieldLooseBase(this, C)[C](t.target))) : window.sessionStorage.setItem("".concat(_classPrivateFieldLooseBase(this, C)[C](t.target)), t.target.value))
                        }
                    }]), RestorableFormElement
                }()))
            },
            263: (t, d, h) => {
                "use strict";
                h.r(d);
                var y = h(7757),
                    _ = h.n(y),
                    x = h(8136);

                function debounce(t, d = 0, {
                    start: h = !1,
                    middle: y = !1,
                    once: _ = !1
                } = {}) {
                    return function throttle(t, d = 0, {
                        start: h = !0,
                        middle: y = !0,
                        once: _ = !1
                    } = {}) {
                        let x, C = 0,
                            E = !1;

                        function fn(...O) {
                            if (E) return;
                            const k = Date.now() - C;
                            C = Date.now(), h ? (h = !1, t.apply(this, O), _ && fn.cancel()) : (y && k < d || !y) && (clearTimeout(x), x = setTimeout((() => {
                                C = Date.now(), t.apply(this, O), _ && fn.cancel()
                            }), y ? d - k : d))
                        }
                        return fn.cancel = () => {
                            clearTimeout(x), E = !0
                        }, fn
                    }(t, d, {
                        start: h,
                        middle: y,
                        once: _
                    })
                }

                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = function _unsupportedIterableToArray(t, d) {
                                if (!t) return;
                                if ("string" == typeof t) return _arrayLikeToArray(t, d);
                                var h = Object.prototype.toString.call(t).slice(8, -1);
                                "Object" === h && t.constructor && (h = t.constructor.name);
                                if ("Map" === h || "Set" === h) return Array.from(t);
                                if ("Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)) return _arrayLikeToArray(t, d)
                            }(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function highlightString(t, d, h) {
                    var y, _ = document.createElement(t),
                        x = d.toLowerCase(),
                        C = [],
                        E = _createForOfIteratorHelper(h.toLowerCase().split(" "));
                    try {
                        for (E.s(); !(y = E.n()).done;) {
                            var O = y.value;
                            if (O.length < 2) break;
                            for (var k = x.indexOf(O); - 1 !== k;) {
                                var z = k + O.length,
                                    A = document.createElement("em");
                                A.textContent = d.slice(k, z), C.push({
                                    node: A,
                                    start: k,
                                    end: z
                                }), -1 !== (k = x.slice(z).indexOf(O)) && (k += z)
                            }
                        }
                    } catch (j) {
                        E.e(j)
                    } finally {
                        E.f()
                    }
                    C.sort((function(t, d) {
                        return t.start < d.start ? -1 : 1
                    }));
                    for (var B = 0, I = 0, q = C; I < q.length; I++) {
                        var D = q[I];
                        D.start < B || (_.appendChild(document.createTextNode(d.slice(B, D.start))), _.appendChild(D.node), B = D.end)
                    }
                    return _.appendChild(document.createTextNode(d.slice(B))), _
                }

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }(0, x.controller)(function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(SearchHitElement, window.HTMLElement);
                    var d = _createSuper(SearchHitElement);

                    function SearchHitElement() {
                        return _classCallCheck(this, SearchHitElement), d.apply(this, arguments)
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(SearchHitElement, [{
                        key: "anchor",
                        get: function get() {
                            return (0, x.findTarget)(this, "anchor")
                        }
                    }, {
                        key: "icon",
                        get: function get() {
                            return (0, x.findTarget)(this, "icon")
                        }
                    }, {
                        key: "intro",
                        get: function get() {
                            return (0, x.findTarget)(this, "intro")
                        }
                    }, {
                        key: "introFulltext",
                        get: function get() {
                            return (0, x.findTarget)(this, "introFulltext")
                        }
                    }, {
                        key: "section",
                        get: function get() {
                            return (0, x.findTarget)(this, "section")
                        }
                    }, {
                        key: "title",
                        get: function get() {
                            return (0, x.findTarget)(this, "title")
                        }
                    }, {
                        key: "wrapper",
                        get: function get() {
                            return (0, x.findTarget)(this, "wrapper")
                        }
                    }, {
                        key: "load",
                        value: function load(t) {
                            var d, h, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                            if (this.title.appendChild(highlightString("span", t.title, y)), t.url ? this.anchor.href = t.url : this.anchor.classList.add("text-inherit"), t.event && t.hmac && (this.anchor.dataset.eventClick = t.event, this.anchor.dataset.eventHmac = t.hmac), t.fulltext && t.intro && this.introFulltext) {
                                this.introFulltext.appendChild(highlightString("span", t.intro, y));
                                var _ = this.introFulltext.closest("li");
                                _ && _.classList.add("search-result-fulltext")
                            } else t.intro && this.intro && this.intro.appendChild(highlightString("span", t.intro, y));
                            if (this.section && (this.section.textContent = t.section), this.icon && t.icon) {
                                var x = document.getElementById("octicon-".concat(t.icon));
                                x && this.icon.appendChild(x.cloneNode(!0))
                            }(t.topics && 0 !== t.topics.length && this.setAttribute("topics", t.topics), t.category && 0 !== t.category.length && this.setAttribute("category", t.category), t.highlight) && (null !== (d = this.wrapper) && void 0 !== d && null !== (h = d.dataset) && void 0 !== h && h.highlightClasslist && (this.wrapper.className = this.wrapper.dataset.highlightClasslist))
                        }
                    }]), SearchHitElement
                }());
                var C, E, O, k, z, A, B, I, q, D, j, H, $, G, ee, te, re = h(7113);

                function search_settings_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function search_settings_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function search_settings_setPrototypeOf(t, d) {
                    return search_settings_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, search_settings_setPrototypeOf(t, d)
                }

                function search_settings_createSuper(t) {
                    var d = function search_settings_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = search_settings_getPrototypeOf(t);
                        if (d) {
                            var _ = search_settings_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return search_settings_possibleConstructorReturn(this, h)
                    }
                }

                function search_settings_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function search_settings_assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function search_settings_getPrototypeOf(t) {
                    return search_settings_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, search_settings_getPrototypeOf(t)
                }

                function search_field_createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = search_field_unsupportedIterableToArray(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _asyncToGenerator(t) {
                    return function() {
                        var d = this,
                            h = arguments;
                        return new Promise((function(y, _) {
                            var x = t.apply(d, h);

                            function _next(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                            }

                            function _throw(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                            }
                            _next(void 0)
                        }))
                    }
                }

                function _toConsumableArray(t) {
                    return function _arrayWithoutHoles(t) {
                        if (Array.isArray(t)) return search_field_arrayLikeToArray(t)
                    }(t) || function _iterableToArray(t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                    }(t) || search_field_unsupportedIterableToArray(t) || function _nonIterableSpread() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function search_field_unsupportedIterableToArray(t, d) {
                    if (t) {
                        if ("string" == typeof t) return search_field_arrayLikeToArray(t, d);
                        var h = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === h && t.constructor && (h = t.constructor.name), "Map" === h || "Set" === h ? Array.from(t) : "Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h) ? search_field_arrayLikeToArray(t, d) : void 0
                    }
                }

                function search_field_arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function search_field_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function search_field_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function search_field_setPrototypeOf(t, d) {
                    return search_field_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, search_field_setPrototypeOf(t, d)
                }

                function search_field_createSuper(t) {
                    var d = function search_field_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = search_field_getPrototypeOf(t);
                        if (d) {
                            var _ = search_field_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return search_field_possibleConstructorReturn(this, h)
                    }
                }

                function search_field_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return search_field_assertThisInitialized(t)
                }

                function search_field_assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function search_field_getPrototypeOf(t) {
                    return search_field_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, search_field_getPrototypeOf(t)
                }

                function _classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }(0, x.controller)(function(t) {
                    ! function search_settings_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && search_settings_setPrototypeOf(t, d)
                    }(SearchSettingsElement, window.HTMLElement);
                    var d = search_settings_createSuper(SearchSettingsElement);

                    function SearchSettingsElement() {
                        var t;
                        search_settings_classCallCheck(this, SearchSettingsElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return (t = d.call.apply(d, [this].concat(y))).SEARCH_SETTINGS_KEY = "search_settings", t
                    }
                    return function search_settings_createClass(t, d, h) {
                        return d && search_settings_defineProperties(t.prototype, d), h && search_settings_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(SearchSettingsElement, [{
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            this.setFilterAPICheckbox()
                        }
                    }, {
                        key: "filterAPIKey",
                        get: function get() {
                            return this.filterAPICheckbox.getAttribute("data-setting") || ""
                        }
                    }, {
                        key: "filterAPICheckbox",
                        get: function get() {
                            return (0, x.findTarget)(this, "filterAPICheckbox")
                        }
                    }, {
                        key: "saveAPISetting",
                        value: function saveAPISetting() {
                            this.searchSettings().includes(this.filterAPIKey) && this.filterAPICheckbox.checked ? this.removeSetting(this.SEARCH_SETTINGS_KEY, this.filterAPIKey) : this.addSetting(this.SEARCH_SETTINGS_KEY, this.filterAPIKey)
                        }
                    }, {
                        key: "removeSetting",
                        value: function removeSetting(t, d) {
                            var h = this.searchSettings().filter((function(t) {
                                return t !== d && "" !== t
                            }));
                            (0, re.LS)(t, h.join(",")), this.clearEmptySettings(h)
                        }
                    }, {
                        key: "addSetting",
                        value: function addSetting(t, d) {
                            var h = this.searchSettings().concat(d || []);
                            (0, re.LS)(t, h.join(","))
                        }
                    }, {
                        key: "clearEmptySettings",
                        value: function clearEmptySettings(t) {
                            t.length || (0, re.cl)(this.SEARCH_SETTINGS_KEY)
                        }
                    }, {
                        key: "setFilterAPICheckbox",
                        value: function setFilterAPICheckbox() {
                            this.filterAPICheckbox.checked = !this.searchSettings().includes(this.filterAPIKey)
                        }
                    }, {
                        key: "searchSettings",
                        value: function searchSettings() {
                            try {
                                return ((0, re.rV)(this.SEARCH_SETTINGS_KEY) || "").split(",")
                            } catch (t) {
                                return []
                            }
                        }
                    }]), SearchSettingsElement
                }());
                var ne = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + ne++ + "_" + t
                }

                function _get_initialQuery() {
                    return this.getAttribute("initial-query")
                }

                function _get_maxQueryLength() {
                    return parseInt(this.getAttribute("max-query-length"), 10) || 200
                }

                function _get_maxHits() {
                    return parseInt(this.getAttribute("max-hits"), 10) || 20
                }

                function _get_searchUrl() {
                    var t;
                    return new URL(null !== (t = this.getAttribute("search-path")) && void 0 !== t ? t : "/search", document.location.href)
                }

                function _get_updateWindowHistory() {
                    return "true" === this.getAttribute("update-window-history")
                }

                function _get_featureKeyword() {
                    return this.getAttribute("feature-keyword")
                }

                function _cancelSearch2() {
                    var t;
                    null === (t = _classPrivateFieldLooseBase(this, B)[B]) || void 0 === t || t.abort()
                }

                function _doSearch2(t) {
                    return _doSearch3.apply(this, arguments)
                }

                function _doSearch3() {
                    return (_doSearch3 = _asyncToGenerator(_().mark((function _callee(t) {
                        var d, h, y, x, C, E = this;
                        return _().wrap((function _callee$(_) {
                            for (;;) switch (_.prev = _.next) {
                                case 0:
                                    return _classPrivateFieldLooseBase(this, j)[j](t), _classPrivateFieldLooseBase(this, I)[I](), _classPrivateFieldLooseBase(this, B)[B] = new AbortController, d = _classPrivateFieldLooseBase(this, B)[B].signal, setTimeout((function() {
                                        _classPrivateFieldLooseBase(E, I)[I]()
                                    }), this.SEARCH_TIMEOUT_MS), h = _classPrivateFieldLooseBase(this, k)[k], y = new URLSearchParams({
                                        q: t
                                    }), _classPrivateFieldLooseBase(this, A)[A] && y.append("feature", _classPrivateFieldLooseBase(this, A)[A]), h.search = y, x = [], _.prev = 10, _.next = 13, window.fetch(h, {
                                        headers: {
                                            Accept: "application/json",
                                            "Content-Type": "application/json"
                                        },
                                        signal: d
                                    });
                                case 13:
                                    return C = _.sent, _.next = 16, C.json();
                                case 16:
                                    x = _.sent, _.next = 26;
                                    break;
                                case 19:
                                    if (_.prev = 19, _.t0 = _.catch(10), "AbortError" === _.t0.name) {
                                        _.next = 25;
                                        break
                                    }
                                    console.log("Error fetching search results: ".concat(_.t0, " for query ").concat(t)), _.next = 26;
                                    break;
                                case 25:
                                    return _.abrupt("return");
                                case 26:
                                    _classPrivateFieldLooseBase(this, H)[H](x, t), _classPrivateFieldLooseBase(this, $)[$]();
                                case 28:
                                case "end":
                                    return _.stop()
                            }
                        }), _callee, this, [
                            [10, 19]
                        ])
                    })))).apply(this, arguments)
                }

                function _replaceHistoryState2(t) {
                    if (_classPrivateFieldLooseBase(this, z)[z]) {
                        var d = new URL(window.location.href);
                        t ? d.searchParams.set("q", t) : d.searchParams.delete("q"), window.history.replaceState(window.history.state, document.title, d.toString())
                    }
                }

                function _showHits2(t, d) {
                    var h, y, _;
                    if (null === (h = this.virtualAgentContainer) || void 0 === h || h.dispatchEvent(new window.CustomEvent("inferflow", {
                            detail: d
                        })), null === (y = _classPrivateFieldLooseBase(this, B)[B]) || void 0 === y || null === (_ = y.signal) || void 0 === _ || !_.aborted) {
                        var x, C = search_field_createForOfIteratorHelper(this.hits);
                        try {
                            for (C.s(); !(x = C.n()).done;) {
                                x.value.parentElement.remove()
                            }
                        } catch (I) {
                            C.e(I)
                        } finally {
                            C.f()
                        }
                        0 === t.length && t.push({
                            icon: "alert",
                            title: "No results found."
                        });
                        var E, k = search_field_createForOfIteratorHelper(t.slice(0, _classPrivateFieldLooseBase(this, O)[O]));
                        try {
                            for (k.s(); !(E = k.n()).done;) {
                                var z = E.value,
                                    A = this.hitTemplate.content.cloneNode(!0);
                                this.hitsList.append(A), this.hits.slice(-1)[0].load(z, d)
                            }
                        } catch (I) {
                            k.e(I)
                        } finally {
                            k.f()
                        }
                        this.defaultContentContainer && (this.defaultContentContainer.hidden = !0), this.hitsContainer.hidden = !1
                    }
                }

                function _filterAPISearchResults2() {
                    if (this.settings) {
                        var t = _classPrivateFieldLooseBase(this, O)[O] / 2;
                        _classPrivateFieldLooseBase(this, te)[te]() >= t ? (_classPrivateFieldLooseBase(this, G)[G](), this.settings.filterAPICheckbox.disabled = !1) : this.settings.filterAPICheckbox.disabled = !0
                    }
                }

                function _toggleAPIFilter2() {
                    var t, d = search_field_createForOfIteratorHelper(_classPrivateFieldLooseBase(this, ee)[ee]());
                    try {
                        for (d.s(); !(t = d.n()).done;) {
                            t.value.hidden = this.settings.filterAPICheckbox.checked
                        }
                    } catch (h) {
                        d.e(h)
                    } finally {
                        d.f()
                    }
                }

                function _allAPISearchResults2() {
                    return this.hits.filter((function(t) {
                        var d = t.getAttribute("topics") || t.getAttribute("category");
                        return d && d.match(/API/gi)
                    }))
                }

                function _hitsCountWithoutAPI2() {
                    return this.hits.length - _classPrivateFieldLooseBase(this, ee)[ee]().length
                }(0, x.controller)((C = _classPrivateFieldLooseKey("initialQuery"), E = _classPrivateFieldLooseKey("maxQueryLength"), O = _classPrivateFieldLooseKey("maxHits"), k = _classPrivateFieldLooseKey("searchUrl"), z = _classPrivateFieldLooseKey("updateWindowHistory"), A = _classPrivateFieldLooseKey("featureKeyword"), B = _classPrivateFieldLooseKey("searchController"), I = _classPrivateFieldLooseKey("cancelSearch"), q = _classPrivateFieldLooseKey("doSearch"), D = _classPrivateFieldLooseKey("debouncedSearch"), j = _classPrivateFieldLooseKey("replaceHistoryState"), H = _classPrivateFieldLooseKey("showHits"), $ = _classPrivateFieldLooseKey("filterAPISearchResults"), G = _classPrivateFieldLooseKey("toggleAPIFilter"), ee = _classPrivateFieldLooseKey("allAPISearchResults"), te = _classPrivateFieldLooseKey("hitsCountWithoutAPI"), function(t) {
                    ! function search_field_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && search_field_setPrototypeOf(t, d)
                    }(SearchFieldElement, window.HTMLElement);
                    var d = search_field_createSuper(SearchFieldElement);

                    function SearchFieldElement() {
                        var t;
                        search_field_classCallCheck(this, SearchFieldElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return t = d.call.apply(d, [this].concat(y)), Object.defineProperty(search_field_assertThisInitialized(t), te, {
                            value: _hitsCountWithoutAPI2
                        }), Object.defineProperty(search_field_assertThisInitialized(t), ee, {
                            value: _allAPISearchResults2
                        }), Object.defineProperty(search_field_assertThisInitialized(t), G, {
                            value: _toggleAPIFilter2
                        }), Object.defineProperty(search_field_assertThisInitialized(t), $, {
                            value: _filterAPISearchResults2
                        }), Object.defineProperty(search_field_assertThisInitialized(t), H, {
                            value: _showHits2
                        }), Object.defineProperty(search_field_assertThisInitialized(t), j, {
                            value: _replaceHistoryState2
                        }), Object.defineProperty(search_field_assertThisInitialized(t), q, {
                            value: _doSearch2
                        }), Object.defineProperty(search_field_assertThisInitialized(t), I, {
                            value: _cancelSearch2
                        }), Object.defineProperty(search_field_assertThisInitialized(t), A, {
                            get: _get_featureKeyword,
                            set: void 0
                        }), Object.defineProperty(search_field_assertThisInitialized(t), z, {
                            get: _get_updateWindowHistory,
                            set: void 0
                        }), Object.defineProperty(search_field_assertThisInitialized(t), k, {
                            get: _get_searchUrl,
                            set: void 0
                        }), Object.defineProperty(search_field_assertThisInitialized(t), O, {
                            get: _get_maxHits,
                            set: void 0
                        }), Object.defineProperty(search_field_assertThisInitialized(t), E, {
                            get: _get_maxQueryLength,
                            set: void 0
                        }), Object.defineProperty(search_field_assertThisInitialized(t), C, {
                            get: _get_initialQuery,
                            set: void 0
                        }), t.SEARCH_DEBOUNCE_MS = 250, t.SEARCH_TIMEOUT_MS = 5e3, Object.defineProperty(search_field_assertThisInitialized(t), B, {
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(search_field_assertThisInitialized(t), D, {
                            writable: !0,
                            value: debounce(_classPrivateFieldLooseBase(search_field_assertThisInitialized(t), q)[q], t.SEARCH_DEBOUNCE_MS)
                        }), t
                    }
                    return function search_field_createClass(t, d, h) {
                        return d && search_field_defineProperties(t.prototype, d), h && search_field_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(SearchFieldElement, [{
                        key: "defaultContentContainer",
                        get: function get() {
                            return (0, x.findTarget)(this, "defaultContentContainer")
                        }
                    }, {
                        key: "hitsContainer",
                        get: function get() {
                            return (0, x.findTarget)(this, "hitsContainer")
                        }
                    }, {
                        key: "hitsList",
                        get: function get() {
                            return (0, x.findTarget)(this, "hitsList") || this.hitsContainer
                        }
                    }, {
                        key: "hitTemplate",
                        get: function get() {
                            return (0, x.findTarget)(this, "hitTemplate")
                        }
                    }, {
                        key: "hits",
                        get: function get() {
                            return (0, x.findTargets)(this, "hits")
                        }
                    }, {
                        key: "input",
                        get: function get() {
                            return (0, x.findTarget)(this, "input")
                        }
                    }, {
                        key: "settings",
                        get: function get() {
                            return (0, x.findTarget)(this, "settings")
                        }
                    }, {
                        key: "virtualAgentContainer",
                        get: function get() {
                            return (0, x.findTarget)(this, "virtual-agent-container")
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            _classPrivateFieldLooseBase(this, C)[C] && (this.input.setSelectionRange(this.input.value.length, this.input.value.length), _classPrivateFieldLooseBase(this, q)[q](_classPrivateFieldLooseBase(this, C)[C]))
                        }
                    }, {
                        key: "search",
                        value: function search(t) {
                            var d;
                            if ("Escape" === t.key && "false" !== this.input.dataset.searchClearOnEsc && (this.input.value = ""), "" === this.input.value) return _classPrivateFieldLooseBase(this, I)[I](), _classPrivateFieldLooseBase(this, j)[j](), null === (d = this.virtualAgentContainer) || void 0 === d || d.dispatchEvent(new window.CustomEvent("inferflow", {
                                detail: ""
                            })), this.hitsContainer.hidden = !0, void(this.defaultContentContainer && (this.defaultContentContainer.hidden = !1));
                            var h = _toConsumableArray(this.input.value).slice(0, _classPrivateFieldLooseBase(this, E)[E]).join("");
                            h.length < 3 || _classPrivateFieldLooseBase(this, D)[D](h)
                        }
                    }, {
                        key: "preventSubmit",
                        value: function preventSubmit(t) {
                            t.preventDefault()
                        }
                    }, {
                        key: "saveAPIFilterSetting",
                        value: function saveAPIFilterSetting() {
                            this.settings.saveAPISetting(), _classPrivateFieldLooseBase(this, G)[G]()
                        }
                    }]), SearchFieldElement
                }()))
            },
            2462: () => {
                document.addEventListener("DOMContentLoaded", (function(t) {
                    var d = document.getElementById("javascript_enabled");
                    d && (d.value = "true")
                }))
            },
            3938: (t, d, h) => {
                "use strict";

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return function _assertThisInitialized(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function _wrapNativeSuper(t) {
                    var d = "function" == typeof Map ? new Map : void 0;
                    return _wrapNativeSuper = function _wrapNativeSuper(t) {
                        if (null === t || ! function _isNativeFunction(t) {
                                return -1 !== Function.toString.call(t).indexOf("[native code]")
                            }(t)) return t;
                        if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== d) {
                            if (d.has(t)) return d.get(t);
                            d.set(t, Wrapper)
                        }

                        function Wrapper() {
                            return _construct(t, arguments, _getPrototypeOf(this).constructor)
                        }
                        return Wrapper.prototype = Object.create(t.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), _setPrototypeOf(Wrapper, t)
                    }, _wrapNativeSuper(t)
                }

                function _construct(t, d, h) {
                    return _construct = _isNativeReflectConstruct() ? Reflect.construct : function _construct(t, d, h) {
                        var y = [null];
                        y.push.apply(y, d);
                        var _ = new(Function.bind.apply(t, y));
                        return h && _setPrototypeOf(_, h.prototype), _
                    }, _construct.apply(null, arguments)
                }

                function _isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function fetchPoll(t, d) {
                    return new Promise((function(h, _) {
                        ! function poll(x) {
                            window.fetch(t, d).then((function done(t) {
                                switch (t.status) {
                                    case 200:
                                        h(t);
                                        break;
                                    case 202:
                                        setTimeout((function() {
                                            return poll(1.5 * x)
                                        }), x);
                                        break;
                                    default:
                                        _(new y(t))
                                }
                            }), _).catch((function(t) {
                                console.error(t)
                            }))
                        }(1e3)
                    }))
                }
                h.r(d);
                var y = function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(ResponseError, t);
                    var d = function _createSuper(t) {
                        var d = _isNativeReflectConstruct();
                        return function _createSuperInternal() {
                            var h, y = _getPrototypeOf(t);
                            if (d) {
                                var _ = _getPrototypeOf(this).constructor;
                                h = Reflect.construct(y, arguments, _)
                            } else h = y.apply(this, arguments);
                            return _possibleConstructorReturn(this, h)
                        }
                    }(ResponseError);

                    function ResponseError(t) {
                        var h;
                        return function _classCallCheck(t, d) {
                            if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                        }(this, ResponseError), (h = d.call(this)).response = t, h.framesToPop = 1, h
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(ResponseError)
                }(_wrapNativeSuper(Error));
                document.addEventListener("DOMContentLoaded", (function() {
                    var t = document.getElementById("js-github-user-uncached");
                    t && setTimeout((function() {
                        t.firstElementChild.hidden = !1, setTimeout((function() {
                            t.firstElementChild.hidden = !0
                        }), 3e3), fetchPoll("/_user/load", {
                            headers: {
                                "X-Requested-With": "XMLHttpRequest"
                            }
                        }).then((function() {
                            t.firstElementChild.hidden = !0, document.dispatchEvent(new window.Event("githubuserloaded"))
                        }))
                    }), 0)
                })), document.addEventListener("githubuserloaded", (function() {
                    var t = document.getElementById("js-my-tickets-button");
                    t && t.hidden && fetchPoll("/_user/ticket_visibility_enabled", {
                        headers: {
                            "X-Requested-With": "XMLHttpRequest"
                        }
                    }).then((function() {
                        t.hidden = !1
                    })).catch((function(t) {
                        if (!t.response || 204 !== t.response.status) throw t
                    }))
                })), document.addEventListener("githubuserloaded", (function() {
                    var t = document.getElementById("js-premium-button");
                    t && t.hidden && fetchPoll("/_user/premium_content_enabled", {
                        headers: {
                            "X-Requested-With": "XMLHttpRequest"
                        }
                    }).then((function() {
                        t.hidden = !1, document.dispatchEvent(new window.Event("premiumbuttonloaded"))
                    })).catch((function(t) {
                        if (!t.response || 204 !== t.response.status) throw t
                    }))
                }))
            },
            881: (t, d, h) => {
                "use strict";
                h.r(d);
                var y = h(8136),
                    _ = {
                        logger: self.console,
                        WebSocket: self.WebSocket
                    },
                    x = {
                        log(...t) {
                            this.enabled && (t.push(Date.now()), _.logger.log("[ActionCable]", ...t))
                        }
                    };
                const now = () => (new Date).getTime(),
                    secondsSince = t => (now() - t) / 1e3;
                class ConnectionMonitor {
                    constructor(t) {
                        this.visibilityDidChange = this.visibilityDidChange.bind(this), this.connection = t, this.reconnectAttempts = 0
                    }
                    start() {
                        this.isRunning() || (this.startedAt = now(), delete this.stoppedAt, this.startPolling(), addEventListener("visibilitychange", this.visibilityDidChange), x.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`))
                    }
                    stop() {
                        this.isRunning() && (this.stoppedAt = now(), this.stopPolling(), removeEventListener("visibilitychange", this.visibilityDidChange), x.log("ConnectionMonitor stopped"))
                    }
                    isRunning() {
                        return this.startedAt && !this.stoppedAt
                    }
                    recordPing() {
                        this.pingedAt = now()
                    }
                    recordConnect() {
                        this.reconnectAttempts = 0, this.recordPing(), delete this.disconnectedAt, x.log("ConnectionMonitor recorded connect")
                    }
                    recordDisconnect() {
                        this.disconnectedAt = now(), x.log("ConnectionMonitor recorded disconnect")
                    }
                    startPolling() {
                        this.stopPolling(), this.poll()
                    }
                    stopPolling() {
                        clearTimeout(this.pollTimeout)
                    }
                    poll() {
                        this.pollTimeout = setTimeout((() => {
                            this.reconnectIfStale(), this.poll()
                        }), this.getPollInterval())
                    }
                    getPollInterval() {
                        const {
                            staleThreshold: t,
                            reconnectionBackoffRate: d
                        } = this.constructor;
                        return 1e3 * t * Math.pow(1 + d, Math.min(this.reconnectAttempts, 10)) * (1 + (0 === this.reconnectAttempts ? 1 : d) * Math.random())
                    }
                    reconnectIfStale() {
                        this.connectionIsStale() && (x.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`), this.reconnectAttempts++, this.disconnectedRecently() ? x.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`) : (x.log("ConnectionMonitor reopening"), this.connection.reopen()))
                    }
                    get refreshedAt() {
                        return this.pingedAt ? this.pingedAt : this.startedAt
                    }
                    connectionIsStale() {
                        return secondsSince(this.refreshedAt) > this.constructor.staleThreshold
                    }
                    disconnectedRecently() {
                        return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold
                    }
                    visibilityDidChange() {
                        "visible" === document.visibilityState && setTimeout((() => {
                            !this.connectionIsStale() && this.connection.isOpen() || (x.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`), this.connection.reopen())
                        }), 200)
                    }
                }
                ConnectionMonitor.staleThreshold = 6, ConnectionMonitor.reconnectionBackoffRate = .15;
                var C = {
                    message_types: {
                        welcome: "welcome",
                        disconnect: "disconnect",
                        ping: "ping",
                        confirmation: "confirm_subscription",
                        rejection: "reject_subscription"
                    },
                    disconnect_reasons: {
                        unauthorized: "unauthorized",
                        invalid_request: "invalid_request",
                        server_restart: "server_restart"
                    },
                    default_mount_path: "/cable",
                    protocols: ["actioncable-v1-json", "actioncable-unsupported"]
                };
                const {
                    message_types: E,
                    protocols: O
                } = C, k = O.slice(0, O.length - 1), z = [].indexOf;
                class Connection {
                    constructor(t) {
                        this.open = this.open.bind(this), this.consumer = t, this.subscriptions = this.consumer.subscriptions, this.monitor = new ConnectionMonitor(this), this.disconnected = !0
                    }
                    send(t) {
                        return !!this.isOpen() && (this.webSocket.send(JSON.stringify(t)), !0)
                    }
                    open() {
                        return this.isActive() ? (x.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`), !1) : (x.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${O}`), this.webSocket && this.uninstallEventHandlers(), this.webSocket = new _.WebSocket(this.consumer.url, O), this.installEventHandlers(), this.monitor.start(), !0)
                    }
                    close({
                        allowReconnect: t
                    } = {
                        allowReconnect: !0
                    }) {
                        if (t || this.monitor.stop(), this.isOpen()) return this.webSocket.close()
                    }
                    reopen() {
                        if (x.log(`Reopening WebSocket, current state is ${this.getState()}`), !this.isActive()) return this.open();
                        try {
                            return this.close()
                        } catch (t) {
                            x.log("Failed to reopen WebSocket", t)
                        } finally {
                            x.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`), setTimeout(this.open, this.constructor.reopenDelay)
                        }
                    }
                    getProtocol() {
                        if (this.webSocket) return this.webSocket.protocol
                    }
                    isOpen() {
                        return this.isState("open")
                    }
                    isActive() {
                        return this.isState("open", "connecting")
                    }
                    isProtocolSupported() {
                        return z.call(k, this.getProtocol()) >= 0
                    }
                    isState(...t) {
                        return z.call(t, this.getState()) >= 0
                    }
                    getState() {
                        if (this.webSocket)
                            for (let t in _.WebSocket)
                                if (_.WebSocket[t] === this.webSocket.readyState) return t.toLowerCase();
                        return null
                    }
                    installEventHandlers() {
                        for (let t in this.events) {
                            const d = this.events[t].bind(this);
                            this.webSocket[`on${t}`] = d
                        }
                    }
                    uninstallEventHandlers() {
                        for (let t in this.events) this.webSocket[`on${t}`] = function() {}
                    }
                }
                Connection.reopenDelay = 500, Connection.prototype.events = {
                    message(t) {
                        if (!this.isProtocolSupported()) return;
                        const {
                            identifier: d,
                            message: h,
                            reason: y,
                            reconnect: _,
                            type: C
                        } = JSON.parse(t.data);
                        switch (C) {
                            case E.welcome:
                                return this.monitor.recordConnect(), this.subscriptions.reload();
                            case E.disconnect:
                                return x.log(`Disconnecting. Reason: ${y}`), this.close({
                                    allowReconnect: _
                                });
                            case E.ping:
                                return this.monitor.recordPing();
                            case E.confirmation:
                                return this.subscriptions.confirmSubscription(d), this.subscriptions.notify(d, "connected");
                            case E.rejection:
                                return this.subscriptions.reject(d);
                            default:
                                return this.subscriptions.notify(d, "received", h)
                        }
                    },
                    open() {
                        if (x.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`), this.disconnected = !1, !this.isProtocolSupported()) return x.log("Protocol is unsupported. Stopping monitor and disconnecting."), this.close({
                            allowReconnect: !1
                        })
                    },
                    close(t) {
                        if (x.log("WebSocket onclose event"), !this.disconnected) return this.disconnected = !0, this.monitor.recordDisconnect(), this.subscriptions.notifyAll("disconnected", {
                            willAttemptReconnect: this.monitor.isRunning()
                        })
                    },
                    error() {
                        x.log("WebSocket onerror event")
                    }
                };
                class Subscription {
                    constructor(t, d = {}, h) {
                        this.consumer = t, this.identifier = JSON.stringify(d),
                            function(t, d) {
                                if (null != d)
                                    for (let h in d) {
                                        const y = d[h];
                                        t[h] = y
                                    }
                            }(this, h)
                    }
                    perform(t, d = {}) {
                        return d.action = t, this.send(d)
                    }
                    send(t) {
                        return this.consumer.send({
                            command: "message",
                            identifier: this.identifier,
                            data: JSON.stringify(t)
                        })
                    }
                    unsubscribe() {
                        return this.consumer.subscriptions.remove(this)
                    }
                }
                class SubscriptionGuarantor {
                    constructor(t) {
                        this.subscriptions = t, this.pendingSubscriptions = []
                    }
                    guarantee(t) {
                        -1 == this.pendingSubscriptions.indexOf(t) ? (x.log(`SubscriptionGuarantor guaranteeing ${t.identifier}`), this.pendingSubscriptions.push(t)) : x.log(`SubscriptionGuarantor already guaranteeing ${t.identifier}`), this.startGuaranteeing()
                    }
                    forget(t) {
                        x.log(`SubscriptionGuarantor forgetting ${t.identifier}`), this.pendingSubscriptions = this.pendingSubscriptions.filter((d => d !== t))
                    }
                    startGuaranteeing() {
                        this.stopGuaranteeing(), this.retrySubscribing()
                    }
                    stopGuaranteeing() {
                        clearTimeout(this.retryTimeout)
                    }
                    retrySubscribing() {
                        this.retryTimeout = setTimeout((() => {
                            this.subscriptions && "function" == typeof this.subscriptions.subscribe && this.pendingSubscriptions.map((t => {
                                x.log(`SubscriptionGuarantor resubscribing ${t.identifier}`), this.subscriptions.subscribe(t)
                            }))
                        }), 500)
                    }
                }
                class Subscriptions {
                    constructor(t) {
                        this.consumer = t, this.guarantor = new SubscriptionGuarantor(this), this.subscriptions = []
                    }
                    create(t, d) {
                        const h = "object" == typeof t ? t : {
                                channel: t
                            },
                            y = new Subscription(this.consumer, h, d);
                        return this.add(y)
                    }
                    add(t) {
                        return this.subscriptions.push(t), this.consumer.ensureActiveConnection(), this.notify(t, "initialized"), this.subscribe(t), t
                    }
                    remove(t) {
                        return this.forget(t), this.findAll(t.identifier).length || this.sendCommand(t, "unsubscribe"), t
                    }
                    reject(t) {
                        return this.findAll(t).map((t => (this.forget(t), this.notify(t, "rejected"), t)))
                    }
                    forget(t) {
                        return this.guarantor.forget(t), this.subscriptions = this.subscriptions.filter((d => d !== t)), t
                    }
                    findAll(t) {
                        return this.subscriptions.filter((d => d.identifier === t))
                    }
                    reload() {
                        return this.subscriptions.map((t => this.subscribe(t)))
                    }
                    notifyAll(t, ...d) {
                        return this.subscriptions.map((h => this.notify(h, t, ...d)))
                    }
                    notify(t, d, ...h) {
                        let y;
                        return y = "string" == typeof t ? this.findAll(t) : [t], y.map((t => "function" == typeof t[d] ? t[d](...h) : void 0))
                    }
                    subscribe(t) {
                        this.sendCommand(t, "subscribe") && this.guarantor.guarantee(t)
                    }
                    confirmSubscription(t) {
                        x.log(`Subscription confirmed ${t}`), this.findAll(t).map((t => this.guarantor.forget(t)))
                    }
                    sendCommand(t, d) {
                        const {
                            identifier: h
                        } = t;
                        return this.consumer.send({
                            command: d,
                            identifier: h
                        })
                    }
                }
                class Consumer {
                    constructor(t) {
                        this._url = t, this.subscriptions = new Subscriptions(this), this.connection = new Connection(this)
                    }
                    get url() {
                        return function createWebSocketURL(t) {
                            "function" == typeof t && (t = t());
                            if (t && !/^wss?:/i.test(t)) {
                                const d = document.createElement("a");
                                return d.href = t, d.href = d.href, d.protocol = d.protocol.replace("http", "ws"), d.href
                            }
                            return t
                        }(this._url)
                    }
                    send(t) {
                        return this.connection.send(t)
                    }
                    connect() {
                        return this.connection.open()
                    }
                    disconnect() {
                        return this.connection.close({
                            allowReconnect: !1
                        })
                    }
                    ensureActiveConnection() {
                        if (!this.connection.isActive()) return this.connection.open()
                    }
                }
                const A = function createConsumer(t = function getConfig(t) {
                    const d = document.head.querySelector(`meta[name='action-cable-${t}']`);
                    if (d) return d.getAttribute("content")
                }("url") || C.default_mount_path) {
                    return new Consumer(t)
                }("/_ws");
                var B;

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }

                function _classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }
                var I = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + I++ + "_" + t
                }

                function _get_requestID() {
                    return this.getAttribute("request-id")
                }(0, y.controller)((B = _classPrivateFieldLooseKey("requestID"), function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(TicketCreatedElement, window.HTMLElement);
                    var d = _createSuper(TicketCreatedElement);

                    function TicketCreatedElement() {
                        var t;
                        _classCallCheck(this, TicketCreatedElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return t = d.call.apply(d, [this].concat(y)), Object.defineProperty(_assertThisInitialized(t), B, {
                            get: _get_requestID,
                            set: void 0
                        }), t.subscription = void 0, t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(TicketCreatedElement, [{
                        key: "ticketLink",
                        get: function get() {
                            return (0, y.findTarget)(this, "viewTicketLink")
                        }
                    }, {
                        key: "tooltip",
                        get: function get() {
                            return (0, y.findTarget)(this, "tooltip")
                        }
                    }, {
                        key: "enableTicketLink",
                        value: function enableTicketLink(t, d) {
                            this.ticketLink.dataset.ticketLinked || (this.ticketLink.href = t, this.ticketLink.textContent = this.ticketLink.dataset.viewMessage, this.ticketLink.setAttribute("aria-disabled", "false"), this.ticketLink.dataset.ticketLinked = !0, this.ticketLink.dataset.gaClick = "Contact, ".concat(d), this.tooltip.classList.remove("tooltipped"), this.tooltip.removeAttribute("aria-label"))
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            var t = this,
                                d = {
                                    channel: "TicketCreatedChannel",
                                    request_id: _classPrivateFieldLooseBase(this, B)[B]
                                };
                            this.style.display = "inline-block", setTimeout((function() {
                                t.enableTicketLink("/tickets", "View tickets")
                            }), 12e3), this.subscription = A.subscriptions.create(d, {
                                self: this,
                                received: function received(t) {
                                    Number.isInteger(t) && this.self.enableTicketLink("/ticket/".concat(t), "View ticket")
                                }
                            })
                        }
                    }]), TicketCreatedElement
                }()))
            },
            4838: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _, x, C, E, O = h(7757),
                    k = h.n(O),
                    a = function(t, d) {
                        return {
                            name: t,
                            value: void 0 === d ? -1 : 0,
                            delta: 0,
                            entries: [],
                            id: "v1-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12)
                        }
                    },
                    r = function(t, d) {
                        try {
                            if (PerformanceObserver.supportedEntryTypes.includes(t)) {
                                var h = new PerformanceObserver((function(t) {
                                    return t.getEntries().map(d)
                                }));
                                return h.observe({
                                    type: t,
                                    buffered: !0
                                }), h
                            }
                        } catch (t) {}
                    },
                    z = !1,
                    u = function(t, d) {
                        z || "undefined" != typeof InstallTrigger || (addEventListener("beforeunload", (function() {})), z = !0), addEventListener("visibilitychange", (function n(h) {
                            "hidden" === document.visibilityState && (t(h), d && removeEventListener("visibilitychange", n, !0))
                        }), !0)
                    },
                    c = function(t) {
                        addEventListener("pageshow", (function(d) {
                            d.persisted && t(d)
                        }), !0)
                    },
                    A = new WeakSet,
                    f = function(t, d, h) {
                        var y;
                        return function() {
                            d.value >= 0 && (h || A.has(d) || "hidden" === document.visibilityState) && (d.delta = d.value - (y || 0), (d.delta || void 0 === y) && (y = d.value, t(d)))
                        }
                    },
                    B = -1,
                    p = function() {
                        return "hidden" === document.visibilityState ? 0 : 1 / 0
                    },
                    v = function() {
                        u((function(t) {
                            var d = t.timeStamp;
                            B = d
                        }), !0)
                    },
                    l = function() {
                        return B < 0 && (B = p(), v(), c((function() {
                            setTimeout((function() {
                                B = p(), v()
                            }), 0)
                        }))), {
                            get timeStamp() {
                                return B
                            }
                        }
                    },
                    I = {
                        passive: !0,
                        capture: !0
                    },
                    q = new Date,
                    g = function(t, d) {
                        y || (y = d, _ = t, x = new Date, T(removeEventListener), w())
                    },
                    w = function() {
                        if (_ >= 0 && _ < x - q) {
                            var t = {
                                entryType: "first-input",
                                name: y.type,
                                target: y.target,
                                cancelable: y.cancelable,
                                startTime: y.timeStamp,
                                processingStart: y.timeStamp + _
                            };
                            C.map((function(d) {
                                d(t)
                            })), C = []
                        }
                    },
                    L = function(t) {
                        if (t.cancelable) {
                            var d = (t.timeStamp > 1e12 ? new Date : performance.now()) - t.timeStamp;
                            "pointerdown" == t.type ? function(t, d) {
                                var n = function() {
                                        g(t, d), a()
                                    },
                                    i = function() {
                                        a()
                                    },
                                    a = function() {
                                        removeEventListener("pointerup", n, I), removeEventListener("pointercancel", i, I)
                                    };
                                addEventListener("pointerup", n, I), addEventListener("pointercancel", i, I)
                            }(d, t) : g(d, t)
                        }
                    },
                    T = function(t) {
                        ["mousedown", "keydown", "touchstart", "pointerdown"].map((function(d) {
                            return t(d, L, I)
                        }))
                    };

                function asyncGeneratorStep(t, d, h, y, _, x, C) {
                    try {
                        var E = t[x](C),
                            O = E.value
                    } catch (k) {
                        return void h(k)
                    }
                    E.done ? d(O) : Promise.resolve(O).then(y, _)
                }

                function _asyncToGenerator(t) {
                    return function() {
                        var d = this,
                            h = arguments;
                        return new Promise((function(y, _) {
                            var x = t.apply(d, h);

                            function _next(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "next", t)
                            }

                            function _throw(t) {
                                asyncGeneratorStep(x, y, _, _next, _throw, "throw", t)
                            }
                            _next(void 0)
                        }))
                    }
                }
                var D = null === (E = document.querySelector('meta[name="csrf-token"]')) || void 0 === E ? void 0 : E.content,
                    j = null,
                    H = [];

                function _scheduleStats() {
                    return (_scheduleStats = _asyncToGenerator(k().mark((function _callee() {
                        return k().wrap((function _callee$(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, $;
                                case 2:
                                    null == j && (j = window.requestIdleCallback ? window.requestIdleCallback(sendStats) : setTimeout(sendStats, 0));
                                case 3:
                                case "end":
                                    return t.stop()
                            }
                        }), _callee)
                    })))).apply(this, arguments)
                }

                function sendStats() {
                    navigator.sendBeacon && navigator.sendBeacon("/_stats", JSON.stringify({
                        csrf: D,
                        stats: H
                    })), j = null, H = []
                }

                function collectStats(t) {
                    var d, h;
                    H.push({
                            name: t.name,
                            value: t.value,
                            url: window.location.href,
                            timestamp: (new Date).getTime(),
                            signedIn: !(null === (d = document.head) || void 0 === d || null === (h = d.querySelector('meta[name="user-login"]')) || void 0 === h || !h.content)
                        }),
                        function scheduleStats() {
                            return _scheduleStats.apply(this, arguments)
                        }()
                }
                var $ = "complete" === document.readyState ? Promise.resolve() : new Promise((function(t) {
                    window.addEventListener("load", t)
                }));
                ! function(t, d) {
                    var h, y = a("CLS", 0),
                        o = function(t) {
                            t.hadRecentInput || (y.value += t.value, y.entries.push(t), h())
                        },
                        _ = r("layout-shift", o);
                    _ && (h = f(t, y, d), u((function() {
                        _.takeRecords().map(o), h()
                    })), c((function() {
                        y = a("CLS", 0), h = f(t, y, d)
                    })))
                }(collectStats),
                function(t, d) {
                    var h, x = l(),
                        E = a("FID"),
                        v = function(t) {
                            t.startTime < x.timeStamp && (E.value = t.processingStart - t.startTime, E.entries.push(t), A.add(E), h())
                        },
                        O = r("first-input", v);
                    h = f(t, E, d), O && u((function() {
                        O.takeRecords().map(v), O.disconnect()
                    }), !0), O && c((function() {
                        var x;
                        E = a("FID"), h = f(t, E, d), C = [], _ = -1, y = null, T(addEventListener), x = v, C.push(x), w()
                    }))
                }(collectStats),
                function(t, d) {
                    var h, y = l(),
                        _ = a("LCP"),
                        m = function(t) {
                            var d = t.startTime;
                            d < y.timeStamp && (_.value = d, _.entries.push(t)), h()
                        },
                        x = r("largest-contentful-paint", m);
                    if (x) {
                        h = f(t, _, d);
                        var p = function() {
                            A.has(_) || (x.takeRecords().map(m), x.disconnect(), A.add(_), h())
                        };
                        ["keydown", "click"].map((function(t) {
                            addEventListener(t, p, {
                                once: !0,
                                capture: !0
                            })
                        })), u(p, !0), c((function(y) {
                            _ = a("LCP"), h = f(t, _, d), requestAnimationFrame((function() {
                                requestAnimationFrame((function() {
                                    _.value = performance.now() - y.timeStamp, A.add(_), h()
                                }))
                            }))
                        }))
                    }
                }(collectStats),
                function(t, d) {
                    var h, y = l(),
                        _ = a("FCP"),
                        x = r("paint", (function(t) {
                            "first-contentful-paint" === t.name && (x && x.disconnect(), t.startTime < y.timeStamp && (_.value = t.startTime, _.entries.push(t), A.add(_), h()))
                        }));
                    x && (h = f(t, _, d), c((function(y) {
                        _ = a("FCP"), h = f(t, _, d), requestAnimationFrame((function() {
                            requestAnimationFrame((function() {
                                _.value = performance.now() - y.timeStamp, A.add(_), h()
                            }))
                        }))
                    })))
                }(collectStats),
                function(t) {
                    var d, h = a("TTFB");
                    d = function() {
                        try {
                            var d = performance.getEntriesByType("navigation")[0] || function() {
                                var t = performance.timing,
                                    d = {
                                        entryType: "navigation",
                                        startTime: 0
                                    };
                                for (var h in t) "navigationStart" !== h && "toJSON" !== h && (d[h] = Math.max(t[h] - t.navigationStart, 0));
                                return d
                            }();
                            h.value = h.delta = d.responseStart, h.entries = [d], t(h)
                        } catch (t) {}
                    }, "complete" === document.readyState ? setTimeout(d, 0) : addEventListener("pageshow", d)
                }(collectStats)
            },
            4742: (t, d, h) => {
                "use strict";

                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = function _unsupportedIterableToArray(t, d) {
                                if (!t) return;
                                if ("string" == typeof t) return _arrayLikeToArray(t, d);
                                var h = Object.prototype.toString.call(t).slice(8, -1);
                                "Object" === h && t.constructor && (h = t.constructor.name);
                                if ("Map" === h || "Set" === h) return Array.from(t);
                                if ("Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)) return _arrayLikeToArray(t, d)
                            }(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function setupToggles() {
                    document.addEventListener("change", (function(t) {
                        var d, h = _createForOfIteratorHelper(document.getElementsByClassName("js-toggler"));
                        try {
                            for (h.s(); !(d = h.n()).done;) {
                                var y = d.value,
                                    _ = y.dataset.toggleSelector;
                                if (_) {
                                    var x, C = y.dataset.toggleValues,
                                        E = C ? C.split(",") : [],
                                        O = _createForOfIteratorHelper(document.querySelectorAll(_));
                                    try {
                                        for (O.s(); !(x = O.n()).done;) {
                                            var k = x.value,
                                                z = k.dataset.toggleValueMatch,
                                                A = z ? z.split(",") : [];
                                            if (k.dataset.toggleClass) {
                                                var B = k.classList;
                                                A.includes(y.value) || E.includes(y.value) ? B.add(k.dataset.toggleClass) : B.remove(k.dataset.toggleClass)
                                            }
                                            k.dataset.toggleDisabled ? k.disabled = A.includes(y.value) || E.includes(y.value) : k.dataset.toggleEnabled && (k.disabled = !(A.includes(y.value) || E.includes(y.value))), k.dataset.toggleHidden ? k.hidden = A.includes(y.value) || E.includes(y.value) : k.dataset.toggleRevealed && (k.hidden = !(A.includes(y.value) || E.includes(y.value)))
                                        }
                                    } catch (I) {
                                        O.e(I)
                                    } finally {
                                        O.f()
                                    }
                                }
                            }
                        } catch (I) {
                            h.e(I)
                        } finally {
                            h.f()
                        }
                    }))
                }
                h.r(d), h.d(d, {
                    setupToggles: () => setupToggles
                }), document.addEventListener("DOMContentLoaded", (function(t) {
                    setupToggles()
                }))
            },
            2507: () => {
                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = function _unsupportedIterableToArray(t, d) {
                                if (!t) return;
                                if ("string" == typeof t) return _arrayLikeToArray(t, d);
                                var h = Object.prototype.toString.call(t).slice(8, -1);
                                "Object" === h && t.constructor && (h = t.constructor.name);
                                if ("Map" === h || "Set" === h) return Array.from(t);
                                if ("Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h)) return _arrayLikeToArray(t, d)
                            }(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }
                document.addEventListener("DOMContentLoaded", (function(t) {
                    var d, h = _createForOfIteratorHelper(document.getElementsByClassName("js-unhide"));
                    try {
                        for (h.s(); !(d = h.n()).done;) {
                            d.value.hidden = !1
                        }
                    } catch (y) {
                        h.e(y)
                    } finally {
                        h.f()
                    }
                })), document.addEventListener("DOMContentLoaded", (function(t) {
                    var d, h = _createForOfIteratorHelper(document.getElementsByClassName("js-hide"));
                    try {
                        for (h.s(); !(d = h.n()).done;) {
                            d.value.hidden = !0
                        }
                    } catch (y) {
                        h.e(y)
                    } finally {
                        h.f()
                    }
                })), document.addEventListener("DOMContentLoaded", (function(t) {
                    var d, h = _createForOfIteratorHelper(document.getElementsByClassName("js-unhide-by-class"));
                    try {
                        for (h.s(); !(d = h.n()).done;) {
                            d.value.classList.add("v-visible")
                        }
                    } catch (y) {
                        h.e(y)
                    } finally {
                        h.f()
                    }
                })), document.addEventListener("DOMContentLoaded", (function(t) {
                    var d, h = _createForOfIteratorHelper(document.getElementsByClassName("js-hide-by-class"));
                    try {
                        for (h.s(); !(d = h.n()).done;) {
                            d.value.classList.add("v-hidden")
                        }
                    } catch (y) {
                        h.e(y)
                    } finally {
                        h.f()
                    }
                }))
            },
            5382: (t, d, h) => {
                "use strict";
                h.r(d);
                var y, _ = h(6470),
                    x = h.n(_),
                    C = h(8136);
                h(3596);

                function _classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function _defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function _setPrototypeOf(t, d) {
                    return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, _setPrototypeOf(t, d)
                }

                function _createSuper(t) {
                    var d = function _isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = _getPrototypeOf(t);
                        if (d) {
                            var _ = _getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return _possibleConstructorReturn(this, h)
                    }
                }

                function _possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t)
                }

                function _assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, _getPrototypeOf(t)
                }
                var E = 0;

                function _classPrivateFieldLooseKey(t) {
                    return "__private_" + E++ + "_" + t
                }

                function _humanSize2(t) {
                    var d = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    if (0 === t) return "0 Bytes";
                    var h = 1e3,
                        y = d < 0 ? 0 : d,
                        _ = ["B", "KB", "MB", "GB", "TB"],
                        x = Math.floor(Math.log(t) / Math.log(h)),
                        C = parseFloat((t / Math.pow(h, x)).toFixed(y)) + " " + _[x];
                    return C
                }

                function insertText(t, d) {
                    const h = t.value.substring(0, t.selectionStart || 0),
                        y = t.value.substring(t.selectionEnd || 0),
                        _ = 0 === h.length || h.match(/\n$/) ? "" : "\n",
                        x = h + _ + d;
                    t.value = x + y, t.selectionStart = x.length, t.selectionEnd = t.selectionStart, t.dispatchEvent(new CustomEvent("change", {
                        bubbles: !0,
                        cancelable: !1
                    })), t.focus()
                }

                function onDrop$1(t) {
                    const d = t.dataTransfer;
                    if (!d) return;
                    if (function hasFile$1(t) {
                            return Array.from(t.types).indexOf("Files") >= 0
                        }(d)) return;
                    if (!hasLink(d)) return;
                    const h = extractLinks(d);
                    if (!h.some(isImageLink)) return;
                    t.stopPropagation(), t.preventDefault();
                    const y = t.currentTarget;
                    y instanceof HTMLTextAreaElement && insertText(y, h.map(linkify).join(""))
                }

                function onDragover$1(t) {
                    const d = t.dataTransfer;
                    d && (d.dropEffect = "link")
                }

                function onPaste$2(t) {
                    const d = t.clipboardData;
                    if (!d || !hasLink(d)) return;
                    const h = extractLinks(d);
                    if (!h.some(isImageLink)) return;
                    t.stopPropagation(), t.preventDefault();
                    const y = t.currentTarget;
                    y instanceof HTMLTextAreaElement && insertText(y, h.map(linkify).join(""))
                }

                function linkify(t) {
                    return isImageLink(t) ? `\n![](${t})\n` : t
                }

                function hasLink(t) {
                    return Array.from(t.types).indexOf("text/uri-list") >= 0
                }

                function extractLinks(t) {
                    return (t.getData("text/uri-list") || "").split("\r\n")
                }(0, C.controller)((y = _classPrivateFieldLooseKey("humanSize"), function(t) {
                    ! function _inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && _setPrototypeOf(t, d)
                    }(FileUploadElement, window.HTMLElement);
                    var d = _createSuper(FileUploadElement);

                    function FileUploadElement() {
                        var t;
                        _classCallCheck(this, FileUploadElement);
                        for (var h = arguments.length, _ = new Array(h), x = 0; x < h; x++) _[x] = arguments[x];
                        return t = d.call.apply(d, [this].concat(_)), Object.defineProperty(_assertThisInitialized(t), y, {
                            value: _humanSize2
                        }), t
                    }
                    return function _createClass(t, d, h) {
                        return d && _defineProperties(t.prototype, d), h && _defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(FileUploadElement, [{
                        key: "name",
                        get: function get() {
                            return (0, C.findTarget)(this, "name")
                        }
                    }, {
                        key: "size",
                        get: function get() {
                            return (0, C.findTarget)(this, "size")
                        }
                    }, {
                        key: "progressBar",
                        get: function get() {
                            return (0, C.findTarget)(this, "progressBar")
                        }
                    }, {
                        key: "progressBarContainer",
                        get: function get() {
                            return (0, C.findTarget)(this, "progressBarContainer")
                        }
                    }, {
                        key: "cancel",
                        get: function get() {
                            return (0, C.findTarget)(this, "cancel")
                        }
                    }, {
                        key: "show",
                        value: function show(t) {
                            this.progressBar.style.width = "0%", this.name.textContent = t.name, this.size.textContent = function _classPrivateFieldLooseBase(t, d) {
                                if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                                return t
                            }(this, y)[y](t.size)
                        }
                    }, {
                        key: "abort",
                        value: function abort() {
                            this.xhr.abort(), this.remove()
                        }
                    }, {
                        key: "showProgress",
                        value: function showProgress(t) {
                            this.progressBar.style.width = "".concat(t, "%"), 100 === t && this.progressBarContainer.classList.add("progress-bar-processing")
                        }
                    }, {
                        key: "remove",
                        value: function remove() {
                            this.parentNode.removeChild(this)
                        }
                    }]), FileUploadElement
                }()));
                const O = /\.(gif|png|jpe?g)$/i;

                function isImageLink(t) {
                    return O.test(t)
                }

                function onDrop(t) {
                    const d = t.dataTransfer;
                    if (!d) return;
                    if (function hasFile(t) {
                            return Array.from(t.types).indexOf("Files") >= 0
                        }(d)) return;
                    const h = generateText(d);
                    if (!h) return;
                    t.stopPropagation(), t.preventDefault();
                    const y = t.currentTarget;
                    y instanceof HTMLTextAreaElement && insertText(y, h)
                }

                function onDragover(t) {
                    const d = t.dataTransfer;
                    d && (d.dropEffect = "copy")
                }

                function onPaste$1(t) {
                    if (!t.clipboardData) return;
                    const d = generateText(t.clipboardData);
                    if (!d) return;
                    t.stopPropagation(), t.preventDefault();
                    const h = t.currentTarget;
                    h instanceof HTMLTextAreaElement && insertText(h, d)
                }

                function columnText(t) {
                    return (t.textContent || "").trim().replace(/\|/g, "\\|").replace(/\n/g, " ") || "Â "
                }

                function tableMarkdown(t) {
                    const d = Array.from(t.querySelectorAll("tr")),
                        h = d.shift();
                    if (!h) return "";
                    const y = function tableHeaders(t) {
                            return Array.from(t.querySelectorAll("td, th")).map(columnText)
                        }(h),
                        _ = y.map((() => "--"));
                    return `\n${`${y.join(" | ")}\n${_.join(" | ")}\n`}${d.map((t=>Array.from(t.querySelectorAll("td")).map(columnText).join(" | "))).join("\n")}\n\n`
                }

                function generateText(t) {
                    if (-1 === Array.from(t.types).indexOf("text/html")) return;
                    const d = t.getData("text/html");
                    if (!/<table/i.test(d)) return;
                    let h = (new DOMParser).parseFromString(d, "text/html").querySelector("table");
                    if (h = !h || h.closest("[data-paste-markdown-skip]") ? null : h, !h) return;
                    const y = tableMarkdown(h);
                    return d.replace(/<meta.*?>/, "").replace(/<table[.\S\s]*<\/table>/, `\n${y}`)
                }

                function onPaste(t) {
                    const d = t.clipboardData;
                    if (!d || ! function hasMarkdown(t) {
                            return Array.from(t.types).indexOf("text/x-gfm") >= 0
                        }(d)) return;
                    const h = t.currentTarget;
                    if (!(h instanceof HTMLTextAreaElement)) return;
                    const y = d.getData("text/x-gfm");
                    y && (t.stopPropagation(), t.preventDefault(), insertText(h, y))
                }
                const k = function subscribe(t) {
                    return function install$1(t) {
                            t.addEventListener("dragover", onDragover), t.addEventListener("drop", onDrop), t.addEventListener("paste", onPaste$1)
                        }(t),
                        function install$2(t) {
                            t.addEventListener("dragover", onDragover$1), t.addEventListener("drop", onDrop$1), t.addEventListener("paste", onPaste$2)
                        }(t),
                        function install(t) {
                            t.addEventListener("paste", onPaste)
                        }(t), {
                            unsubscribe: () => {
                                ! function uninstall$1(t) {
                                    t.removeEventListener("dragover", onDragover), t.removeEventListener("drop", onDrop), t.removeEventListener("paste", onPaste$1)
                                }(t),
                                function uninstall$2(t) {
                                    t.removeEventListener("dragover", onDragover$1), t.removeEventListener("drop", onDrop$1), t.removeEventListener("paste", onPaste$2)
                                }(t),
                                function uninstall(t) {
                                    t.removeEventListener("paste", onPaste)
                                }(t)
                            }
                        }
                };
                var z;

                function file_commenter_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function file_commenter_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function file_commenter_setPrototypeOf(t, d) {
                    return file_commenter_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, file_commenter_setPrototypeOf(t, d)
                }

                function file_commenter_createSuper(t) {
                    var d = function file_commenter_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = file_commenter_getPrototypeOf(t);
                        if (d) {
                            var _ = file_commenter_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return file_commenter_possibleConstructorReturn(this, h)
                    }
                }

                function file_commenter_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return file_commenter_assertThisInitialized(t)
                }

                function file_commenter_assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function file_commenter_getPrototypeOf(t) {
                    return file_commenter_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, file_commenter_getPrototypeOf(t)
                }

                function file_commenter_classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }
                var A, B, I = 0;

                function file_commenter_classPrivateFieldLooseKey(t) {
                    return "__private_" + I++ + "_" + t
                }

                function _triggerEvent2() {
                    this.textarea.dispatchEvent(new Event("change", {
                        bubbles: !0
                    }))
                }

                function file_manager_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function file_manager_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function file_manager_setPrototypeOf(t, d) {
                    return file_manager_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, file_manager_setPrototypeOf(t, d)
                }

                function file_manager_createSuper(t) {
                    var d = function file_manager_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = file_manager_getPrototypeOf(t);
                        if (d) {
                            var _ = file_manager_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return file_manager_possibleConstructorReturn(this, h)
                    }
                }

                function file_manager_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return file_manager_assertThisInitialized(t)
                }

                function file_manager_assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function file_manager_getPrototypeOf(t) {
                    return file_manager_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, file_manager_getPrototypeOf(t)
                }(0, C.controller)((z = file_commenter_classPrivateFieldLooseKey("triggerEvent"), function(t) {
                    ! function file_commenter_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && file_commenter_setPrototypeOf(t, d)
                    }(FileCommenterElement, window.HTMLElement);
                    var d = file_commenter_createSuper(FileCommenterElement);

                    function FileCommenterElement() {
                        var t;
                        file_commenter_classCallCheck(this, FileCommenterElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return t = d.call.apply(d, [this].concat(y)), Object.defineProperty(file_commenter_assertThisInitialized(t), z, {
                            value: _triggerEvent2
                        }), t
                    }
                    return function file_commenter_createClass(t, d, h) {
                        return d && file_commenter_defineProperties(t.prototype, d), h && file_commenter_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(FileCommenterElement, [{
                        key: "textarea",
                        get: function get() {
                            return (0, C.findTarget)(this, "textarea")
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            k(this.textarea)
                        }
                    }, {
                        key: "addComment",
                        value: function addComment(t) {
                            var d = "[Uploading ".concat(t.name, "â€¦]()"),
                                h = this.textarea.value.substring(0, this.textarea.selectionEnd || 0),
                                y = "" === this.textarea.value || h.match(/\n$/) ? "" : "\n";
                            this.textarea.setRangeText(y + d, this.textarea.selectionEnd, this.textarea.selectionEnd, "end"), this.textarea.focus()
                        }
                    }, {
                        key: "replaceComment",
                        value: function replaceComment(t, d) {
                            var h = "[Uploading ".concat(t.name, "â€¦]()"),
                                y = t.type.match(/image\/*/) ? "!" : "",
                                _ = this.textarea.value.replace(h, "".concat(y, "[").concat(t.name, "](").concat(d, ")"));
                            this.textarea.value = _, this.textarea.focus()
                        }
                    }, {
                        key: "removeComment",
                        value: function removeComment(t) {
                            var d = "[Uploading ".concat(t, "â€¦]()");
                            this.textarea.value = this.textarea.value.replace(d, "")
                        }
                    }, {
                        key: "commentExists",
                        value: function commentExists(t) {
                            return this.textarea.value.includes(t)
                        }
                    }, {
                        key: "addValidation",
                        value: function addValidation() {
                            this.textarea.setCustomValidity("uploading"), file_commenter_classPrivateFieldLooseBase(this, z)[z]()
                        }
                    }, {
                        key: "removeValidation",
                        value: function removeValidation() {
                            this.textarea.setCustomValidity(""), file_commenter_classPrivateFieldLooseBase(this, z)[z]()
                        }
                    }]), FileCommenterElement
                }()));
                var q, D, j, H, $, G, ee, te, re, ne, ie, oe, ae, se, le = 0;

                function file_manager_classPrivateFieldLooseKey(t) {
                    return "__private_" + le++ + "_" + t
                }

                function _trashButton2() {
                    var t = document.createElement("template");
                    return t.innerHTML = String.raw(B || (B = function _taggedTemplateLiteral(t, d) {
                        return d || (d = t.slice(0)), Object.freeze(Object.defineProperties(t, {
                            raw: {
                                value: Object.freeze(d)
                            }
                        }))
                    }(['<button\n          class="btn-octicon btn-octicon-danger"\n          type="button"\n          aria-label="Trashcan icon">\n          <svg class="octicon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M6.5 1.75a.25.25 0 01.25-.25h2.5a.25.25 0 01.25.25V3h-3V1.75zm4.5 0V3h2.25a.75.75 0 010 1.5H2.75a.75.75 0 010-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75zM4.496 6.675a.75.75 0 10-1.492.15l.66 6.6A1.75 1.75 0 005.405 15h5.19c.9 0 1.652-.681 1.741-1.576l.66-6.6a.75.75 0 00-1.492-.149l-.66 6.6a.25.25 0 01-.249.225h-5.19a.25.25 0 01-.249-.225l-.66-6.6z"></path></svg>\n        </button>']))), t.content.firstChild
                }

                function _toConsumableArray(t) {
                    return function _arrayWithoutHoles(t) {
                        if (Array.isArray(t)) return _arrayLikeToArray(t)
                    }(t) || function _iterableToArray(t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                    }(t) || _unsupportedIterableToArray(t) || function _nonIterableSpread() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function _createForOfIteratorHelper(t, d) {
                    var h = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!h) {
                        if (Array.isArray(t) || (h = _unsupportedIterableToArray(t)) || d && t && "number" == typeof t.length) {
                            h && (t = h);
                            var y = 0,
                                _ = function F() {};
                            return {
                                s: _,
                                n: function n() {
                                    return y >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[y++]
                                    }
                                },
                                e: function e(t) {
                                    throw t
                                },
                                f: _
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var x, C = !0,
                        E = !1;
                    return {
                        s: function s() {
                            h = h.call(t)
                        },
                        n: function n() {
                            var t = h.next();
                            return C = t.done, t
                        },
                        e: function e(t) {
                            E = !0, x = t
                        },
                        f: function f() {
                            try {
                                C || null == h.return || h.return()
                            } finally {
                                if (E) throw x
                            }
                        }
                    }
                }

                function _unsupportedIterableToArray(t, d) {
                    if (t) {
                        if ("string" == typeof t) return _arrayLikeToArray(t, d);
                        var h = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === h && t.constructor && (h = t.constructor.name), "Map" === h || "Set" === h ? Array.from(t) : "Arguments" === h || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(h) ? _arrayLikeToArray(t, d) : void 0
                    }
                }

                function _arrayLikeToArray(t, d) {
                    (null == d || d > t.length) && (d = t.length);
                    for (var h = 0, y = new Array(d); h < d; h++) y[h] = t[h];
                    return y
                }

                function file_uploader_classCallCheck(t, d) {
                    if (!(t instanceof d)) throw new TypeError("Cannot call a class as a function")
                }

                function file_uploader_defineProperties(t, d) {
                    for (var h = 0; h < d.length; h++) {
                        var y = d[h];
                        y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(t, y.key, y)
                    }
                }

                function file_uploader_setPrototypeOf(t, d) {
                    return file_uploader_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(t, d) {
                        return t.__proto__ = d, t
                    }, file_uploader_setPrototypeOf(t, d)
                }

                function file_uploader_createSuper(t) {
                    var d = function file_uploader_isNativeReflectConstruct() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function _createSuperInternal() {
                        var h, y = file_uploader_getPrototypeOf(t);
                        if (d) {
                            var _ = file_uploader_getPrototypeOf(this).constructor;
                            h = Reflect.construct(y, arguments, _)
                        } else h = y.apply(this, arguments);
                        return file_uploader_possibleConstructorReturn(this, h)
                    }
                }

                function file_uploader_possibleConstructorReturn(t, d) {
                    if (d && ("object" == typeof d || "function" == typeof d)) return d;
                    if (void 0 !== d) throw new TypeError("Derived constructors may only return object or undefined");
                    return file_uploader_assertThisInitialized(t)
                }

                function file_uploader_assertThisInitialized(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }

                function file_uploader_getPrototypeOf(t) {
                    return file_uploader_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    }, file_uploader_getPrototypeOf(t)
                }

                function file_uploader_classPrivateFieldLooseBase(t, d) {
                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                    return t
                }(0, C.controller)((A = file_manager_classPrivateFieldLooseKey("trashButton"), function(t) {
                    ! function file_manager_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && file_manager_setPrototypeOf(t, d)
                    }(FileManagerElement, window.HTMLElement);
                    var d = file_manager_createSuper(FileManagerElement);

                    function FileManagerElement() {
                        var t;
                        file_manager_classCallCheck(this, FileManagerElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return t = d.call.apply(d, [this].concat(y)), Object.defineProperty(file_manager_assertThisInitialized(t), A, {
                            value: _trashButton2
                        }), t
                    }
                    return function file_manager_createClass(t, d, h) {
                        return d && file_manager_defineProperties(t.prototype, d), h && file_manager_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(FileManagerElement, [{
                        key: "textarea",
                        get: function get() {
                            return (0, C.findTarget)(this, "textarea")
                        }
                    }, {
                        key: "display",
                        get: function get() {
                            return (0, C.findTarget)(this, "display")
                        }
                    }, {
                        key: "textareaUpdated",
                        value: function textareaUpdated() {
                            for (var t = this; this.display.firstChild;) this.display.removeChild(this.display.firstChild);
                            this.textarea.value.split("\n").filter((function(t) {
                                return "" !== t
                            })).forEach((function(d) {
                                var h = document.createElement("div"),
                                    y = document.createElement("div");
                                y.innerText = d.split("](")[0].replace(/^!/, "").replace(/^\[/, ""), y.classList.add("label"), y.dataset.markdown = d;
                                var _ = function file_manager_classPrivateFieldLooseBase(t, d) {
                                    if (!Object.prototype.hasOwnProperty.call(t, d)) throw new TypeError("attempted to use private field on non-instance");
                                    return t
                                }(t, A)[A]();
                                _.addEventListener("click", t.removeUpload.bind(t)), h.appendChild(_), h.appendChild(y), t.display.appendChild(h)
                            }))
                        }
                    }, {
                        key: "removeUpload",
                        value: function removeUpload(t) {
                            var d = t.target.closest("button").parentElement.querySelector(".label").dataset.markdown;
                            this.textarea.value = this.textarea.value.replace(d + "\n", "").replace(d, ""), this.textarea.dispatchEvent(new window.Event("change", {
                                bubbles: !0
                            }))
                        }
                    }]), FileManagerElement
                }()));
                var ce = 0;

                function file_uploader_classPrivateFieldLooseKey(t) {
                    return "__private_" + ce++ + "_" + t
                }
                var ue = 52428800;

                function _get_uploadURL() {
                    return this.getAttribute("upload-url")
                }

                function _get_fieldName() {
                    return this.getAttribute("field-name")
                }

                function _get_uploadRequired() {
                    return /true/.test(this.getAttribute("upload-required"))
                }

                function _get_randomId() {
                    return ((new Date).getTime().toString(36) + Math.random().toString(36).substring(2)).slice(-10)
                }

                function _processFiles2(t) {
                    var d = this,
                        h = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    _toConsumableArray(t).forEach((function(t) {
                        if (!file_uploader_classPrivateFieldLooseBase(d, ie)[ie](t)) return file_uploader_classPrivateFieldLooseBase(d, te)[te]("invalid");
                        if (t.size > ue) return file_uploader_classPrivateFieldLooseBase(d, te)[te]("too_big");
                        file_uploader_classPrivateFieldLooseBase(d, te)[te](), file_uploader_classPrivateFieldLooseBase(d, re)[re](h), file_uploader_classPrivateFieldLooseBase(d, ne)[ne](!1);
                        var y = file_uploader_classPrivateFieldLooseBase(d, G)[G]();
                        file_uploader_classPrivateFieldLooseBase(d, se)[se](t, y)
                    }))
                }

                function _newFileUpload2() {
                    this.filesListContainer.append(this.fileTemplate.content.cloneNode(!0));
                    var t = this.files.slice(-1)[0],
                        d = file_uploader_classPrivateFieldLooseBase(this, H)[H];
                    return t.dataset.id = d, t.cancel.dataset.id = d, t
                }

                function _findFile2(t) {
                    return this.files.find((function(d) {
                        return d.dataset.id === t
                    }))
                }

                function _toggleErrorMessage2(t) {
                    switch (this.statusDefault.hidden = !0, this.statusInvalidFile.hidden = !0, this.statusUnknown.hidden = !0, this.statusTooBig.hidden = !0, t) {
                        case "invalid":
                            this.statusInvalidFile.hidden = !1;
                            break;
                        case "too_big":
                            this.statusTooBig.hidden = !1;
                            break;
                        case "unknown":
                            this.statusUnknown.hidden = !1;
                            break;
                        default:
                            this.statusDefault.hidden = !1
                    }
                }

                function _toggleFilesListContainer2(t) {
                    this.filesListContainer.hidden = !t
                }

                function _toggleSubmit2(t) {
                    document.querySelectorAll("button.js-button-disable").forEach((function(d) {
                        d.disabled = !t
                    }))
                }

                function _validType2(t) {
                    return this.fileInput.accept.split(",").includes(x().extname(t.name).toLowerCase())
                }

                function _getUploadSession2() {
                    return JSON.parse(window.sessionStorage.getItem("uploads:".concat(this.id))) || []
                }

                function _appendUploadSession2(t, d) {
                    var h = file_uploader_classPrivateFieldLooseBase(this, oe)[oe]();
                    h.push({
                        token: t,
                        url: d
                    }), window.sessionStorage.setItem("uploads:".concat(this.id), JSON.stringify(h))
                }

                function _upload2(t, d) {
                    var h = this,
                        y = "".concat(file_uploader_classPrivateFieldLooseBase(this, q)[q], "/api/v2/uploads.json?filename=").concat(t.name),
                        _ = new window.XMLHttpRequest;
                    _.open("POST", y), _.onloadstart = function() {
                        d.xhr = _, d.show(t), h.fileCommenter.addValidation(), h.fileCommenter.addComment(t)
                    }, _.upload.onprogress = function(t) {
                        if (t.lengthComputable) {
                            var h = Math.round(t.loaded / t.total * 100);
                            d.showProgress(h)
                        }
                    }, _.onreadystatechange = function() {
                        if (_.readyState === XMLHttpRequest.DONE)
                            if (201 === _.status) {
                                try {
                                    var y = JSON.parse(_.responseText);
                                    h.fileCommenter.replaceComment(t, y.upload.attachment.content_url), file_uploader_classPrivateFieldLooseBase(h, ae)[ae](y.upload.token, y.upload.attachment.content_url)
                                } catch (x) {
                                    file_uploader_classPrivateFieldLooseBase(h, te)[te]("unknown"), console.error(x)
                                }
                                d.remove()
                            } else {
                                if (0 === _.status) return;
                                file_uploader_classPrivateFieldLooseBase(h, te)[te]("unknown")
                            } h.filesListContainer.children.length || (h.fileCommenter.removeValidation(), file_uploader_classPrivateFieldLooseBase(h, re)[re](!1), file_uploader_classPrivateFieldLooseBase(h, ne)[ne](!0))
                    }, _.send(t)
                }(0, C.controller)((q = file_uploader_classPrivateFieldLooseKey("uploadURL"), D = file_uploader_classPrivateFieldLooseKey("fieldName"), j = file_uploader_classPrivateFieldLooseKey("uploadRequired"), H = file_uploader_classPrivateFieldLooseKey("randomId"), $ = file_uploader_classPrivateFieldLooseKey("processFiles"), G = file_uploader_classPrivateFieldLooseKey("newFileUpload"), ee = file_uploader_classPrivateFieldLooseKey("findFile"), te = file_uploader_classPrivateFieldLooseKey("toggleErrorMessage"), re = file_uploader_classPrivateFieldLooseKey("toggleFilesListContainer"), ne = file_uploader_classPrivateFieldLooseKey("toggleSubmit"), ie = file_uploader_classPrivateFieldLooseKey("validType"), oe = file_uploader_classPrivateFieldLooseKey("getUploadSession"), ae = file_uploader_classPrivateFieldLooseKey("appendUploadSession"), se = file_uploader_classPrivateFieldLooseKey("upload"), function(t) {
                    ! function file_uploader_inherits(t, d) {
                        if ("function" != typeof d && null !== d) throw new TypeError("Super expression must either be null or a function");
                        Object.defineProperty(t, "prototype", {
                            value: Object.create(d && d.prototype, {
                                constructor: {
                                    value: t,
                                    writable: !0,
                                    configurable: !0
                                }
                            }),
                            writable: !1
                        }), d && file_uploader_setPrototypeOf(t, d)
                    }(FileUploaderElement, window.HTMLElement);
                    var d = file_uploader_createSuper(FileUploaderElement);

                    function FileUploaderElement() {
                        var t;
                        file_uploader_classCallCheck(this, FileUploaderElement);
                        for (var h = arguments.length, y = new Array(h), _ = 0; _ < h; _++) y[_] = arguments[_];
                        return t = d.call.apply(d, [this].concat(y)), Object.defineProperty(file_uploader_assertThisInitialized(t), se, {
                            value: _upload2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), ae, {
                            value: _appendUploadSession2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), oe, {
                            value: _getUploadSession2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), ie, {
                            value: _validType2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), ne, {
                            value: _toggleSubmit2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), re, {
                            value: _toggleFilesListContainer2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), te, {
                            value: _toggleErrorMessage2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), ee, {
                            value: _findFile2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), G, {
                            value: _newFileUpload2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), $, {
                            value: _processFiles2
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), H, {
                            get: _get_randomId,
                            set: void 0
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), j, {
                            get: _get_uploadRequired,
                            set: void 0
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), D, {
                            get: _get_fieldName,
                            set: void 0
                        }), Object.defineProperty(file_uploader_assertThisInitialized(t), q, {
                            get: _get_uploadURL,
                            set: void 0
                        }), t
                    }
                    return function file_uploader_createClass(t, d, h) {
                        return d && file_uploader_defineProperties(t.prototype, d), h && file_uploader_defineProperties(t, h), Object.defineProperty(t, "prototype", {
                            writable: !1
                        }), t
                    }(FileUploaderElement, [{
                        key: "statusDefault",
                        get: function get() {
                            return (0, C.findTarget)(this, "statusDefault")
                        }
                    }, {
                        key: "statusUnknown",
                        get: function get() {
                            return (0, C.findTarget)(this, "statusUnknown")
                        }
                    }, {
                        key: "statusInvalidFile",
                        get: function get() {
                            return (0, C.findTarget)(this, "statusInvalidFile")
                        }
                    }, {
                        key: "statusTooBig",
                        get: function get() {
                            return (0, C.findTarget)(this, "statusTooBig")
                        }
                    }, {
                        key: "fileInput",
                        get: function get() {
                            return (0, C.findTarget)(this, "fileInput")
                        }
                    }, {
                        key: "fileTemplate",
                        get: function get() {
                            return (0, C.findTarget)(this, "fileTemplate")
                        }
                    }, {
                        key: "inputTemplate",
                        get: function get() {
                            return (0, C.findTarget)(this, "inputTemplate")
                        }
                    }, {
                        key: "filesListContainer",
                        get: function get() {
                            return (0, C.findTarget)(this, "filesListContainer")
                        }
                    }, {
                        key: "files",
                        get: function get() {
                            return (0, C.findTargets)(this, "files")
                        }
                    }, {
                        key: "fileCommenter",
                        get: function get() {
                            return (0, C.findTarget)(this, "fileCommenter")
                        }
                    }, {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            document.addEventListener("dragover", this.ignoreDrop), document.addEventListener("drop", this.ignoreDrop), this.closest("form").addEventListener("submit", this.submit.bind(this))
                        }
                    }, {
                        key: "ignoreDrop",
                        value: function ignoreDrop(t) {
                            var d = t.dataTransfer;
                            d && Array.from(d.types).indexOf("Files") >= 0 && t.preventDefault()
                        }
                    }, {
                        key: "getFiles",
                        value: function getFiles(t) {
                            var d;
                            t.preventDefault();
                            var h = (d = t.dataTransfer) && d.files || this.fileInput.files;
                            file_uploader_classPrivateFieldLooseBase(this, $)[$](h)
                        }
                    }, {
                        key: "pasteImage",
                        value: function pasteImage(t) {
                            var d, h = /^image\/(gif|png|jpeg)$/;
                            if (t.clipboardData && t.clipboardData.items) {
                                var y, _ = _createForOfIteratorHelper(t.clipboardData.items);
                                try {
                                    for (_.s(); !(y = _.n()).done;) {
                                        var x = y.value;
                                        h.test(x.type) && (d = x.getAsFile())
                                    }
                                } catch (C) {
                                    _.e(C)
                                } finally {
                                    _.f()
                                }
                                d && (file_uploader_classPrivateFieldLooseBase(this, $)[$]([d], !1), t.preventDefault())
                            }
                        }
                    }, {
                        key: "cancel",
                        value: function cancel(t) {
                            var d = file_uploader_classPrivateFieldLooseBase(this, ee)[ee](t.target.dataset.id);
                            d.abort(), this.fileCommenter.removeComment(d.name.textContent), this.filesListContainer.children.length || (file_uploader_classPrivateFieldLooseBase(this, re)[re](!1), file_uploader_classPrivateFieldLooseBase(this, ne)[ne](!0), this.fileCommenter.removeValidation())
                        }
                    }, {
                        key: "submit",
                        value: function submit(t) {
                            var d = this,
                                h = file_uploader_classPrivateFieldLooseBase(this, D)[D] || "uploads",
                                y = file_uploader_classPrivateFieldLooseBase(this, oe)[oe]().filter((function(t) {
                                    return d.fileCommenter.commentExists(t.url)
                                }));
                            if (file_uploader_classPrivateFieldLooseBase(this, j)[j] && !y.length) return window.alert("Please attach one or more files to this request."), file_uploader_classPrivateFieldLooseBase(this, ne)[ne](!0), void t.preventDefault();
                            var _, x = _createForOfIteratorHelper(y);
                            try {
                                for (x.s(); !(_ = x.n()).done;) {
                                    var C = _.value,
                                        E = this.inputTemplate.content.cloneNode(!0).firstElementChild;
                                    E.name = "".concat(h, "[]"), E.value = C.token, t.target.appendChild(E)
                                }
                            } catch (O) {
                                x.e(O)
                            } finally {
                                x.f()
                            }
                            window.sessionStorage.removeItem("uploads:".concat(this.id))
                        }
                    }]), FileUploaderElement
                }()))
            },
            9243: (t, d, h) => {
                "use strict";
                h.d(d, {
                    f: () => fire,
                    on: () => on
                });
                var y = h(8439),
                    _ = {},
                    x = {},
                    C = new WeakMap,
                    E = new WeakMap,
                    O = new WeakMap,
                    k = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");

                function before(t, d, h) {
                    var y = t[d];
                    return t[d] = function() {
                        return h.apply(t, arguments), y.apply(t, arguments)
                    }, t
                }

                function trackPropagation() {
                    C.set(this, !0)
                }

                function trackImmediate() {
                    C.set(this, !0), E.set(this, !0)
                }

                function getCurrentTarget() {
                    return O.get(this) || null
                }

                function defineCurrentTarget(t, d) {
                    k && Object.defineProperty(t, "currentTarget", {
                        configurable: !0,
                        enumerable: !0,
                        get: d || k.get
                    })
                }

                function dispatch(t) {
                    if (function canDispatch(t) {
                            try {
                                return t.eventPhase, !0
                            } catch (d) {
                                return !1
                            }
                        }(t)) {
                        var d = (1 === t.eventPhase ? x : _)[t.type];
                        if (d) {
                            var h = function matches(t, d, h) {
                                var y = [],
                                    _ = d;
                                do {
                                    if (1 !== _.nodeType) break;
                                    var x = t.matches(_);
                                    if (x.length) {
                                        var C = {
                                            node: _,
                                            observers: x
                                        };
                                        h ? y.unshift(C) : y.push(C)
                                    }
                                } while (_ = _.parentElement);
                                return y
                            }(d, t.target, 1 === t.eventPhase);
                            if (h.length) {
                                before(t, "stopPropagation", trackPropagation), before(t, "stopImmediatePropagation", trackImmediate), defineCurrentTarget(t, getCurrentTarget);
                                for (var y = 0, k = h.length; y < k && !C.get(t); y++) {
                                    var z = h[y];
                                    O.set(t, z.node);
                                    for (var A = 0, B = z.observers.length; A < B && !E.get(t); A++) z.observers[A].data.call(z.node, t)
                                }
                                O.delete(t), defineCurrentTarget(t)
                            }
                        }
                    }
                }

                function on(t, d, h) {
                    var C = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                        E = !!C.capture,
                        O = E ? x : _,
                        k = O[t];
                    k || (k = new y.Z, O[t] = k, document.addEventListener(t, dispatch, E)), k.add(d, h)
                }

                function fire(t, d, h) {
                    return t.dispatchEvent(new CustomEvent(d, {
                        bubbles: !0,
                        cancelable: !0,
                        detail: h
                    }))
                }
            },
            3869: () => {
                ! function() {
                    "use strict";
                    var t = document.createElement("details"),
                        d = "undefined" != typeof HTMLDetailsElement && t instanceof HTMLDetailsElement,
                        h = "open" in t || d,
                        y = "ontoggle" in t,
                        _ = '\ndetails, summary {\n  display: block;\n}\ndetails:not([open]) > *:not(summary) {\n  display: none;\n}\nsummary::before {\n  content: "â–º";\n  padding-right: 0.3rem;\n  font-size: 0.6rem;\n  cursor: default;\n}\n[open] > summary::before {\n  content: "â–¼";\n}\n',
                        x = [],
                        C = x.forEach,
                        E = x.slice;

                    function setAccessibilityAttributes(t) {
                        (function findElementsWithTagName(t, d) {
                            return (t.tagName == d ? [t] : []).concat("function" == typeof t.getElementsByTagName ? E.call(t.getElementsByTagName(d)) : [])
                        })(t, "SUMMARY").forEach((function(t) {
                            var d = findClosestElementWithTagName(t, "DETAILS");
                            t.setAttribute("aria-expanded", d.hasAttribute("open")), t.hasAttribute("tabindex") || t.setAttribute("tabindex", "0"), t.hasAttribute("role") || t.setAttribute("role", "button")
                        }))
                    }

                    function eventIsSignificant(t) {
                        return !(t.defaultPrevented || t.ctrlKey || t.metaKey || t.shiftKey || t.target.isContentEditable)
                    }

                    function onTogglingTrigger(t) {
                        addEventListener("click", (function(d) {
                            if (eventIsSignificant(d) && d.which <= 1) {
                                var h = findClosestElementWithTagName(d.target, "SUMMARY");
                                h && h.parentNode && "DETAILS" == h.parentNode.tagName && t(h.parentNode)
                            }
                        }), !1), addEventListener("keydown", (function(d) {
                            if (eventIsSignificant(d) && (13 == d.keyCode || 32 == d.keyCode)) {
                                var h = findClosestElementWithTagName(d.target, "SUMMARY");
                                h && h.parentNode && "DETAILS" == h.parentNode.tagName && (t(h.parentNode), d.preventDefault())
                            }
                        }), !1)
                    }

                    function triggerToggle(t) {
                        var d = document.createEvent("Event");
                        d.initEvent("toggle", !1, !1), t.dispatchEvent(d)
                    }

                    function findClosestElementWithTagName(t, d) {
                        if ("function" == typeof t.closest) return t.closest(d);
                        for (; t;) {
                            if (t.tagName == d) return t;
                            t = t.parentNode
                        }
                    }
                    h || (! function polyfillStyles() {
                        document.head.insertAdjacentHTML("afterbegin", "<style>" + _ + "</style>")
                    }(), function polyfillProperties() {
                        var t = document.createElement("details").constructor.prototype,
                            d = t.setAttribute,
                            h = t.removeAttribute,
                            y = Object.getOwnPropertyDescriptor(t, "open");
                        Object.defineProperties(t, {
                            open: {
                                get: function get() {
                                    return "DETAILS" == this.tagName ? this.hasAttribute("open") : y && y.get ? y.get.call(this) : void 0
                                },
                                set: function set(t) {
                                    return "DETAILS" == this.tagName ? t ? this.setAttribute("open", "") : this.removeAttribute("open") : y && y.set ? y.set.call(this, t) : void 0
                                }
                            },
                            setAttribute: {
                                value: function value(t, h) {
                                    var y = this,
                                        _ = function call() {
                                            return d.call(y, t, h)
                                        };
                                    if ("open" == t && "DETAILS" == this.tagName) {
                                        var x = this.hasAttribute("open"),
                                            C = _();
                                        if (!x) {
                                            var E = this.querySelector("summary");
                                            E && E.setAttribute("aria-expanded", !0), triggerToggle(this)
                                        }
                                        return C
                                    }
                                    return _()
                                }
                            },
                            removeAttribute: {
                                value: function value(t) {
                                    var d = this,
                                        y = function call() {
                                            return h.call(d, t)
                                        };
                                    if ("open" == t && "DETAILS" == this.tagName) {
                                        var _ = this.hasAttribute("open"),
                                            x = y();
                                        if (_) {
                                            var C = this.querySelector("summary");
                                            C && C.setAttribute("aria-expanded", !1), triggerToggle(this)
                                        }
                                        return x
                                    }
                                    return y()
                                }
                            }
                        })
                    }(), function polyfillToggle() {
                        onTogglingTrigger((function(t) {
                            t.hasAttribute("open") ? t.removeAttribute("open") : t.setAttribute("open", "")
                        }))
                    }(), function polyfillAccessibility() {
                        setAccessibilityAttributes(document), window.MutationObserver ? new MutationObserver((function(t) {
                            C.call(t, (function(t) {
                                C.call(t.addedNodes, setAccessibilityAttributes)
                            }))
                        })).observe(document.documentElement, {
                            subtree: !0,
                            childList: !0
                        }) : document.addEventListener("DOMNodeInserted", (function(t) {
                            setAccessibilityAttributes(t.target)
                        }))
                    }()), h && !y && function polyfillToggleEvent() {
                        window.MutationObserver ? new MutationObserver((function(t) {
                            C.call(t, (function(t) {
                                var d = t.target,
                                    h = t.attributeName;
                                "DETAILS" == d.tagName && "open" == h && triggerToggle(d)
                            }))
                        })).observe(document.documentElement, {
                            attributes: !0,
                            subtree: !0
                        }) : onTogglingTrigger((function(t) {
                            var d = t.getAttribute("open");
                            setTimeout((function() {
                                var h = t.getAttribute("open");
                                d != h && triggerToggle(t)
                            }), 1)
                        }))
                    }()
                }()
            },
            7187: t => {
                "use strict";
                var d, h = "object" == typeof Reflect ? Reflect : null,
                    y = h && "function" == typeof h.apply ? h.apply : function ReflectApply(t, d, h) {
                        return Function.prototype.apply.call(t, d, h)
                    };
                d = h && "function" == typeof h.ownKeys ? h.ownKeys : Object.getOwnPropertySymbols ? function ReflectOwnKeys(t) {
                    return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
                } : function ReflectOwnKeys(t) {
                    return Object.getOwnPropertyNames(t)
                };
                var _ = Number.isNaN || function NumberIsNaN(t) {
                    return t != t
                };

                function EventEmitter() {
                    EventEmitter.init.call(this)
                }
                t.exports = EventEmitter, t.exports.once = function once(t, d) {
                    return new Promise((function(h, y) {
                        function errorListener(h) {
                            t.removeListener(d, resolver), y(h)
                        }

                        function resolver() {
                            "function" == typeof t.removeListener && t.removeListener("error", errorListener), h([].slice.call(arguments))
                        }
                        eventTargetAgnosticAddListener(t, d, resolver, {
                            once: !0
                        }), "error" !== d && function addErrorHandlerIfEventEmitter(t, d, h) {
                            "function" == typeof t.on && eventTargetAgnosticAddListener(t, "error", d, h)
                        }(t, errorListener, {
                            once: !0
                        })
                    }))
                }, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._eventsCount = 0, EventEmitter.prototype._maxListeners = void 0;
                var x = 10;

                function checkListener(t) {
                    if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
                }

                function _getMaxListeners(t) {
                    return void 0 === t._maxListeners ? EventEmitter.defaultMaxListeners : t._maxListeners
                }

                function _addListener(t, d, h, y) {
                    var _, x, C;
                    if (checkListener(h), void 0 === (x = t._events) ? (x = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== x.newListener && (t.emit("newListener", d, h.listener ? h.listener : h), x = t._events), C = x[d]), void 0 === C) C = x[d] = h, ++t._eventsCount;
                    else if ("function" == typeof C ? C = x[d] = y ? [h, C] : [C, h] : y ? C.unshift(h) : C.push(h), (_ = _getMaxListeners(t)) > 0 && C.length > _ && !C.warned) {
                        C.warned = !0;
                        var E = new Error("Possible EventEmitter memory leak detected. " + C.length + " " + String(d) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                        E.name = "MaxListenersExceededWarning", E.emitter = t, E.type = d, E.count = C.length,
                            function ProcessEmitWarning(t) {
                                console && console.warn && console.warn(t)
                            }(E)
                    }
                    return t
                }

                function onceWrapper() {
                    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
                }

                function _onceWrap(t, d, h) {
                    var y = {
                            fired: !1,
                            wrapFn: void 0,
                            target: t,
                            type: d,
                            listener: h
                        },
                        _ = onceWrapper.bind(y);
                    return _.listener = h, y.wrapFn = _, _
                }

                function _listeners(t, d, h) {
                    var y = t._events;
                    if (void 0 === y) return [];
                    var _ = y[d];
                    return void 0 === _ ? [] : "function" == typeof _ ? h ? [_.listener || _] : [_] : h ? function unwrapListeners(t) {
                        for (var d = new Array(t.length), h = 0; h < d.length; ++h) d[h] = t[h].listener || t[h];
                        return d
                    }(_) : arrayClone(_, _.length)
                }

                function listenerCount(t) {
                    var d = this._events;
                    if (void 0 !== d) {
                        var h = d[t];
                        if ("function" == typeof h) return 1;
                        if (void 0 !== h) return h.length
                    }
                    return 0
                }

                function arrayClone(t, d) {
                    for (var h = new Array(d), y = 0; y < d; ++y) h[y] = t[y];
                    return h
                }

                function eventTargetAgnosticAddListener(t, d, h, y) {
                    if ("function" == typeof t.on) y.once ? t.once(d, h) : t.on(d, h);
                    else {
                        if ("function" != typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
                        t.addEventListener(d, (function wrapListener(_) {
                            y.once && t.removeEventListener(d, wrapListener), h(_)
                        }))
                    }
                }
                Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                    enumerable: !0,
                    get: function() {
                        return x
                    },
                    set: function(t) {
                        if ("number" != typeof t || t < 0 || _(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
                        x = t
                    }
                }), EventEmitter.init = function() {
                    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
                }, EventEmitter.prototype.setMaxListeners = function setMaxListeners(t) {
                    if ("number" != typeof t || t < 0 || _(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
                    return this._maxListeners = t, this
                }, EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                    return _getMaxListeners(this)
                }, EventEmitter.prototype.emit = function emit(t) {
                    for (var d = [], h = 1; h < arguments.length; h++) d.push(arguments[h]);
                    var _ = "error" === t,
                        x = this._events;
                    if (void 0 !== x) _ = _ && void 0 === x.error;
                    else if (!_) return !1;
                    if (_) {
                        var C;
                        if (d.length > 0 && (C = d[0]), C instanceof Error) throw C;
                        var E = new Error("Unhandled error." + (C ? " (" + C.message + ")" : ""));
                        throw E.context = C, E
                    }
                    var O = x[t];
                    if (void 0 === O) return !1;
                    if ("function" == typeof O) y(O, this, d);
                    else {
                        var k = O.length,
                            z = arrayClone(O, k);
                        for (h = 0; h < k; ++h) y(z[h], this, d)
                    }
                    return !0
                }, EventEmitter.prototype.addListener = function addListener(t, d) {
                    return _addListener(this, t, d, !1)
                }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.prependListener = function prependListener(t, d) {
                    return _addListener(this, t, d, !0)
                }, EventEmitter.prototype.once = function once(t, d) {
                    return checkListener(d), this.on(t, _onceWrap(this, t, d)), this
                }, EventEmitter.prototype.prependOnceListener = function prependOnceListener(t, d) {
                    return checkListener(d), this.prependListener(t, _onceWrap(this, t, d)), this
                }, EventEmitter.prototype.removeListener = function removeListener(t, d) {
                    var h, y, _, x, C;
                    if (checkListener(d), void 0 === (y = this._events)) return this;
                    if (void 0 === (h = y[t])) return this;
                    if (h === d || h.listener === d) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete y[t], y.removeListener && this.emit("removeListener", t, h.listener || d));
                    else if ("function" != typeof h) {
                        for (_ = -1, x = h.length - 1; x >= 0; x--)
                            if (h[x] === d || h[x].listener === d) {
                                C = h[x].listener, _ = x;
                                break
                            } if (_ < 0) return this;
                        0 === _ ? h.shift() : function spliceOne(t, d) {
                            for (; d + 1 < t.length; d++) t[d] = t[d + 1];
                            t.pop()
                        }(h, _), 1 === h.length && (y[t] = h[0]), void 0 !== y.removeListener && this.emit("removeListener", t, C || d)
                    }
                    return this
                }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.removeAllListeners = function removeAllListeners(t) {
                    var d, h, y;
                    if (void 0 === (h = this._events)) return this;
                    if (void 0 === h.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== h[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete h[t]), this;
                    if (0 === arguments.length) {
                        var _, x = Object.keys(h);
                        for (y = 0; y < x.length; ++y) "removeListener" !== (_ = x[y]) && this.removeAllListeners(_);
                        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                    }
                    if ("function" == typeof(d = h[t])) this.removeListener(t, d);
                    else if (void 0 !== d)
                        for (y = d.length - 1; y >= 0; y--) this.removeListener(t, d[y]);
                    return this
                }, EventEmitter.prototype.listeners = function listeners(t) {
                    return _listeners(this, t, !0)
                }, EventEmitter.prototype.rawListeners = function rawListeners(t) {
                    return _listeners(this, t, !1)
                }, EventEmitter.listenerCount = function(t, d) {
                    return "function" == typeof t.listenerCount ? t.listenerCount(d) : listenerCount.call(t, d)
                }, EventEmitter.prototype.listenerCount = listenerCount, EventEmitter.prototype.eventNames = function eventNames() {
                    return this._eventsCount > 0 ? d(this._events) : []
                }
            },
            773: (t, d, h) => {
                var y = "__lodash_hash_undefined__",
                    _ = "[object Function]",
                    x = "[object GeneratorFunction]",
                    C = /^\[object .+?Constructor\]$/,
                    E = "object" == typeof h.g && h.g && h.g.Object === Object && h.g,
                    O = "object" == typeof self && self && self.Object === Object && self,
                    k = E || O || Function("return this")();
                var z, A = Array.prototype,
                    B = Function.prototype,
                    I = Object.prototype,
                    q = k["__core-js_shared__"],
                    D = (z = /[^.]+$/.exec(q && q.keys && q.keys.IE_PROTO || "")) ? "Symbol(src)_1." + z : "",
                    j = B.toString,
                    H = I.hasOwnProperty,
                    $ = I.toString,
                    G = RegExp("^" + j.call(H).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    ee = A.splice,
                    te = getNative(k, "Map"),
                    re = getNative(Object, "create");

                function Hash(t) {
                    var d = -1,
                        h = t ? t.length : 0;
                    for (this.clear(); ++d < h;) {
                        var y = t[d];
                        this.set(y[0], y[1])
                    }
                }

                function ListCache(t) {
                    var d = -1,
                        h = t ? t.length : 0;
                    for (this.clear(); ++d < h;) {
                        var y = t[d];
                        this.set(y[0], y[1])
                    }
                }

                function MapCache(t) {
                    var d = -1,
                        h = t ? t.length : 0;
                    for (this.clear(); ++d < h;) {
                        var y = t[d];
                        this.set(y[0], y[1])
                    }
                }

                function assocIndexOf(t, d) {
                    for (var h, y, _ = t.length; _--;)
                        if ((h = t[_][0]) === (y = d) || h != h && y != y) return _;
                    return -1
                }

                function baseIsNative(t) {
                    if (!isObject(t) || function isMasked(t) {
                            return !!D && D in t
                        }(t)) return !1;
                    var d = function isFunction(t) {
                        var d = isObject(t) ? $.call(t) : "";
                        return d == _ || d == x
                    }(t) || function isHostObject(t) {
                        var d = !1;
                        if (null != t && "function" != typeof t.toString) try {
                            d = !!(t + "")
                        } catch (h) {}
                        return d
                    }(t) ? G : C;
                    return d.test(function toSource(t) {
                        if (null != t) {
                            try {
                                return j.call(t)
                            } catch (d) {}
                            try {
                                return t + ""
                            } catch (d) {}
                        }
                        return ""
                    }(t))
                }

                function getMapData(t, d) {
                    var h = t.__data__;
                    return function isKeyable(t) {
                        var d = typeof t;
                        return "string" == d || "number" == d || "symbol" == d || "boolean" == d ? "__proto__" !== t : null === t
                    }(d) ? h["string" == typeof d ? "string" : "hash"] : h.map
                }

                function getNative(t, d) {
                    var h = function getValue(t, d) {
                        return null == t ? void 0 : t[d]
                    }(t, d);
                    return baseIsNative(h) ? h : void 0
                }

                function memoize(t, d) {
                    if ("function" != typeof t || d && "function" != typeof d) throw new TypeError("Expected a function");
                    var memoized = function() {
                        var h = arguments,
                            y = d ? d.apply(this, h) : h[0],
                            _ = memoized.cache;
                        if (_.has(y)) return _.get(y);
                        var x = t.apply(this, h);
                        return memoized.cache = _.set(y, x), x
                    };
                    return memoized.cache = new(memoize.Cache || MapCache), memoized
                }

                function isObject(t) {
                    var d = typeof t;
                    return !!t && ("object" == d || "function" == d)
                }
                Hash.prototype.clear = function hashClear() {
                    this.__data__ = re ? re(null) : {}
                }, Hash.prototype.delete = function hashDelete(t) {
                    return this.has(t) && delete this.__data__[t]
                }, Hash.prototype.get = function hashGet(t) {
                    var d = this.__data__;
                    if (re) {
                        var h = d[t];
                        return h === y ? void 0 : h
                    }
                    return H.call(d, t) ? d[t] : void 0
                }, Hash.prototype.has = function hashHas(t) {
                    var d = this.__data__;
                    return re ? void 0 !== d[t] : H.call(d, t)
                }, Hash.prototype.set = function hashSet(t, d) {
                    return this.__data__[t] = re && void 0 === d ? y : d, this
                }, ListCache.prototype.clear = function listCacheClear() {
                    this.__data__ = []
                }, ListCache.prototype.delete = function listCacheDelete(t) {
                    var d = this.__data__,
                        h = assocIndexOf(d, t);
                    return !(h < 0) && (h == d.length - 1 ? d.pop() : ee.call(d, h, 1), !0)
                }, ListCache.prototype.get = function listCacheGet(t) {
                    var d = this.__data__,
                        h = assocIndexOf(d, t);
                    return h < 0 ? void 0 : d[h][1]
                }, ListCache.prototype.has = function listCacheHas(t) {
                    return assocIndexOf(this.__data__, t) > -1
                }, ListCache.prototype.set = function listCacheSet(t, d) {
                    var h = this.__data__,
                        y = assocIndexOf(h, t);
                    return y < 0 ? h.push([t, d]) : h[y][1] = d, this
                }, MapCache.prototype.clear = function mapCacheClear() {
                    this.__data__ = {
                        hash: new Hash,
                        map: new(te || ListCache),
                        string: new Hash
                    }
                }, MapCache.prototype.delete = function mapCacheDelete(t) {
                    return getMapData(this, t).delete(t)
                }, MapCache.prototype.get = function mapCacheGet(t) {
                    return getMapData(this, t).get(t)
                }, MapCache.prototype.has = function mapCacheHas(t) {
                    return getMapData(this, t).has(t)
                }, MapCache.prototype.set = function mapCacheSet(t, d) {
                    return getMapData(this, t).set(t, d), this
                }, memoize.Cache = MapCache, t.exports = memoize
            },
            6470: t => {
                "use strict";

                function assertPath(t) {
                    if ("string" != typeof t) throw new TypeError("Path must be a string. Received " + JSON.stringify(t))
                }

                function normalizeStringPosix(t, d) {
                    for (var h, y = "", _ = 0, x = -1, C = 0, E = 0; E <= t.length; ++E) {
                        if (E < t.length) h = t.charCodeAt(E);
                        else {
                            if (47 === h) break;
                            h = 47
                        }
                        if (47 === h) {
                            if (x === E - 1 || 1 === C);
                            else if (x !== E - 1 && 2 === C) {
                                if (y.length < 2 || 2 !== _ || 46 !== y.charCodeAt(y.length - 1) || 46 !== y.charCodeAt(y.length - 2))
                                    if (y.length > 2) {
                                        var O = y.lastIndexOf("/");
                                        if (O !== y.length - 1) {
                                            -1 === O ? (y = "", _ = 0) : _ = (y = y.slice(0, O)).length - 1 - y.lastIndexOf("/"), x = E, C = 0;
                                            continue
                                        }
                                    } else if (2 === y.length || 1 === y.length) {
                                    y = "", _ = 0, x = E, C = 0;
                                    continue
                                }
                                d && (y.length > 0 ? y += "/.." : y = "..", _ = 2)
                            } else y.length > 0 ? y += "/" + t.slice(x + 1, E) : y = t.slice(x + 1, E), _ = E - x - 1;
                            x = E, C = 0
                        } else 46 === h && -1 !== C ? ++C : C = -1
                    }
                    return y
                }
                var d = {
                    resolve: function resolve() {
                        for (var t, d = "", h = !1, y = arguments.length - 1; y >= -1 && !h; y--) {
                            var _;
                            y >= 0 ? _ = arguments[y] : (void 0 === t && (t = process.cwd()), _ = t), assertPath(_), 0 !== _.length && (d = _ + "/" + d, h = 47 === _.charCodeAt(0))
                        }
                        return d = normalizeStringPosix(d, !h), h ? d.length > 0 ? "/" + d : "/" : d.length > 0 ? d : "."
                    },
                    normalize: function normalize(t) {
                        if (assertPath(t), 0 === t.length) return ".";
                        var d = 47 === t.charCodeAt(0),
                            h = 47 === t.charCodeAt(t.length - 1);
                        return 0 !== (t = normalizeStringPosix(t, !d)).length || d || (t = "."), t.length > 0 && h && (t += "/"), d ? "/" + t : t
                    },
                    isAbsolute: function isAbsolute(t) {
                        return assertPath(t), t.length > 0 && 47 === t.charCodeAt(0)
                    },
                    join: function join() {
                        if (0 === arguments.length) return ".";
                        for (var t, h = 0; h < arguments.length; ++h) {
                            var y = arguments[h];
                            assertPath(y), y.length > 0 && (void 0 === t ? t = y : t += "/" + y)
                        }
                        return void 0 === t ? "." : d.normalize(t)
                    },
                    relative: function relative(t, h) {
                        if (assertPath(t), assertPath(h), t === h) return "";
                        if ((t = d.resolve(t)) === (h = d.resolve(h))) return "";
                        for (var y = 1; y < t.length && 47 === t.charCodeAt(y); ++y);
                        for (var _ = t.length, x = _ - y, C = 1; C < h.length && 47 === h.charCodeAt(C); ++C);
                        for (var E = h.length - C, O = x < E ? x : E, k = -1, z = 0; z <= O; ++z) {
                            if (z === O) {
                                if (E > O) {
                                    if (47 === h.charCodeAt(C + z)) return h.slice(C + z + 1);
                                    if (0 === z) return h.slice(C + z)
                                } else x > O && (47 === t.charCodeAt(y + z) ? k = z : 0 === z && (k = 0));
                                break
                            }
                            var A = t.charCodeAt(y + z);
                            if (A !== h.charCodeAt(C + z)) break;
                            47 === A && (k = z)
                        }
                        var B = "";
                        for (z = y + k + 1; z <= _; ++z) z !== _ && 47 !== t.charCodeAt(z) || (0 === B.length ? B += ".." : B += "/..");
                        return B.length > 0 ? B + h.slice(C + k) : (C += k, 47 === h.charCodeAt(C) && ++C, h.slice(C))
                    },
                    _makeLong: function _makeLong(t) {
                        return t
                    },
                    dirname: function dirname(t) {
                        if (assertPath(t), 0 === t.length) return ".";
                        for (var d = t.charCodeAt(0), h = 47 === d, y = -1, _ = !0, x = t.length - 1; x >= 1; --x)
                            if (47 === (d = t.charCodeAt(x))) {
                                if (!_) {
                                    y = x;
                                    break
                                }
                            } else _ = !1;
                        return -1 === y ? h ? "/" : "." : h && 1 === y ? "//" : t.slice(0, y)
                    },
                    basename: function basename(t, d) {
                        if (void 0 !== d && "string" != typeof d) throw new TypeError('"ext" argument must be a string');
                        assertPath(t);
                        var h, y = 0,
                            _ = -1,
                            x = !0;
                        if (void 0 !== d && d.length > 0 && d.length <= t.length) {
                            if (d.length === t.length && d === t) return "";
                            var C = d.length - 1,
                                E = -1;
                            for (h = t.length - 1; h >= 0; --h) {
                                var O = t.charCodeAt(h);
                                if (47 === O) {
                                    if (!x) {
                                        y = h + 1;
                                        break
                                    }
                                } else -1 === E && (x = !1, E = h + 1), C >= 0 && (O === d.charCodeAt(C) ? -1 == --C && (_ = h) : (C = -1, _ = E))
                            }
                            return y === _ ? _ = E : -1 === _ && (_ = t.length), t.slice(y, _)
                        }
                        for (h = t.length - 1; h >= 0; --h)
                            if (47 === t.charCodeAt(h)) {
                                if (!x) {
                                    y = h + 1;
                                    break
                                }
                            } else -1 === _ && (x = !1, _ = h + 1);
                        return -1 === _ ? "" : t.slice(y, _)
                    },
                    extname: function extname(t) {
                        assertPath(t);
                        for (var d = -1, h = 0, y = -1, _ = !0, x = 0, C = t.length - 1; C >= 0; --C) {
                            var E = t.charCodeAt(C);
                            if (47 !== E) - 1 === y && (_ = !1, y = C + 1), 46 === E ? -1 === d ? d = C : 1 !== x && (x = 1) : -1 !== d && (x = -1);
                            else if (!_) {
                                h = C + 1;
                                break
                            }
                        }
                        return -1 === d || -1 === y || 0 === x || 1 === x && d === y - 1 && d === h + 1 ? "" : t.slice(d, y)
                    },
                    format: function format(t) {
                        if (null === t || "object" != typeof t) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
                        return function _format(t, d) {
                            var h = d.dir || d.root,
                                y = d.base || (d.name || "") + (d.ext || "");
                            return h ? h === d.root ? h + y : h + t + y : y
                        }("/", t)
                    },
                    parse: function parse(t) {
                        assertPath(t);
                        var d = {
                            root: "",
                            dir: "",
                            base: "",
                            ext: "",
                            name: ""
                        };
                        if (0 === t.length) return d;
                        var h, y = t.charCodeAt(0),
                            _ = 47 === y;
                        _ ? (d.root = "/", h = 1) : h = 0;
                        for (var x = -1, C = 0, E = -1, O = !0, k = t.length - 1, z = 0; k >= h; --k)
                            if (47 !== (y = t.charCodeAt(k))) - 1 === E && (O = !1, E = k + 1), 46 === y ? -1 === x ? x = k : 1 !== z && (z = 1) : -1 !== x && (z = -1);
                            else if (!O) {
                            C = k + 1;
                            break
                        }
                        return -1 === x || -1 === E || 0 === z || 1 === z && x === E - 1 && x === C + 1 ? -1 !== E && (d.base = d.name = 0 === C && _ ? t.slice(1, E) : t.slice(C, E)) : (0 === C && _ ? (d.name = t.slice(1, x), d.base = t.slice(1, E)) : (d.name = t.slice(C, x), d.base = t.slice(C, E)), d.ext = t.slice(x, E)), C > 0 ? d.dir = t.slice(0, C - 1) : _ && (d.dir = "/"), d
                    },
                    sep: "/",
                    delimiter: ":",
                    win32: null,
                    posix: null
                };
                d.posix = d, t.exports = d
            },
            5666: t => {
                var d = function(t) {
                    "use strict";
                    var d, h = Object.prototype,
                        y = h.hasOwnProperty,
                        _ = "function" == typeof Symbol ? Symbol : {},
                        x = _.iterator || "@@iterator",
                        C = _.asyncIterator || "@@asyncIterator",
                        E = _.toStringTag || "@@toStringTag";

                    function define(t, d, h) {
                        return Object.defineProperty(t, d, {
                            value: h,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }), t[d]
                    }
                    try {
                        define({}, "")
                    } catch (H) {
                        define = function(t, d, h) {
                            return t[d] = h
                        }
                    }

                    function wrap(t, d, h, y) {
                        var _ = d && d.prototype instanceof Generator ? d : Generator,
                            x = Object.create(_.prototype),
                            C = new Context(y || []);
                        return x._invoke = function makeInvokeMethod(t, d, h) {
                            var y = O;
                            return function invoke(_, x) {
                                if (y === z) throw new Error("Generator is already running");
                                if (y === A) {
                                    if ("throw" === _) throw x;
                                    return doneResult()
                                }
                                for (h.method = _, h.arg = x;;) {
                                    var C = h.delegate;
                                    if (C) {
                                        var E = maybeInvokeDelegate(C, h);
                                        if (E) {
                                            if (E === B) continue;
                                            return E
                                        }
                                    }
                                    if ("next" === h.method) h.sent = h._sent = h.arg;
                                    else if ("throw" === h.method) {
                                        if (y === O) throw y = A, h.arg;
                                        h.dispatchException(h.arg)
                                    } else "return" === h.method && h.abrupt("return", h.arg);
                                    y = z;
                                    var I = tryCatch(t, d, h);
                                    if ("normal" === I.type) {
                                        if (y = h.done ? A : k, I.arg === B) continue;
                                        return {
                                            value: I.arg,
                                            done: h.done
                                        }
                                    }
                                    "throw" === I.type && (y = A, h.method = "throw", h.arg = I.arg)
                                }
                            }
                        }(t, h, C), x
                    }

                    function tryCatch(t, d, h) {
                        try {
                            return {
                                type: "normal",
                                arg: t.call(d, h)
                            }
                        } catch (H) {
                            return {
                                type: "throw",
                                arg: H
                            }
                        }
                    }
                    t.wrap = wrap;
                    var O = "suspendedStart",
                        k = "suspendedYield",
                        z = "executing",
                        A = "completed",
                        B = {};

                    function Generator() {}

                    function GeneratorFunction() {}

                    function GeneratorFunctionPrototype() {}
                    var I = {};
                    define(I, x, (function() {
                        return this
                    }));
                    var q = Object.getPrototypeOf,
                        D = q && q(q(values([])));
                    D && D !== h && y.call(D, x) && (I = D);
                    var j = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(I);

                    function defineIteratorMethods(t) {
                        ["next", "throw", "return"].forEach((function(d) {
                            define(t, d, (function(t) {
                                return this._invoke(d, t)
                            }))
                        }))
                    }

                    function AsyncIterator(t, d) {
                        function invoke(h, _, x, C) {
                            var E = tryCatch(t[h], t, _);
                            if ("throw" !== E.type) {
                                var O = E.arg,
                                    k = O.value;
                                return k && "object" == typeof k && y.call(k, "__await") ? d.resolve(k.__await).then((function(t) {
                                    invoke("next", t, x, C)
                                }), (function(t) {
                                    invoke("throw", t, x, C)
                                })) : d.resolve(k).then((function(t) {
                                    O.value = t, x(O)
                                }), (function(t) {
                                    return invoke("throw", t, x, C)
                                }))
                            }
                            C(E.arg)
                        }
                        var h;
                        this._invoke = function enqueue(t, y) {
                            function callInvokeWithMethodAndArg() {
                                return new d((function(d, h) {
                                    invoke(t, y, d, h)
                                }))
                            }
                            return h = h ? h.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg()
                        }
                    }

                    function maybeInvokeDelegate(t, h) {
                        var y = t.iterator[h.method];
                        if (y === d) {
                            if (h.delegate = null, "throw" === h.method) {
                                if (t.iterator.return && (h.method = "return", h.arg = d, maybeInvokeDelegate(t, h), "throw" === h.method)) return B;
                                h.method = "throw", h.arg = new TypeError("The iterator does not provide a 'throw' method")
                            }
                            return B
                        }
                        var _ = tryCatch(y, t.iterator, h.arg);
                        if ("throw" === _.type) return h.method = "throw", h.arg = _.arg, h.delegate = null, B;
                        var x = _.arg;
                        return x ? x.done ? (h[t.resultName] = x.value, h.next = t.nextLoc, "return" !== h.method && (h.method = "next", h.arg = d), h.delegate = null, B) : x : (h.method = "throw", h.arg = new TypeError("iterator result is not an object"), h.delegate = null, B)
                    }

                    function pushTryEntry(t) {
                        var d = {
                            tryLoc: t[0]
                        };
                        1 in t && (d.catchLoc = t[1]), 2 in t && (d.finallyLoc = t[2], d.afterLoc = t[3]), this.tryEntries.push(d)
                    }

                    function resetTryEntry(t) {
                        var d = t.completion || {};
                        d.type = "normal", delete d.arg, t.completion = d
                    }

                    function Context(t) {
                        this.tryEntries = [{
                            tryLoc: "root"
                        }], t.forEach(pushTryEntry, this), this.reset(!0)
                    }

                    function values(t) {
                        if (t) {
                            var h = t[x];
                            if (h) return h.call(t);
                            if ("function" == typeof t.next) return t;
                            if (!isNaN(t.length)) {
                                var _ = -1,
                                    C = function next() {
                                        for (; ++_ < t.length;)
                                            if (y.call(t, _)) return next.value = t[_], next.done = !1, next;
                                        return next.value = d, next.done = !0, next
                                    };
                                return C.next = C
                            }
                        }
                        return {
                            next: doneResult
                        }
                    }

                    function doneResult() {
                        return {
                            value: d,
                            done: !0
                        }
                    }
                    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(j, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, E, "GeneratorFunction"), t.isGeneratorFunction = function(t) {
                        var d = "function" == typeof t && t.constructor;
                        return !!d && (d === GeneratorFunction || "GeneratorFunction" === (d.displayName || d.name))
                    }, t.mark = function(t) {
                        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, E, "GeneratorFunction")), t.prototype = Object.create(j), t
                    }, t.awrap = function(t) {
                        return {
                            __await: t
                        }
                    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, C, (function() {
                        return this
                    })), t.AsyncIterator = AsyncIterator, t.async = function(d, h, y, _, x) {
                        void 0 === x && (x = Promise);
                        var C = new AsyncIterator(wrap(d, h, y, _), x);
                        return t.isGeneratorFunction(h) ? C : C.next().then((function(t) {
                            return t.done ? t.value : C.next()
                        }))
                    }, defineIteratorMethods(j), define(j, E, "Generator"), define(j, x, (function() {
                        return this
                    })), define(j, "toString", (function() {
                        return "[object Generator]"
                    })), t.keys = function(t) {
                        var d = [];
                        for (var h in t) d.push(h);
                        return d.reverse(),
                            function next() {
                                for (; d.length;) {
                                    var h = d.pop();
                                    if (h in t) return next.value = h, next.done = !1, next
                                }
                                return next.done = !0, next
                            }
                    }, t.values = values, Context.prototype = {
                        constructor: Context,
                        reset: function(t) {
                            if (this.prev = 0, this.next = 0, this.sent = this._sent = d, this.done = !1, this.delegate = null, this.method = "next", this.arg = d, this.tryEntries.forEach(resetTryEntry), !t)
                                for (var h in this) "t" === h.charAt(0) && y.call(this, h) && !isNaN(+h.slice(1)) && (this[h] = d)
                        },
                        stop: function() {
                            this.done = !0;
                            var t = this.tryEntries[0].completion;
                            if ("throw" === t.type) throw t.arg;
                            return this.rval
                        },
                        dispatchException: function(t) {
                            if (this.done) throw t;
                            var h = this;

                            function handle(y, _) {
                                return C.type = "throw", C.arg = t, h.next = y, _ && (h.method = "next", h.arg = d), !!_
                            }
                            for (var _ = this.tryEntries.length - 1; _ >= 0; --_) {
                                var x = this.tryEntries[_],
                                    C = x.completion;
                                if ("root" === x.tryLoc) return handle("end");
                                if (x.tryLoc <= this.prev) {
                                    var E = y.call(x, "catchLoc"),
                                        O = y.call(x, "finallyLoc");
                                    if (E && O) {
                                        if (this.prev < x.catchLoc) return handle(x.catchLoc, !0);
                                        if (this.prev < x.finallyLoc) return handle(x.finallyLoc)
                                    } else if (E) {
                                        if (this.prev < x.catchLoc) return handle(x.catchLoc, !0)
                                    } else {
                                        if (!O) throw new Error("try statement without catch or finally");
                                        if (this.prev < x.finallyLoc) return handle(x.finallyLoc)
                                    }
                                }
                            }
                        },
                        abrupt: function(t, d) {
                            for (var h = this.tryEntries.length - 1; h >= 0; --h) {
                                var _ = this.tryEntries[h];
                                if (_.tryLoc <= this.prev && y.call(_, "finallyLoc") && this.prev < _.finallyLoc) {
                                    var x = _;
                                    break
                                }
                            }
                            x && ("break" === t || "continue" === t) && x.tryLoc <= d && d <= x.finallyLoc && (x = null);
                            var C = x ? x.completion : {};
                            return C.type = t, C.arg = d, x ? (this.method = "next", this.next = x.finallyLoc, B) : this.complete(C)
                        },
                        complete: function(t, d) {
                            if ("throw" === t.type) throw t.arg;
                            return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && d && (this.next = d), B
                        },
                        finish: function(t) {
                            for (var d = this.tryEntries.length - 1; d >= 0; --d) {
                                var h = this.tryEntries[d];
                                if (h.finallyLoc === t) return this.complete(h.completion, h.afterLoc), resetTryEntry(h), B
                            }
                        },
                        catch: function(t) {
                            for (var d = this.tryEntries.length - 1; d >= 0; --d) {
                                var h = this.tryEntries[d];
                                if (h.tryLoc === t) {
                                    var y = h.completion;
                                    if ("throw" === y.type) {
                                        var _ = y.arg;
                                        resetTryEntry(h)
                                    }
                                    return _
                                }
                            }
                            throw new Error("illegal catch attempt")
                        },
                        delegateYield: function(t, h, y) {
                            return this.delegate = {
                                iterator: values(t),
                                resultName: h,
                                nextLoc: y
                            }, "next" === this.method && (this.arg = d), B
                        }
                    }, t
                }(t.exports);
                try {
                    regeneratorRuntime = d
                } catch (h) {
                    "object" == typeof globalThis ? globalThis.regeneratorRuntime = d : Function("r", "regeneratorRuntime = r")(d)
                }
            },
            8823: function() {
                if ("undefined" == typeof window);
                window.requestIdleCallback = window.requestIdleCallback || function(t) {
                    var d = Date.now();
                    return setTimeout((function() {
                        t({
                            didTimeout: !1,
                            timeRemaining: function() {
                                return Math.max(0, 50 - (Date.now() - d))
                            }
                        })
                    }), 1)
                }, window.cancelIdleCallback = window.cancelIdleCallback || function(t) {
                    clearTimeout(t)
                }
            },
            8439: (t, d, h) => {
                "use strict";

                function SelectorSet() {
                    if (!(this instanceof SelectorSet)) return new SelectorSet;
                    this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = []
                }
                h.d(d, {
                    Z: () => SelectorSet
                });
                var y = window.document.documentElement,
                    _ = y.matches || y.webkitMatchesSelector || y.mozMatchesSelector || y.oMatchesSelector || y.msMatchesSelector;
                SelectorSet.prototype.matchesSelector = function(t, d) {
                    return _.call(t, d)
                }, SelectorSet.prototype.querySelectorAll = function(t, d) {
                    return d.querySelectorAll(t)
                }, SelectorSet.prototype.indexes = [];
                var x = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
                SelectorSet.prototype.indexes.push({
                    name: "ID",
                    selector: function matchIdSelector(t) {
                        var d;
                        if (d = t.match(x)) return d[0].slice(1)
                    },
                    element: function getElementId(t) {
                        if (t.id) return [t.id]
                    }
                });
                var C = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
                SelectorSet.prototype.indexes.push({
                    name: "CLASS",
                    selector: function matchClassSelector(t) {
                        var d;
                        if (d = t.match(C)) return d[0].slice(1)
                    },
                    element: function getElementClassNames(t) {
                        var d = t.className;
                        if (d) {
                            if ("string" == typeof d) return d.split(/\s/);
                            if ("object" == typeof d && "baseVal" in d) return d.baseVal.split(/\s/)
                        }
                    }
                });
                var E, O = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
                SelectorSet.prototype.indexes.push({
                    name: "TAG",
                    selector: function matchTagSelector(t) {
                        var d;
                        if (d = t.match(O)) return d[0].toUpperCase()
                    },
                    element: function getElementTagName(t) {
                        return [t.nodeName.toUpperCase()]
                    }
                }), SelectorSet.prototype.indexes.default = {
                    name: "UNIVERSAL",
                    selector: function() {
                        return !0
                    },
                    element: function() {
                        return [!0]
                    }
                }, E = "function" == typeof window.Map ? window.Map : function() {
                    function Map() {
                        this.map = {}
                    }
                    return Map.prototype.get = function(t) {
                        return this.map[t + " "]
                    }, Map.prototype.set = function(t, d) {
                        this.map[t + " "] = d
                    }, Map
                }();
                var k = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;

                function parseSelectorIndexes(t, d) {
                    var h, y, _, x, C, E, O = (t = t.slice(0).concat(t.default)).length,
                        z = d,
                        A = [];
                    do {
                        if (k.exec(""), (_ = k.exec(z)) && (z = _[3], _[2] || !z))
                            for (h = 0; h < O; h++)
                                if (C = (E = t[h]).selector(_[1])) {
                                    for (y = A.length, x = !1; y--;)
                                        if (A[y].index === E && A[y].key === C) {
                                            x = !0;
                                            break
                                        } x || A.push({
                                        index: E,
                                        key: C
                                    });
                                    break
                                }
                    } while (_);
                    return A
                }

                function findByPrototype(t, d) {
                    var h, y, _;
                    for (h = 0, y = t.length; h < y; h++)
                        if (_ = t[h], d.isPrototypeOf(_)) return _
                }

                function sortById(t, d) {
                    return t.id - d.id
                }
                SelectorSet.prototype.logDefaultIndexUsed = function() {}, SelectorSet.prototype.add = function(t, d) {
                    var h, y, _, x, C, O, k, z, A = this.activeIndexes,
                        B = this.selectors,
                        I = this.selectorObjects;
                    if ("string" == typeof t) {
                        for (I[(h = {
                                id: this.uid++,
                                selector: t,
                                data: d
                            }).id] = h, k = parseSelectorIndexes(this.indexes, t), y = 0; y < k.length; y++) x = (z = k[y]).key, (C = findByPrototype(A, _ = z.index)) || ((C = Object.create(_)).map = new E, A.push(C)), _ === this.indexes.default && this.logDefaultIndexUsed(h), (O = C.map.get(x)) || (O = [], C.map.set(x, O)), O.push(h);
                        this.size++, B.push(t)
                    }
                }, SelectorSet.prototype.remove = function(t, d) {
                    if ("string" == typeof t) {
                        var h, y, _, x, C, E, O, k, z = this.activeIndexes,
                            A = this.selectors = [],
                            B = this.selectorObjects,
                            I = {},
                            q = 1 === arguments.length;
                        for (h = parseSelectorIndexes(this.indexes, t), _ = 0; _ < h.length; _++)
                            for (y = h[_], x = z.length; x--;)
                                if (E = z[x], y.index.isPrototypeOf(E)) {
                                    if (O = E.map.get(y.key))
                                        for (C = O.length; C--;)(k = O[C]).selector !== t || !q && k.data !== d || (O.splice(C, 1), I[k.id] = !0);
                                    break
                                } for (_ in I) delete B[_], this.size--;
                        for (_ in B) A.push(B[_].selector)
                    }
                }, SelectorSet.prototype.queryAll = function(t) {
                    if (!this.selectors.length) return [];
                    var d, h, y, _, x, C, E, O, k = {},
                        z = [],
                        A = this.querySelectorAll(this.selectors.join(", "), t);
                    for (d = 0, y = A.length; d < y; d++)
                        for (x = A[d], h = 0, _ = (C = this.matches(x)).length; h < _; h++) k[(O = C[h]).id] ? E = k[O.id] : (E = {
                            id: O.id,
                            selector: O.selector,
                            data: O.data,
                            elements: []
                        }, k[O.id] = E, z.push(E)), E.elements.push(x);
                    return z.sort(sortById)
                }, SelectorSet.prototype.matches = function(t) {
                    if (!t) return [];
                    var d, h, y, _, x, C, E, O, k, z, A, B = this.activeIndexes,
                        I = {},
                        q = [];
                    for (d = 0, _ = B.length; d < _; d++)
                        if (O = (E = B[d]).element(t))
                            for (h = 0, x = O.length; h < x; h++)
                                if (k = E.map.get(O[h]))
                                    for (y = 0, C = k.length; y < C; y++) !I[A = (z = k[y]).id] && this.matchesSelector(t, z.selector) && (I[A] = !0, q.push(z));
                    return q.sort(sortById)
                }
            },
            6376: (t, d, h) => {
                const y = h(4225),
                    {
                        MAX_LENGTH: _,
                        MAX_SAFE_INTEGER: x
                    } = h(3295),
                    {
                        re: C,
                        t: E
                    } = h(5765),
                    O = h(2893),
                    {
                        compareIdentifiers: k
                    } = h(6742);
                class SemVer {
                    constructor(t, d) {
                        if (d = O(d), t instanceof SemVer) {
                            if (t.loose === !!d.loose && t.includePrerelease === !!d.includePrerelease) return t;
                            t = t.version
                        } else if ("string" != typeof t) throw new TypeError(`Invalid Version: ${t}`);
                        if (t.length > _) throw new TypeError(`version is longer than ${_} characters`);
                        y("SemVer", t, d), this.options = d, this.loose = !!d.loose, this.includePrerelease = !!d.includePrerelease;
                        const h = t.trim().match(d.loose ? C[E.LOOSE] : C[E.FULL]);
                        if (!h) throw new TypeError(`Invalid Version: ${t}`);
                        if (this.raw = t, this.major = +h[1], this.minor = +h[2], this.patch = +h[3], this.major > x || this.major < 0) throw new TypeError("Invalid major version");
                        if (this.minor > x || this.minor < 0) throw new TypeError("Invalid minor version");
                        if (this.patch > x || this.patch < 0) throw new TypeError("Invalid patch version");
                        h[4] ? this.prerelease = h[4].split(".").map((t => {
                            if (/^[0-9]+$/.test(t)) {
                                const d = +t;
                                if (d >= 0 && d < x) return d
                            }
                            return t
                        })) : this.prerelease = [], this.build = h[5] ? h[5].split(".") : [], this.format()
                    }
                    format() {
                        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version
                    }
                    toString() {
                        return this.version
                    }
                    compare(t) {
                        if (y("SemVer.compare", this.version, this.options, t), !(t instanceof SemVer)) {
                            if ("string" == typeof t && t === this.version) return 0;
                            t = new SemVer(t, this.options)
                        }
                        return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t)
                    }
                    compareMain(t) {
                        return t instanceof SemVer || (t = new SemVer(t, this.options)), k(this.major, t.major) || k(this.minor, t.minor) || k(this.patch, t.patch)
                    }
                    comparePre(t) {
                        if (t instanceof SemVer || (t = new SemVer(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
                        if (!this.prerelease.length && t.prerelease.length) return 1;
                        if (!this.prerelease.length && !t.prerelease.length) return 0;
                        let d = 0;
                        do {
                            const h = this.prerelease[d],
                                _ = t.prerelease[d];
                            if (y("prerelease compare", d, h, _), void 0 === h && void 0 === _) return 0;
                            if (void 0 === _) return 1;
                            if (void 0 === h) return -1;
                            if (h !== _) return k(h, _)
                        } while (++d)
                    }
                    compareBuild(t) {
                        t instanceof SemVer || (t = new SemVer(t, this.options));
                        let d = 0;
                        do {
                            const h = this.build[d],
                                _ = t.build[d];
                            if (y("prerelease compare", d, h, _), void 0 === h && void 0 === _) return 0;
                            if (void 0 === _) return 1;
                            if (void 0 === h) return -1;
                            if (h !== _) return k(h, _)
                        } while (++d)
                    }
                    inc(t, d) {
                        switch (t) {
                            case "premajor":
                                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", d);
                                break;
                            case "preminor":
                                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", d);
                                break;
                            case "prepatch":
                                this.prerelease.length = 0, this.inc("patch", d), this.inc("pre", d);
                                break;
                            case "prerelease":
                                0 === this.prerelease.length && this.inc("patch", d), this.inc("pre", d);
                                break;
                            case "major":
                                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                                break;
                            case "minor":
                                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                                break;
                            case "patch":
                                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                                break;
                            case "pre":
                                if (0 === this.prerelease.length) this.prerelease = [0];
                                else {
                                    let t = this.prerelease.length;
                                    for (; --t >= 0;) "number" == typeof this.prerelease[t] && (this.prerelease[t]++, t = -2); - 1 === t && this.prerelease.push(0)
                                }
                                d && (this.prerelease[0] === d ? isNaN(this.prerelease[1]) && (this.prerelease = [d, 0]) : this.prerelease = [d, 0]);
                                break;
                            default:
                                throw new Error(`invalid increment argument: ${t}`)
                        }
                        return this.format(), this.raw = this.version, this
                    }
                }
                t.exports = SemVer
            },
            3959: (t, d, h) => {
                const {
                    MAX_LENGTH: y
                } = h(3295), {
                    re: _,
                    t: x
                } = h(5765), C = h(6376), E = h(2893);
                t.exports = (t, d) => {
                    if (d = E(d), t instanceof C) return t;
                    if ("string" != typeof t) return null;
                    if (t.length > y) return null;
                    if (!(d.loose ? _[x.LOOSE] : _[x.FULL]).test(t)) return null;
                    try {
                        return new C(t, d)
                    } catch (h) {
                        return null
                    }
                }
            },
            6397: (t, d, h) => {
                const y = h(3959);
                t.exports = (t, d) => {
                    const h = y(t, d);
                    return h ? h.version : null
                }
            },
            3295: t => {
                const d = Number.MAX_SAFE_INTEGER || 9007199254740991;
                t.exports = {
                    SEMVER_SPEC_VERSION: "2.0.0",
                    MAX_LENGTH: 256,
                    MAX_SAFE_INTEGER: d,
                    MAX_SAFE_COMPONENT_LENGTH: 16
                }
            },
            4225: t => {
                const d = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {};
                t.exports = d
            },
            6742: t => {
                const d = /^[0-9]+$/,
                    compareIdentifiers = (t, h) => {
                        const y = d.test(t),
                            _ = d.test(h);
                        return y && _ && (t = +t, h = +h), t === h ? 0 : y && !_ ? -1 : _ && !y ? 1 : t < h ? -1 : 1
                    };
                t.exports = {
                    compareIdentifiers,
                    rcompareIdentifiers: (t, d) => compareIdentifiers(d, t)
                }
            },
            2893: t => {
                const d = ["includePrerelease", "loose", "rtl"];
                t.exports = t => t ? "object" != typeof t ? {
                    loose: !0
                } : d.filter((d => t[d])).reduce(((t, d) => (t[d] = !0, t)), {}) : {}
            },
            5765: (t, d, h) => {
                const {
                    MAX_SAFE_COMPONENT_LENGTH: y
                } = h(3295), _ = h(4225), x = (d = t.exports = {}).re = [], C = d.src = [], E = d.t = {};
                let O = 0;
                const createToken = (t, d, h) => {
                    const y = O++;
                    _(y, d), E[t] = y, C[y] = d, x[y] = new RegExp(d, h ? "g" : void 0)
                };
                createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+"), createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${C[E.NUMERICIDENTIFIER]})\\.(${C[E.NUMERICIDENTIFIER]})\\.(${C[E.NUMERICIDENTIFIER]})`), createToken("MAINVERSIONLOOSE", `(${C[E.NUMERICIDENTIFIERLOOSE]})\\.(${C[E.NUMERICIDENTIFIERLOOSE]})\\.(${C[E.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASEIDENTIFIER", `(?:${C[E.NUMERICIDENTIFIER]}|${C[E.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${C[E.NUMERICIDENTIFIERLOOSE]}|${C[E.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASE", `(?:-(${C[E.PRERELEASEIDENTIFIER]}(?:\\.${C[E.PRERELEASEIDENTIFIER]})*))`), createToken("PRERELEASELOOSE", `(?:-?(${C[E.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${C[E.PRERELEASEIDENTIFIERLOOSE]})*))`), createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), createToken("BUILD", `(?:\\+(${C[E.BUILDIDENTIFIER]}(?:\\.${C[E.BUILDIDENTIFIER]})*))`), createToken("FULLPLAIN", `v?${C[E.MAINVERSION]}${C[E.PRERELEASE]}?${C[E.BUILD]}?`), createToken("FULL", `^${C[E.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${C[E.MAINVERSIONLOOSE]}${C[E.PRERELEASELOOSE]}?${C[E.BUILD]}?`), createToken("LOOSE", `^${C[E.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), createToken("XRANGEIDENTIFIERLOOSE", `${C[E.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), createToken("XRANGEIDENTIFIER", `${C[E.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${C[E.XRANGEIDENTIFIER]})(?:\\.(${C[E.XRANGEIDENTIFIER]})(?:\\.(${C[E.XRANGEIDENTIFIER]})(?:${C[E.PRERELEASE]})?${C[E.BUILD]}?)?)?`), createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${C[E.XRANGEIDENTIFIERLOOSE]})(?:\\.(${C[E.XRANGEIDENTIFIERLOOSE]})(?:\\.(${C[E.XRANGEIDENTIFIERLOOSE]})(?:${C[E.PRERELEASELOOSE]})?${C[E.BUILD]}?)?)?`), createToken("XRANGE", `^${C[E.GTLT]}\\s*${C[E.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${C[E.GTLT]}\\s*${C[E.XRANGEPLAINLOOSE]}$`), createToken("COERCE", `(^|[^\\d])(\\d{1,${y}})(?:\\.(\\d{1,${y}}))?(?:\\.(\\d{1,${y}}))?(?:$|[^\\d])`), createToken("COERCERTL", C[E.COERCE], !0), createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${C[E.LONETILDE]}\\s+`, !0), d.tildeTrimReplace = "$1~", createToken("TILDE", `^${C[E.LONETILDE]}${C[E.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${C[E.LONETILDE]}${C[E.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${C[E.LONECARET]}\\s+`, !0), d.caretTrimReplace = "$1^", createToken("CARET", `^${C[E.LONECARET]}${C[E.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${C[E.LONECARET]}${C[E.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${C[E.GTLT]}\\s*(${C[E.LOOSEPLAIN]})$|^$`), createToken("COMPARATOR", `^${C[E.GTLT]}\\s*(${C[E.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${C[E.GTLT]}\\s*(${C[E.LOOSEPLAIN]}|${C[E.XRANGEPLAIN]})`, !0), d.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${C[E.XRANGEPLAIN]})\\s+-\\s+(${C[E.XRANGEPLAIN]})\\s*$`), createToken("HYPHENRANGELOOSE", `^\\s*(${C[E.XRANGEPLAINLOOSE]})\\s+-\\s+(${C[E.XRANGEPLAINLOOSE]})\\s*$`), createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$")
            },
            6031: function(t, d) {
                var h;
                ! function(y, _) {
                    "use strict";
                    h = function() {
                        var t = function() {
                            var noop = function() {},
                                t = 8,
                                d = 46,
                                h = 37,
                                y = 39,
                                _ = {
                                    additionalTagClasses: "",
                                    allowDuplicates: !1,
                                    saveOnBlur: !1,
                                    clearOnBlur: !0,
                                    duplicateTagClass: "",
                                    containerFocusClass: "active",
                                    focusInputOnContainerClick: !0,
                                    hiddenInputName: "taggles[]",
                                    tags: [],
                                    delimeter: ",",
                                    delimiter: "",
                                    attachTagId: !1,
                                    allowedTags: [],
                                    disallowedTags: [],
                                    trimTags: !0,
                                    maxTags: null,
                                    tabIndex: 1,
                                    placeholder: "Enter tags...",
                                    submitKeys: [188, 9, 13],
                                    preserveCase: !1,
                                    inputFormatter: noop,
                                    tagFormatter: noop,
                                    onBeforeTagAdd: noop,
                                    onTagAdd: noop,
                                    onBeforeTagRemove: function() {
                                        return !0
                                    },
                                    onTagRemove: noop
                                };

                            function _extend() {
                                for (var t = arguments[0], d = 1, h = arguments.length; d < h; d++) {
                                    var y = arguments[d];
                                    for (var _ in y) y.hasOwnProperty(_) && (t[_] = y[_])
                                }
                                return t
                            }

                            function _isArray(t) {
                                return Array.isArray ? Array.isArray(t) : "[object Array]" === Object.prototype.toString.call(t)
                            }

                            function _on(t, d, h) {
                                t.addEventListener ? t.addEventListener(d, h, !1) : t.attachEvent ? t.attachEvent("on" + d, h) : t["on" + d] = h
                            }

                            function _off(t, d, h) {
                                t.removeEventListener ? t.removeEventListener(d, h, !1) : t.detachEvent ? t.detachEvent("on" + d, h) : t["on" + d] = null
                            }

                            function _trim(t) {
                                return t.replace(/^\s+|\s+$/g, "")
                            }

                            function _setText(t, d) {
                                window.attachEvent && !window.addEventListener ? t.innerText = d : t.textContent = d
                            }

                            function _clamp(t, d, h) {
                                return Math.min(Math.max(t, d), h)
                            }
                            var Taggle = function(t, d) {
                                this.settings = _extend({}, _, d), this.measurements = {
                                    container: {
                                        rect: null,
                                        style: null,
                                        padding: null
                                    }
                                }, this.container = t, this.tag = {
                                    values: [],
                                    elements: []
                                }, this.list = document.createElement("ul"), this.inputLi = document.createElement("li"), this.input = document.createElement("input"), this.sizer = document.createElement("div"), this.pasting = !1, this.placeholder = null, this.data = null, this.settings.placeholder && (this.placeholder = document.createElement("span")), "string" == typeof t && (this.container = document.getElementById(t)), this._id = 0, this._backspacePressed = !1, this._inputPosition = 0, this._closeEvents = [], this._closeButtons = [], this._setMeasurements(), this._setupTextarea(), this._attachEvents()
                            };
                            return Taggle.prototype._setMeasurements = function() {
                                this.measurements.container.rect = this.container.getBoundingClientRect(), this.measurements.container.style = window.getComputedStyle(this.container);
                                var t = this.measurements.container.style,
                                    d = parseInt(t["padding-left"] || t.paddingLeft, 10),
                                    h = parseInt(t["padding-right"] || t.paddingRight, 10),
                                    y = parseInt(t["border-left-width"] || t.borderLeftWidth, 10),
                                    _ = parseInt(t["border-right-width"] || t.borderRightWidth, 10);
                                this.measurements.container.padding = d + h + y + _
                            }, Taggle.prototype._setupTextarea = function() {
                                var t;
                                if (this.list.className = "taggle_list", this.input.type = "text", this.input.style.paddingLeft = 0, this.input.style.paddingRight = 0, this.input.className = "taggle_input", this.input.tabIndex = this.settings.tabIndex, this.sizer.className = "taggle_sizer", this.settings.tags.length)
                                    for (var d = 0, h = this.settings.tags.length; d < h; d++) {
                                        var y = this._createTag(this.settings.tags[d], this.tag.values.length);
                                        this.list.appendChild(y)
                                    }
                                this.placeholder && (this._hidePlaceholder(), this.placeholder.classList.add("taggle_placeholder"), this.container.appendChild(this.placeholder), _setText(this.placeholder, this.settings.placeholder), this.settings.tags.length || this._showPlaceholder());
                                var _ = this.settings.inputFormatter(this.input);
                                _ && (this.input = _), this.inputLi.appendChild(this.input), this.list.appendChild(this.inputLi), this.container.appendChild(this.list), this.container.appendChild(this.sizer), t = window.getComputedStyle(this.input).fontSize, this.sizer.style.fontSize = t
                            }, Taggle.prototype._attachEvents = function() {
                                var t = this;
                                if (this._eventsAttached) return !1;

                                function containerClick() {
                                    t.input.focus()
                                }
                                return this._eventsAttached = !0, this.settings.focusInputOnContainerClick && (this._handleContainerClick = containerClick.bind(this), _on(this.container, "click", this._handleContainerClick)), this._handleFocus = this._setFocusStateForContainer.bind(this), this._handleBlur = this._blurEvent.bind(this), this._handleKeydown = this._keydownEvents.bind(this), this._handleKeyup = this._keyupEvents.bind(this), _on(this.input, "focus", this._handleFocus), _on(this.input, "blur", this._handleBlur), _on(this.input, "keydown", this._handleKeydown), _on(this.input, "keyup", this._handleKeyup), !0
                            }, Taggle.prototype._detachEvents = function() {
                                if (!this._eventsAttached) return !1;
                                var t = this;
                                return this._eventsAttached = !1, _off(this.container, "click", this._handleContainerClick), _off(this.input, "focus", this._handleFocus), _off(this.input, "blur", this._handleBlur), _off(this.input, "keydown", this._handleKeydown), _off(this.input, "keyup", this._handleKeyup), this._closeButtons.forEach((function(d, h) {
                                    _off(d, "click", t._closeEvents[h])
                                })), !0
                            }, Taggle.prototype._fixInputWidth = function() {
                                this._setMeasurements(), this._setInputWidth()
                            }, Taggle.prototype._canAdd = function(t, d) {
                                if (!d) return !1;
                                var h = this.settings.maxTags;
                                if (null !== h && h <= this.getTagValues().length) return !1;
                                if (!1 === this.settings.onBeforeTagAdd(t, d)) return !1;
                                if (!this.settings.allowDuplicates && this._hasDupes(d)) return !1;
                                var y = this.settings.preserveCase,
                                    _ = this.settings.allowedTags;
                                if (_.length && !this._tagIsInArray(d, _, y)) return !1;
                                var x = this.settings.disallowedTags;
                                return !x.length || !this._tagIsInArray(d, x, y)
                            }, Taggle.prototype._tagIsInArray = function(t, d, h) {
                                return h ? -1 !== d.indexOf(t) : -1 !== [].slice.apply(d).map((function(t) {
                                    return t.toLowerCase()
                                })).indexOf(t)
                            }, Taggle.prototype._add = function(t, d, h) {
                                var y = this,
                                    _ = d || "",
                                    x = this.settings.delimiter || this.settings.delimeter;
                                "string" != typeof d && (_ = this.input.value, this.settings.trimTags && (_[0] === x && (_ = _.replace(x, "")), _ = _trim(_))), _.split(x).map((function(t) {
                                    return y.settings.trimTags && (t = _trim(t)), y._formatTag(t)
                                })).forEach((function(d) {
                                    if (y._canAdd(t, d)) {
                                        var _ = y.tag.values.length,
                                            x = _clamp(h || _, 0, _),
                                            C = y._createTag(d, x),
                                            E = y.list.children[x];
                                        y.list.insertBefore(C, E), d = y.tag.values[x], y.settings.onTagAdd(t, d), y.input.value = "", y._fixInputWidth(), y._setFocusStateForContainer()
                                    }
                                }))
                            }, Taggle.prototype._checkPrevOrNextTag = function(h) {
                                h = h || window.event;
                                var y = this.container.querySelectorAll(".taggle"),
                                    _ = _clamp(this._inputPosition - 1, 0, y.length - 1),
                                    x = _clamp(this._inputPosition, 0, y.length - 1),
                                    C = _;
                                h.keyCode === d && (C = x);
                                var E = y[C],
                                    O = "taggle_hot",
                                    k = -1 !== [t, d].indexOf(h.keyCode);
                                "" === this.input.value && k && !this._backspacePressed ? E.classList.contains(O) ? (this._backspacePressed = !0, this._remove(E, h), this._fixInputWidth(), this._setFocusStateForContainer()) : E.classList.add(O) : E.classList.contains(O) && E.classList.remove(O)
                            }, Taggle.prototype._setInputWidth = function() {
                                var t = this.sizer.getBoundingClientRect().width,
                                    d = this.measurements.container.rect.width - this.measurements.container.padding,
                                    h = parseInt(this.sizer.style.fontSize, 10),
                                    y = Math.round(_clamp(t + 1.5 * h, 10, d));
                                this.input.style.width = y + "px"
                            }, Taggle.prototype._hasDupes = function(t) {
                                var d, h = this.tag.values.indexOf(t),
                                    y = this.container.querySelector(".taggle_list");
                                if (this.settings.duplicateTagClass)
                                    for (var _ = 0, x = (d = y.querySelectorAll("." + this.settings.duplicateTagClass)).length; _ < x; _++) d[_].classList.remove(this.settings.duplicateTagClass);
                                return h > -1 && (this.settings.duplicateTagClass && y.childNodes[h].classList.add(this.settings.duplicateTagClass), !0)
                            }, Taggle.prototype._isConfirmKey = function(t) {
                                var d = !1;
                                return this.settings.submitKeys.indexOf(t) > -1 && (d = !0), d
                            }, Taggle.prototype._setFocusStateForContainer = function() {
                                this._fixInputWidth(), this.container.classList.contains(this.settings.containerFocusClass) || this.container.classList.add(this.settings.containerFocusClass), this._hidePlaceholder()
                            }, Taggle.prototype._blurEvent = function(t) {
                                if (this.container.classList.contains(this.settings.containerFocusClass) && this.container.classList.remove(this.settings.containerFocusClass), this.settings.saveOnBlur) {
                                    if (t = t || window.event, this._setInputWidth(), "" !== this.input.value) return void this._confirmValidTagEvent(t);
                                    this.tag.values.length && this._checkPrevOrNextTag(t)
                                } else this.settings.clearOnBlur && (this.input.value = "", this._setInputWidth());
                                this.tag.values.length || this.input.value || this._showPlaceholder()
                            }, Taggle.prototype._keydownEvents = function(t) {
                                var d = (t = t || window.event).keyCode;
                                this.pasting = !1, this._setInputWidth(), 86 === d && t.metaKey && (this.pasting = !0), this._isConfirmKey(d) && "" !== this.input.value ? this._confirmValidTagEvent(t) : this.tag.values.length && this._checkPrevOrNextTag(t)
                            }, Taggle.prototype._keyupEvents = function(t) {
                                t = t || window.event, this._backspacePressed = !1, -1 === [h, y].indexOf(t.keyCode) ? (_setText(this.sizer, this.input.value), this.input.value || this._setInputWidth(), this.pasting && "" !== this.input.value && (this._add(t), this.pasting = !1)) : this._moveInput(t.keyCode)
                            }, Taggle.prototype._moveInput = function(t) {
                                var d = this._inputPosition;
                                switch (t) {
                                    case h:
                                        var _ = _clamp(this._inputPosition - 1, 0, this.tag.values.length),
                                            x = d !== _;
                                        this._inputPosition = _, x && (this.list.insertBefore(this.inputLi, this.list.childNodes[_] || null), this.input.focus());
                                        break;
                                    case y:
                                        var C = _clamp(this._inputPosition + 1, 0, this.tag.values.length),
                                            E = d !== C;
                                        this._inputPosition = C, E && (this.list.insertBefore(this.inputLi, this.list.childNodes[C + 1] || null), this.input.focus())
                                }
                            }, Taggle.prototype._confirmValidTagEvent = function(t) {
                                (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1, this._add(t, null, this._inputPosition)
                            }, Taggle.prototype._createTag = function(t, d) {
                                var h = document.createElement("li"),
                                    y = document.createElement("button"),
                                    _ = document.createElement("input"),
                                    x = document.createElement("span");
                                t = this._formatTag(t), _setText(y, "Ã—"), y.className = "close", y.setAttribute("type", "button");
                                var C = this._remove.bind(this, y);
                                _on(y, "click", C), _setText(x, t), x.className = "taggle_text", h.className = "taggle " + this.settings.additionalTagClasses, _.type = "hidden", _.value = t, _.name = this.settings.hiddenInputName, h.appendChild(x), h.appendChild(y), h.appendChild(_);
                                var E = this.settings.tagFormatter(h);
                                if (void 0 !== E && (h = E), !(h instanceof HTMLElement) || "li" !== h.localName && "LI" !== h.tagName) throw new Error("tagFormatter must return an li element");
                                return this.settings.attachTagId && (this._id += 1, t = {
                                    text: t,
                                    id: this._id
                                }), this.tag.values.splice(d, 0, t), this.tag.elements.splice(d, 0, h), this._closeEvents.splice(d, 0, C), this._closeButtons.splice(d, 0, y), this._inputPosition = _clamp(this._inputPosition + 1, 0, this.tag.values.length), h
                            }, Taggle.prototype._showPlaceholder = function() {
                                this.placeholder && (this.placeholder.style.opacity = 1, this.placeholder.setAttribute("aria-hidden", "false"))
                            }, Taggle.prototype._hidePlaceholder = function() {
                                this.placeholder && (this.placeholder.style.opacity = 0, this.placeholder.setAttribute("aria-hidden", "true"))
                            }, Taggle.prototype._remove = function(t, d) {
                                var h, y, _, x = this;

                                function done(y) {
                                    if (!y) {
                                        var C = x._closeEvents[_];
                                        _off(x._closeButtons[_], "click", C), t.parentNode.removeChild(t), x.tag.elements.splice(_, 1), x.tag.values.splice(_, 1), x._closeEvents.splice(_, 1), x._closeButtons.splice(_, 1), x.settings.onTagRemove(d, h), _ < x._inputPosition && (x._inputPosition = _clamp(x._inputPosition - 1, 0, x.tag.values.length)), x._setFocusStateForContainer()
                                    }
                                }
                                "li" !== t.tagName.toLowerCase() && (t = t.parentNode), y = "a" === t.tagName.toLowerCase() ? t.parentNode : t, _ = this.tag.elements.indexOf(y), h = this.tag.values[_], this.settings.onBeforeTagRemove(d, h, done) && done()
                            }, Taggle.prototype._formatTag = function(t) {
                                return this.settings.preserveCase ? t : t.toLowerCase()
                            }, Taggle.prototype._isIndexInRange = function(t) {
                                return t >= 0 && t <= this.tag.values.length - 1
                            }, Taggle.prototype.getTags = function() {
                                return {
                                    elements: this.getTagElements(),
                                    values: this.getTagValues()
                                }
                            }, Taggle.prototype.getTagElements = function() {
                                return [].slice.apply(this.tag.elements)
                            }, Taggle.prototype.getTagValues = function() {
                                return [].slice.apply(this.tag.values)
                            }, Taggle.prototype.getInput = function() {
                                return this.input
                            }, Taggle.prototype.getContainer = function() {
                                return this.container
                            }, Taggle.prototype.add = function(t, d) {
                                if (_isArray(t))
                                    for (var h = d, y = 0, _ = t.length; y < _; y++) "string" == typeof t[y] && (this._add(null, t[y], h), isNaN(h) || (h += 1));
                                else this._add(null, t, d);
                                return this
                            }, Taggle.prototype.edit = function(t, d) {
                                if ("string" != typeof t) throw new Error("First edit argument must be of type string");
                                if ("number" != typeof d) throw new Error("Second edit argument must be a number");
                                if (!this._isIndexInRange(d)) throw new Error("Edit index should be between 0 and " + this.tag.values.length - 1);
                                return "string" == typeof this.tag.values[d] ? this.tag.values[d] = t : this.tag.values[d].text = t, _setText(this.tag.elements[d], t), this
                            }, Taggle.prototype.move = function(t, d) {
                                if ("number" != typeof t || "number" != typeof d) throw new Error("Both arguments must be numbers");
                                if (!this._isIndexInRange(t)) throw new Error("First index should be between 0 and " + this.tag.values.length - 1);
                                if (!this._isIndexInRange(d)) throw new Error("Second index should be between 0 and " + this.tag.values.length - 1);
                                if (t === d) return this;
                                var h = this.tag.values[t],
                                    y = this.tag.elements[t],
                                    _ = this.tag.elements[d],
                                    x = this._closeEvents[t],
                                    C = this._closeButtons[t];
                                return this.tag.values.splice(t, 1), this.tag.elements.splice(t, 1), this._closeEvents.splice(t, 1), this._closeButtons.splice(t, 1), this.tag.values.splice(d, 0, h), this.tag.elements.splice(d, 0, y), this._closeEvents.splice(t, 0, x), this._closeButtons.splice(t, 0, C), this.list.insertBefore(y, _.nextSibling), this
                            }, Taggle.prototype.remove = function(t, d) {
                                for (var h = this.tag.values.length - 1, y = !1; h > -1;) {
                                    var _ = this.tag.values[h];
                                    if (this.settings.attachTagId && (_ = _.text), _ === t && (y = !0, this._remove(this.tag.elements[h])), y && !d) break;
                                    h--
                                }
                                return this
                            }, Taggle.prototype.removeAll = function() {
                                for (var t = this.tag.values.length - 1; t >= 0; t--) this._remove(this.tag.elements[t]);
                                return this._showPlaceholder(), this
                            }, Taggle.prototype.setOptions = function(t) {
                                return this.settings = _extend({}, this.settings, t || {}), this
                            }, Taggle.prototype.enable = function() {
                                var t = [].slice.call(this.container.querySelectorAll("button")),
                                    d = [].slice.call(this.container.querySelectorAll("input"));
                                return t.concat(d).forEach((function(t) {
                                    t.removeAttribute("disabled")
                                })), this
                            }, Taggle.prototype.disable = function() {
                                var t = [].slice.call(this.container.querySelectorAll("button")),
                                    d = [].slice.call(this.container.querySelectorAll("input"));
                                return t.concat(d).forEach((function(t) {
                                    t.setAttribute("disabled", "")
                                })), this
                            }, Taggle.prototype.setData = function(t) {
                                return this.data = t, this
                            }, Taggle.prototype.getData = function() {
                                return this.data
                            }, Taggle.prototype.attachEvents = function() {
                                var t = this;
                                return this._attachEvents() && this._closeButtons.forEach((function(d, h) {
                                    _on(d, "click", t._closeEvents[h])
                                })), this
                            }, Taggle.prototype.removeEvents = function() {
                                return this._detachEvents(), this
                            }, Taggle
                        }();
                        return y.Taggle = t, t
                    }.apply(d, []), void 0 === h || (t.exports = h)
                }(this)
            },
            4598: () => {},
            4126: (t, d, h) => {
                "use strict";

                function autoShadowRoot(t) {
                    for (const d of t.querySelectorAll("template[data-shadowroot]")) d.parentElement === t && t.attachShadow({
                        mode: "closed" === d.getAttribute("data-shadowroot") ? "closed" : "open"
                    }).append(d.content.cloneNode(!0))
                }
                h.d(d, {
                    U: () => autoShadowRoot
                })
            },
            5451: (t, d, h) => {
                "use strict";

                function findTarget(t, d) {
                    const h = t.tagName.toLowerCase();
                    if (t.shadowRoot)
                        for (const y of t.shadowRoot.querySelectorAll(`[data-target~="${h}.${d}"]`))
                            if (!y.closest(h)) return y;
                    for (const y of t.querySelectorAll(`[data-target~="${h}.${d}"]`))
                        if (y.closest(h) === t) return y
                }

                function findTargets(t, d) {
                    const h = t.tagName.toLowerCase(),
                        y = [];
                    if (t.shadowRoot)
                        for (const _ of t.shadowRoot.querySelectorAll(`[data-targets~="${h}.${d}"]`)) _.closest(h) || y.push(_);
                    for (const _ of t.querySelectorAll(`[data-targets~="${h}.${d}"]`)) _.closest(h) === t && y.push(_);
                    return y
                }
                h.d(d, {
                    P: () => findTarget,
                    E: () => findTargets
                })
            },
            8136: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    attr: () => attr,
                    autoShadowRoot: () => O.U,
                    bind: () => bind,
                    controller: () => controller,
                    defineObservedAttributes: () => defineObservedAttributes,
                    findTarget: () => C.P,
                    findTargets: () => C.E,
                    initializeAttrs: () => initializeAttrs,
                    listenForBind: () => listenForBind,
                    register: () => x.z,
                    target: () => E.f,
                    targets: () => E.G
                });
                const y = new WeakSet;

                function bind(t) {
                    y.add(t), t.shadowRoot && bindShadow(t.shadowRoot), bindElements(t), listenForBind(t.ownerDocument)
                }

                function bindShadow(t) {
                    bindElements(t), listenForBind(t)
                }
                const _ = new WeakMap;

                function listenForBind(t = document) {
                    if (_.has(t)) return _.get(t);
                    let d = !1;
                    const h = new MutationObserver((t => {
                        for (const d of t)
                            if ("attributes" === d.type && d.target instanceof Element) bindActions(d.target);
                            else if ("childList" === d.type && d.addedNodes.length)
                            for (const t of d.addedNodes) t instanceof Element && bindElements(t)
                    }));
                    h.observe(t, {
                        childList: !0,
                        subtree: !0,
                        attributeFilter: ["data-action"]
                    });
                    const y = {
                        get closed() {
                            return d
                        },
                        unsubscribe() {
                            d = !0, _.delete(t), h.disconnect()
                        }
                    };
                    return _.set(t, y), y
                }

                function bindElements(t) {
                    for (const d of t.querySelectorAll("[data-action]")) bindActions(d);
                    t instanceof Element && t.hasAttribute("data-action") && bindActions(t)
                }

                function handleEvent(t) {
                    const d = t.currentTarget;
                    for (const h of bindings(d))
                        if (t.type === h.type) {
                            const _ = d.closest(h.tag);
                            y.has(_) && "function" == typeof _[h.method] && _[h.method](t);
                            const x = d.getRootNode();
                            if (x instanceof ShadowRoot && y.has(x.host) && x.host.matches(h.tag)) {
                                const d = x.host;
                                "function" == typeof d[h.method] && d[h.method](t)
                            }
                        }
                }

                function* bindings(t) {
                    for (const d of (t.getAttribute("data-action") || "").trim().split(/\s+/)) {
                        const t = d.lastIndexOf(":"),
                            h = d.lastIndexOf("#");
                        yield {
                            type: d.slice(0, t),
                            tag: d.slice(t + 1, h),
                            method: d.slice(h + 1)
                        }
                    }
                }

                function bindActions(t) {
                    for (const d of bindings(t)) t.addEventListener(d.type, handleEvent)
                }
                var x = h(4604),
                    C = h(5451),
                    E = h(2095),
                    O = h(4126);
                const k = new WeakMap;

                function attr(t, d) {
                    k.has(t) || k.set(t, []), k.get(t).push(d)
                }

                function initializeAttrs(t, d) {
                    d || (d = getAttrNames(Object.getPrototypeOf(t)));
                    for (const h of d) {
                        const d = t[h],
                            y = attrToAttributeName(h);
                        let _ = {
                            get() {
                                return this.getAttribute(y) || ""
                            },
                            set(t) {
                                this.setAttribute(y, t || "")
                            }
                        };
                        "number" == typeof d ? _ = {
                            get() {
                                return Number(this.getAttribute(y) || 0)
                            },
                            set(t) {
                                this.setAttribute(y, t)
                            }
                        } : "boolean" == typeof d && (_ = {
                            get() {
                                return this.hasAttribute(y)
                            },
                            set(t) {
                                this.toggleAttribute(y, t)
                            }
                        }), Object.defineProperty(t, h, _), h in t && !t.hasAttribute(y) && _.set.call(t, d)
                    }
                }

                function getAttrNames(t) {
                    const d = new Set;
                    let h = t;
                    for (; h && h !== HTMLElement;) {
                        const t = k.get(h) || [];
                        for (const h of t) d.add(h);
                        h = Object.getPrototypeOf(h)
                    }
                    return d
                }

                function attrToAttributeName(t) {
                    return `data-${t.replace(/([A-Z]($|[a-z]))/g,"-$1")}`.replace(/--/g, "-").toLowerCase()
                }

                function defineObservedAttributes(t) {
                    let d = t.observedAttributes || [];
                    Object.defineProperty(t, "observedAttributes", {
                        get: () => [...getAttrNames(t.prototype)].map(attrToAttributeName).concat(d),
                        set(t) {
                            d = t
                        }
                    })
                }

                function controller(t) {
                    const d = t.prototype.connectedCallback;
                    t.prototype.connectedCallback = function() {
                        this.toggleAttribute("data-catalyst", !0), (0, O.U)(this), initializeAttrs(this), bind(this), d && d.call(this), this.shadowRoot && bindShadow(this.shadowRoot)
                    }, defineObservedAttributes(t), (0, x.z)(t)
                }
            },
            4604: (t, d, h) => {
                "use strict";

                function register(t) {
                    const d = t.name.replace(/([A-Z]($|[a-z]))/g, "-$1").replace(/(^-|-Element$)/g, "").toLowerCase();
                    window.customElements.get(d) || (window[t.name] = t, window.customElements.define(d, t))
                }
                h.d(d, {
                    z: () => register
                })
            },
            2095: (t, d, h) => {
                "use strict";
                h.d(d, {
                    f: () => target,
                    G: () => targets
                });
                var y = h(5451);

                function target(t, d) {
                    return Object.defineProperty(t, d, {
                        configurable: !0,
                        get() {
                            return (0, y.P)(this, d)
                        }
                    })
                }

                function targets(t, d) {
                    return Object.defineProperty(t, d, {
                        configurable: !0,
                        get() {
                            return (0, y.E)(this, d)
                        }
                    })
                }
            },
            4840: (t, d, h) => {
                "use strict";
                h.r(d), h.d(d, {
                    default: () => C
                });
                const y = "data-close-dialog",
                    _ = `[${y}]`;

                function autofocus(t) {
                    let d = Array.from(t.querySelectorAll("[autofocus]")).filter(focusable)[0];
                    d || (d = t, t.setAttribute("tabindex", "-1")), d.focus()
                }

                function keydown(t) {
                    const d = t.currentTarget;
                    d instanceof Element && ("Escape" === t.key || "Esc" === t.key ? (toggleDetails(d, !1), t.stopPropagation()) : "Tab" === t.key && function restrictTabBehavior(t) {
                        if (!(t.currentTarget instanceof Element)) return;
                        const d = t.currentTarget.querySelector("details-dialog");
                        if (!d) return;
                        t.preventDefault();
                        const h = Array.from(d.querySelectorAll("*")).filter(focusable);
                        if (0 === h.length) return;
                        const y = t.shiftKey ? -1 : 1,
                            _ = d.getRootNode(),
                            x = d.contains(_.activeElement) ? _.activeElement : null;
                        let C = -1 === y ? -1 : 0;
                        if (x instanceof HTMLElement) {
                            const t = h.indexOf(x); - 1 !== t && (C = t + y)
                        }
                        C < 0 ? C = h.length - 1 : C %= h.length;
                        h[C].focus()
                    }(t))
                }

                function focusable(t) {
                    return t.tabIndex >= 0 && !t.disabled && function visible(t) {
                        return !t.hidden && (!t.type || "hidden" !== t.type) && (t.offsetWidth > 0 || t.offsetHeight > 0)
                    }(t)
                }

                function allowClosingDialog(t) {
                    const d = t.querySelector("details-dialog");
                    return !(d instanceof DetailsDialogElement) || d.dispatchEvent(new CustomEvent("details-dialog-close", {
                        bubbles: !0,
                        cancelable: !0
                    }))
                }

                function onSummaryClick(t) {
                    if (!(t.currentTarget instanceof Element)) return;
                    const d = t.currentTarget.closest("details");
                    d && d.hasAttribute("open") && (allowClosingDialog(d) || (t.preventDefault(), t.stopPropagation()))
                }

                function toggle(t) {
                    const d = t.currentTarget;
                    if (!(d instanceof Element)) return;
                    const h = d.querySelector("details-dialog");
                    if (h instanceof DetailsDialogElement)
                        if (d.hasAttribute("open")) {
                            const t = h.getRootNode();
                            t.activeElement instanceof HTMLElement && x.set(h, {
                                details: d,
                                activeElement: t.activeElement
                            }), autofocus(h), d.addEventListener("keydown", keydown)
                        } else {
                            for (const d of h.querySelectorAll("form")) d.reset();
                            const t = function findFocusElement(t, d) {
                                const h = x.get(d);
                                return h && h.activeElement instanceof HTMLElement ? h.activeElement : t.querySelector("summary")
                            }(d, h);
                            t && t.focus(), d.removeEventListener("keydown", keydown)
                        }
                }

                function toggleDetails(t, d) {
                    d !== t.hasAttribute("open") && (d ? t.setAttribute("open", "") : allowClosingDialog(t) && t.removeAttribute("open"))
                }

                function loadIncludeFragment(t) {
                    const d = t.currentTarget;
                    if (!(d instanceof Element)) return;
                    const h = d.querySelector("details-dialog");
                    if (!(h instanceof DetailsDialogElement)) return;
                    const y = h.querySelector("include-fragment:not([src])");
                    if (!y) return;
                    const _ = h.src;
                    null !== _ && (y.addEventListener("loadend", (() => {
                        d.hasAttribute("open") && autofocus(h)
                    })), y.setAttribute("src", _))
                }

                function updateIncludeFragmentEventListeners(t, d, h) {
                    removeIncludeFragmentEventListeners(t), d && t.addEventListener("toggle", loadIncludeFragment, {
                        once: !0
                    }), d && h && t.addEventListener("mouseover", loadIncludeFragment, {
                        once: !0
                    })
                }

                function removeIncludeFragmentEventListeners(t) {
                    t.removeEventListener("toggle", loadIncludeFragment), t.removeEventListener("mouseover", loadIncludeFragment)
                }
                const x = new WeakMap;
                class DetailsDialogElement extends HTMLElement {
                    static get CLOSE_ATTR() {
                        return y
                    }
                    static get CLOSE_SELECTOR() {
                        return _
                    }
                    constructor() {
                        super(), x.set(this, {
                            details: null,
                            activeElement: null
                        }), this.addEventListener("click", (function({
                            target: t
                        }) {
                            if (!(t instanceof Element)) return;
                            const d = t.closest("details");
                            d && t.closest(_) && toggleDetails(d, !1)
                        }))
                    }
                    get src() {
                        return this.getAttribute("src")
                    }
                    set src(t) {
                        this.setAttribute("src", t || "")
                    }
                    get preload() {
                        return this.hasAttribute("preload")
                    }
                    set preload(t) {
                        t ? this.setAttribute("preload", "") : this.removeAttribute("preload")
                    }
                    connectedCallback() {
                        this.setAttribute("role", "dialog"), this.setAttribute("aria-modal", "true");
                        const t = x.get(this);
                        if (!t) return;
                        const d = this.parentElement;
                        if (!d) return;
                        const h = d.querySelector("summary");
                        h && (h.hasAttribute("role") || h.setAttribute("role", "button"), h.addEventListener("click", onSummaryClick, {
                            capture: !0
                        })), d.addEventListener("toggle", toggle), t.details = d, updateIncludeFragmentEventListeners(d, this.src, this.preload)
                    }
                    disconnectedCallback() {
                        const t = x.get(this);
                        if (!t) return;
                        const {
                            details: d
                        } = t;
                        if (!d) return;
                        d.removeEventListener("toggle", toggle), removeIncludeFragmentEventListeners(d);
                        const h = d.querySelector("summary");
                        h && h.removeEventListener("click", onSummaryClick, {
                            capture: !0
                        }), t.details = null
                    }
                    toggle(t) {
                        const d = x.get(this);
                        if (!d) return;
                        const {
                            details: h
                        } = d;
                        h && toggleDetails(h, t)
                    }
                    static get observedAttributes() {
                        return ["src", "preload"]
                    }
                    attributeChangedCallback() {
                        const t = x.get(this);
                        if (!t) return;
                        const {
                            details: d
                        } = t;
                        d && updateIncludeFragmentEventListeners(d, this.src, this.preload)
                    }
                }
                const C = DetailsDialogElement;
                window.customElements.get("details-dialog") || (window.DetailsDialogElement = DetailsDialogElement, window.customElements.define("details-dialog", DetailsDialogElement))
            }
        },
        d = {};

    function __webpack_require__(h) {
        var y = d[h];
        if (void 0 !== y) return y.exports;
        var _ = d[h] = {
            exports: {}
        };
        return t[h].call(_.exports, _, _.exports, __webpack_require__), _.exports
    }
    __webpack_require__.n = t => {
        var d = t && t.__esModule ? () => t.default : () => t;
        return __webpack_require__.d(d, {
            a: d
        }), d
    }, __webpack_require__.d = (t, d) => {
        for (var h in d) __webpack_require__.o(d, h) && !__webpack_require__.o(t, h) && Object.defineProperty(t, h, {
            enumerable: !0,
            get: d[h]
        })
    }, __webpack_require__.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window) return window
        }
    }(), __webpack_require__.o = (t, d) => Object.prototype.hasOwnProperty.call(t, d), __webpack_require__.r = t => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, __webpack_require__(3869), __webpack_require__(8823), __webpack_require__(7363), __webpack_require__(4840), __webpack_require__(8136), __webpack_require__(4260), __webpack_require__(2234), __webpack_require__(987), __webpack_require__(4742), __webpack_require__(2507), __webpack_require__(3596), __webpack_require__(8434), __webpack_require__(2585), __webpack_require__(958), __webpack_require__(4125), __webpack_require__(4282), __webpack_require__(6729), __webpack_require__(1061), __webpack_require__(2925), __webpack_require__(7964), __webpack_require__(263), __webpack_require__(4928), __webpack_require__(4690), __webpack_require__(881), __webpack_require__(13), __webpack_require__(5002), __webpack_require__(1897), __webpack_require__(5777), __webpack_require__(1891), __webpack_require__(4056), __webpack_require__(7414), __webpack_require__(5496), __webpack_require__(1613), __webpack_require__(3939), __webpack_require__(4838), __webpack_require__(3938), __webpack_require__(6663), __webpack_require__(2462), __webpack_require__(6635), __webpack_require__(5382), __webpack_require__(9644)
})();
